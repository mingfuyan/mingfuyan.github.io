[{"title":"SDNU_ACM_ICPC_2020_Winter_Practice_2nd【解题报告】","date":"2020-01-29T02:54:43.243Z","path":"2020/01/29/SDNU_ACM_ICPC_2020_Winter_Practice_2nd【解题报告】/","text":"部分参照 SDNU_ACM_ICPC_2020_Winter_Practice_2nd【解题报告】– The__Flash。欢迎评论提问， 纠错 文章篇幅较长， 请参考右侧文章目录食用。 专题链接： SDNU_ACM_ICPC_2020_Winter_Practice_2nd A HDU 1559 【The__Flash】的矩阵1. 题目大意给你一个m×n的整数矩阵，在上面找一个x×y的子矩阵，使子矩阵中所有元素的和最大。 2. 分析一开始我以为是最大子矩阵和, 做了几个题回来发现就是个二维前缀和. 3. AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int a[1003][1003];int m, n, x, y;int main() &#123; int t; read(t); while(t--)&#123; read(m), read(n), read(x), read(y); for (int i = 0; i &lt; m; ++i)&#123; for (int j = 0; j &lt; n; ++j)&#123; read(a[i][j]); if (i == 0 &amp;&amp; j != 0)&#123; a[i][j] += a[i][j - 1]; &#125; if (i != 0 &amp;&amp; j == 0)&#123; a[i][j] += a[i - 1][j]; &#125; if (i != 0 &amp;&amp; j != 0)&#123; a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]; &#125; &#125; &#125; int ans = 0, temp; x--, y--; for (int i = 0; i &lt; m - x; ++i)&#123; for (int j = 0; j &lt; n - y; ++j)&#123; temp = a[i + x][j + y]; if (i) temp -= a[i - 1][j + y]; if (j) temp -= a[i + x][j - 1]; if (i &amp;&amp; j) temp += a[i - 1][j - 1]; ans = max(ans, temp); &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; B HDU 3790 【The__Flash】的疑惑1. 题目大意给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 2. 分析就是个最短路, 需要维护两个东西, 最短距离和花费. 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e3 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;struct edge&#123; int v, w, c, ne;&#125;ed[200005];int head[N], dis[N], dis1[N], vis[N], cnt;inline void init()&#123; ms(head, -1); ms(dis, INF); ms(dis1, INF); ms(vis, 0); cnt = 0;&#125;inline void add(int u, int v, int w, int c)&#123; ed[cnt] = &#123;v, w, c, head[u]&#125;; head[u] = cnt++;&#125;priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;void dijk(int u)&#123; dis[u] = 0; dis1[u] = 0; q.push(P(0, u)); while(!q.empty())&#123; u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v, w = ed[i].w, c = ed[i].c; // 维护dis 和 dis1 if (dis[v] &gt; dis[u] + w)&#123; dis[v] = dis[u] + w; dis1[v] = dis1[u] + c; q.push(P(dis[v], v)); &#125; else if (dis[v] == dis[u] + w)&#123; dis1[v] = min(dis1[v], dis1[u] + c); q.push(P(dis[v], v)); &#125; &#125; &#125;&#125;int n, m, u, v, w, c, s, t;int main() &#123; while(~scanf(\"%d%d\", &amp;n, &amp;m))&#123; if (m == 0 &amp;&amp; n == 0) break; init(); for (int i = 0; i &lt; m; ++i)&#123; read(u), read(v), read(w), read(c); add(u, v, w, c); add(v, u, w, c); &#125; read(s), read(t); dijk(s); cout &lt;&lt; dis[t] &lt;&lt; ' ' &lt;&lt; dis1[t] &lt;&lt; \"\\n\"; &#125; return 0;&#125; C CodeForces 670C 【The__Flash】的电影1. 题目大意有n个人， 每个人只会一种语言， 然后有m场电影， 电影的声音和字幕是两种不同的语言， 问 选择哪一场电影， 使得能听懂的人最多， 如果能听懂的一样多， 那么就使能看懂的人最多， 如果听懂的和看懂的都一样多， 输出其中任何一场电影都行。 2. 分析比较直观的想法， 统计每个语言会的人数， 遍历m场电影， 选择能听懂的最大的， 如果能听懂的一样多， 选择能看懂的最大的。（由于数据太大进行离散化处理） 我当时没直接离散化，偷懒用的map， wa了两次，最后 还是用map， set卡过了(*^▽^*) 下面贴离散化的做法 3. AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; P;const int N = 2e5 + 20;const int M = 1e6 + 20;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 10007;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;int a[N], b[N], c[N], d[N * 3], num[N];int len;inline int f(int x)&#123; return lower_bound(d + 1, d + len + 1, x) - d;&#125;int main()&#123; int n, m; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); m = read(); for (int i = 1; i &lt;= m; ++i) b[i] = read(); for (int i = 1; i &lt;= m; ++i) c[i] = read(); for (int i = 1; i &lt;= n; ++i) d[++len] = a[i]; for (int i = 1; i &lt;= m; ++i) d[++len] = b[i]; for (int i = 1; i &lt;= m; ++i) d[++len] = c[i]; sort(d + 1, d + len + 1); len = unique(d + 1, d + len + 1) - (d + 1); for (int i = 1; i &lt;= n; ++i) num[f(a[i])]++; int mx1 = -1, mx2 = -1, id; for (int i = 1; i &lt;= m; ++i)&#123; b[i] = f(b[i]) ,c[i] = f(c[i]); if (mx1 &lt; num[b[i]] || mx1 == num[b[i]] &amp;&amp; mx2 &lt; num[c[i]])&#123; mx1 = num[b[i]]; mx2 = num[c[i]]; id = i; &#125; &#125; cout &lt;&lt; id &lt;&lt; \"\\n\"; return 0;&#125; 4. 后继打算写一篇关于 unique 用法的博客， 写完了回来补上。 D UVA 10305 【The__Flash】的排序1. 题目大意拓扑排序裸题 2. 分析拓扑排序裸题 3. AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int n, m, a, b, in[102];vector&lt;int&gt;ve[N];queue&lt;int&gt;q;vector&lt;int&gt;ans;inline void init()&#123; for (int i = 0; i &lt;= n; ++i)&#123; ve[i].clear(); in[i] = 0; ans.clear(); &#125;&#125;int main() &#123; while(~scanf(\"%d%d\", &amp;n, &amp;m) &amp;&amp; (m || n))&#123; init(); while(m--)&#123; read(a), read(b); ve[a].push_back(b); in[b]++; &#125; for (int i = 1; i &lt;= n; ++i)&#123; if (in[i] == 0) q.push(i); &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); ans.push_back(u); for (int i = 0; i &lt; ve[u].size(); ++i)&#123; int v = ve[u][i]; in[v]--; if(in[v] == 0) q.push(v); &#125; &#125; for (int i = 0; i &lt; ans.size() - 1; ++i) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; ans.back() &lt;&lt; \"\\n\"; &#125; return 0;&#125; E HDU 4578 【The__Flash】的操作1. 题目大意裸线段树， 就是有些许麻烦。4个操作 12341 x y c 将[x, y]区间的数加c2 x y c 将[x, y]区间的数乘c3 x y c 将[x, y]区间的数重置为c4 x y p 输出[x, y]区间的数的 p次方和 2. 分析两种做法， 先说第一种也是通俗易懂的一种但是代码写起来很抓狂。。。3个lazy数组， 3个存值数组 123456add[i] 加标记mul[i] 乘标记sett[i] 重置标记sum[i] 1次方和sum2[i] 2次方和sum3[i] 3次方和 难弄的是add[i] 的 二、三次方和 怎么求。酱紫 1234567sum2[rt] = (a + add) ^ 2 + (b + add) ^ 2 + (c + add) ^ 2= (a^2 + b^2 + c^2) + 2 * add * (a + b + c) + 3 * val ^ 2= sum2[rt] + 2 * add[rt] * sum[rt] + (r - l + 1) * add[rt] * add[rt]sum3[rt] = (a + add) ^ 3 + (b + add) ^ 3 + (c + add) ^ 3= (a^3 + b^3 + c ^ 3) + 3 * add * (a^2 + b^2 + c^2) + 3 * add * add * (a + b + c) + 3 * add * add * add = sum3[rt] + 3 * add[rt] * sum2[rt] + 3 * add[rt] * add[rt] + sum[rt] + (r - l + 1) * add[rt] * add[rt] * add[rt] 然后就是快乐了写代码时间了， 记得注意取余（因为取余我debug了2小时+ o(╥﹏╥)o） 第二种， 只用一个lazy数组， 太妙了， 它是以区间里的数是否相等作为lazy数组 12flag[i] i表示的区间里的数是否相等val[i] i表示的区间里的数的值 3. AC代码第一种方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; P;const int N = 1e5 + 20;const int M = 1e6 + 20;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 10007;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;int mul[N &lt;&lt; 2], sett[N &lt;&lt; 2], add[N &lt;&lt; 2], sum[N &lt;&lt; 2], sum2[N &lt;&lt; 2], sum3[N &lt;&lt; 2];void pushup(int rt) &#123; sum3[rt] = (sum3[rt &lt;&lt; 1] + sum3[rt &lt;&lt; 1 | 1]) % mod; sum2[rt] = (sum2[rt &lt;&lt; 1] + sum2[rt &lt;&lt; 1 | 1]) % mod; sum[rt] = (sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1]) % mod;&#125;void build(int l, int r, int rt) &#123; sett[rt] = add[rt] = 0; mul[rt] = 1; if (l == r) &#123; sum[rt] = sum2[rt] = sum3[rt] = 0; return; &#125; int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);&#125;void pushdown(int rt, int len) &#123; if (sett[rt]) &#123; sett[rt &lt;&lt; 1] = sett[rt &lt;&lt; 1 | 1] = sett[rt]; add[rt &lt;&lt; 1] = add[rt &lt;&lt; 1 | 1] = 0; //注意这个也要下放 mul[rt &lt;&lt; 1] = mul[rt &lt;&lt; 1 | 1] = 1; int tmp = ((sett[rt] * sett[rt]) % mod) * sett[rt] % mod; sum[rt &lt;&lt; 1] = ((len - (len &gt;&gt; 1)) % mod) * (sett[rt]) % mod; sum[rt &lt;&lt; 1 | 1] = ((len &gt;&gt; 1) % mod) * (sett[rt]) % mod; sum2[rt &lt;&lt; 1] = ((len - (len &gt;&gt; 1)) % mod) * ((sett[rt] * sett[rt]) % mod) % mod; sum2[rt &lt;&lt; 1 | 1] = ((len &gt;&gt; 1) % mod) * ((sett[rt] * sett[rt]) % mod) % mod; sum3[rt &lt;&lt; 1] = ((len - (len &gt;&gt; 1)) % mod) * tmp % mod; sum3[rt &lt;&lt; 1 | 1] = ((len &gt;&gt; 1) % mod) * tmp % mod; sett[rt] = 0; &#125; if (mul[rt] != 1) &#123; //这个就是mul[rt] != 1 ， 当时我这里没注意所以TLE了 mul[rt &lt;&lt; 1] = (mul[rt &lt;&lt; 1] * mul[rt]) % mod; mul[rt &lt;&lt; 1 | 1] = (mul[rt &lt;&lt; 1 | 1] * mul[rt]) % mod; add[rt &lt;&lt; 1] = (add[rt &lt;&lt; 1] * mul[rt]) % mod; add[rt &lt;&lt; 1 | 1] = (add[rt &lt;&lt; 1 | 1] * mul[rt]) % mod; int tmp = (((mul[rt] * mul[rt]) % mod * mul[rt]) % mod); sum[rt &lt;&lt; 1] = (sum[rt &lt;&lt; 1] * mul[rt]) % mod; sum[rt &lt;&lt; 1 | 1] = (sum[rt &lt;&lt; 1 | 1] * mul[rt]) % mod; sum2[rt &lt;&lt; 1] = (sum2[rt &lt;&lt; 1] % mod) * ((mul[rt] * mul[rt]) % mod) % mod; sum2[rt &lt;&lt; 1 | 1] = (sum2[rt &lt;&lt; 1 | 1] % mod) * ((mul[rt] * mul[rt]) % mod) % mod; sum3[rt &lt;&lt; 1] = (sum3[rt &lt;&lt; 1] % mod) * tmp % mod; sum3[rt &lt;&lt; 1 | 1] = (sum3[rt &lt;&lt; 1 | 1] % mod) * tmp % mod; mul[rt] = 1; &#125; if (add[rt]) &#123; add[rt &lt;&lt; 1] = (add[rt &lt;&lt; 1] + add[rt]) % mod; add[rt &lt;&lt; 1 | 1] = (add[rt &lt;&lt; 1 | 1] + add[rt]) % mod; int tmp = (add[rt] * add[rt] % mod) * add[rt] % mod; //注意sum3 , sum2 , sum的先后顺序 sum3[rt &lt;&lt; 1] = (sum3[rt &lt;&lt; 1] + tmp * (len - (len &gt;&gt; 1) % mod) % mod + 3 * add[rt] * sum2[rt &lt;&lt; 1] % mod + 3 * add[rt] * add[rt] % mod * sum[rt &lt;&lt; 1]) % mod; sum3[rt &lt;&lt; 1 | 1] = (sum3[rt &lt;&lt; 1 | 1] + tmp * ((len &gt;&gt; 1) % mod) % mod + 3 * add[rt] * sum2[rt &lt;&lt; 1 | 1] % mod + 3 * add[rt] * add[rt] % mod * sum[rt &lt;&lt; 1 | 1]) % mod; sum2[rt &lt;&lt; 1] = (sum2[rt &lt;&lt; 1] + ((add[rt] * add[rt] % mod) * ((len - (len &gt;&gt; 1)) % mod)) % mod + (2 * sum[rt &lt;&lt; 1] * add[rt] % mod)) % mod; sum2[rt &lt;&lt; 1 | 1] = (sum2[rt &lt;&lt; 1 | 1] + (((add[rt] * add[rt] % mod) * ((len &gt;&gt; 1)) % mod)) % mod + (2 * sum[rt &lt;&lt; 1 | 1] * add[rt] % mod)) % mod; sum[rt &lt;&lt; 1] = (sum[rt &lt;&lt; 1] + ((len - (len &gt;&gt; 1)) % mod) * add[rt] % mod) % mod; sum[rt &lt;&lt; 1 | 1] = (sum[rt &lt;&lt; 1 | 1] + ((len &gt;&gt; 1) % mod) * add[rt] % mod) % mod; add[rt] = 0; &#125;&#125;void update(int op, int L, int R, int c, int l, int r, int rt) &#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; if (op == 3) &#123; sett[rt] = c; add[rt] = 0; mul[rt] = 1; sum[rt] = ((r - l + 1) % mod * c) % mod; sum2[rt] = ((r - l + 1) % mod * ((c * c) % mod)) % mod; sum3[rt] = ((r - l + 1) % mod * (((c * c) % mod) * c % mod)) % mod; &#125; else if (op == 2) &#123; mul[rt] = (mul[rt] * c) % mod; add[rt] = (add[rt] * c) % mod; sum[rt] = (sum[rt] * c) % mod; sum2[rt] = sum2[rt] * (c * c % mod) % mod; sum3[rt] = sum3[rt] * ((c * c % mod) * c % mod) % mod; &#125; else if (op == 1) &#123; add[rt] = (add[rt] + c) % mod; int tmp = (((c * c) % mod * c) % mod * (r - l + 1) % mod) % mod; sum3[rt] = (sum3[rt] + tmp + 3 * c * sum2[rt] % mod + 3 * c * c % mod * sum[rt]) % mod; sum2[rt] = (sum2[rt] + (c * c % mod * ((r - l + 1) % mod)) % mod + 2 * sum[rt] * c % mod) % mod; sum[rt] = (sum[rt] + (r - l + 1) % mod * c % mod) % mod; &#125; return; &#125; pushdown(rt, r - l + 1); int m = l + r &gt;&gt; 1; if (m &gt;= L) update(op, L, R, c, l, m, rt &lt;&lt; 1); if (m &lt; R) update(op, L, R, c, m + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);&#125;int query(int L, int R, int p, int l, int r, int rt) &#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; if (p == 1) return sum[rt]; if (p == 2) return sum2[rt]; if (p == 3) return sum3[rt]; &#125; pushdown(rt, r - l + 1); int ans = 0; int m = l + r &gt;&gt; 1; if (m &gt;= L) ans = (ans + query(L, R, p, l, m, rt &lt;&lt; 1)) % mod; if (m &lt; R) ans = (ans + query(L, R, p, m + 1, r, rt &lt;&lt; 1 | 1)) % mod; return ans;&#125;int n, m, op, x, y, c;int main() &#123; while (~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; if (!m &amp;&amp; !n) break; build(1, n, 1); while (m--) &#123; op = read(), x = read(), y = read(), c = read(); if (op &lt;= 3) update(op, x, y, c, 1, n, 1); else printf(\"%d\\n\", query(x, y, c, 1, n, 1)); &#125; &#125; return 0;&#125; 第二种方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 20;const int M = 1e6 + 20;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 10007;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;bool flag[N &lt;&lt; 2];int val[N &lt;&lt; 2];void init()&#123; ms(flag, true); ms(val, 0);&#125;void update(int op, int L, int R, int c, int l, int r, int rt)&#123; if (l &gt;= L &amp;&amp; r &lt;= R &amp;&amp; flag[rt])&#123; if (op == 1) val[rt] = (val[rt] + c) % mod; else if (op == 2) val[rt] = (val[rt] * c) % mod; else if (op == 3) val[rt] = c; return ; &#125; if (flag[rt])&#123; // pushdown flag[rt &lt;&lt; 1] = flag[rt &lt;&lt; 1 | 1] = 1; flag[rt] = 0; val[rt &lt;&lt; 1] = val[rt &lt;&lt; 1 | 1] = val[rt]; &#125; int m = l + (r - l) / 2; if (m &gt;= L) update(op, L, R, c, l, m, rt &lt;&lt; 1); if (m &lt; R) update(op, L, R, c, m + 1, r, rt &lt;&lt; 1 | 1); if (flag[rt &lt;&lt; 1] &amp;&amp; flag[rt &lt;&lt; 1 | 1])&#123; if (val[rt &lt;&lt; 1] == val[rt &lt;&lt; 1 | 1])&#123; flag[rt] = 1; val[rt] = val[rt &lt;&lt; 1]; &#125; else flag[rt] = 0; &#125; else flag[rt] = 0;&#125;int query(int L, int R, int p, int l, int r, int rt)&#123; if (l &gt;= L &amp;&amp; r &lt;= R &amp;&amp; flag[rt])&#123; int ans = 1; for (int i = 1; i &lt;= p; ++i)&#123; ans = (ans * val[rt]) % mod; &#125; ans = ans * (r - l + 1) % mod; return ans; &#125; if (flag[rt])&#123; flag[rt &lt;&lt; 1] = flag[rt &lt;&lt; 1 | 1] = 1; flag[rt] = 0; val[rt &lt;&lt; 1] = val[rt &lt;&lt; 1 | 1] = val[rt]; &#125; int m = l + (r - l) / 2; int ans = 0; if (m &gt;= L) ans += query(L, R, p, l, m, rt &lt;&lt; 1) % mod; if (m &lt; R) ans += query(L, R, p, m + 1, r, rt &lt;&lt; 1 | 1) % mod; return ans % mod;&#125;int n, m;int main()&#123; while(~scanf(\"%d%d\", &amp;n, &amp;m))&#123; if (n == 0 &amp;&amp; m == 0) break; int x, y, op, c; init(); while(m--)&#123; op = read(), x = read(), y = read(), c = read(); if (op &lt;= 3) update(op, x, y, c, 1, n, 1); else printf(\"%d\\n\", query(x, y, c, 1, n, 1)); &#125; &#125; return 0;&#125; 4. 后继 线段树要开4倍空间, 为什么 传lazy数组时， 不仅值要更新， lazy数组也要更新 update， build操作完， 别忘了pushup uodate操作更新lazy数组时， 别忘了更新值。 左子树的区间长度(len - (len &gt;&gt; 1))&gt;= 右子树的区间长度 (len &gt;&gt; 1) F CodeForces 797B 【The__Flash】的序列1. 题目大意给你一个序列， 找出一个子序列， 使得其和为奇数且最大。 2. 分析先求出最大和， 也就是把大于0的数都加起来， 如果是奇数就输出， 如果是偶数就减去绝对值最小的奇数。 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int a[N];int main() &#123; int n; read(n); int sum = 0; int flag = 100000; for (int i = 0; i &lt; n; ++i)&#123; read(a[i]); if (a[i] &gt; 0)&#123; sum += a[i]; &#125; if (a[i] &amp; 1) flag = min(flag, abs(a[i])); &#125; if (sum &amp; 1) cout &lt;&lt; sum &lt;&lt; \"\\n\"; else cout &lt;&lt; sum - flag &lt;&lt; \"\\n\"; return 0;&#125; G CodeForces 1223B 【The__Flash】的水题1. 题目大意字符串可以进行这样一个操作， 将相邻的字符（a ， b）变成（a， a）或者 （b， b）可以进行任意次这种操作 2. 分析进行任意次操作后， 字符串里的字符就全一样了， 所以只需要判断两个字符串中是否有相同的字符即可。把第一个字符串所有字符塞到set&lt;char&gt;里， 然后遍历第二个字符串， 看看能不能从里面找出一样的。 3. AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;string a, b;set&lt;char&gt;se;int main() &#123; int t; read(t); while(t--)&#123; se.clear(); cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; a.length(); ++i) se.insert(a[i]); int flag = 0; for (int i = 0; i &lt; b.length(); ++i)&#123; if (se.find(b[i]) != se.end())&#123; flag = 1; break; &#125; &#125; if (flag) puts(\"YES\"); else puts(\"NO\"); &#125; return 0;&#125; H CodeForces 960B 【The__Flash】的赠予1. 题目大意给你两个序列a, b， 定义E = (ai - bi) ^ 2 | i : 1 - n , 每一次操作可以使序列中的某个数加1或者减1， 问对序列a进行k1次操作， b进行k2次操作后E的最小值。 2. 分析每一次操作就是使 |ai - bi|的值减小1， 因为要求最小值， 所以对|ai - bi|的值越大的 操作 越值得。 例如： 对9 减1后， 实际减小的值为 9 ^ 2 - 8 ^ 2 = 17, 对8 减1后， 实际减小的值为 8 ^ 2 - 7 ^ 2 = 15, 可见对|ai - bi|的值越大的 操作 越值得。然后就是把|ai - bi|塞进优先队列里， 每次取top 对其减一， 执行k1 + k2次即可。 3. AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;priority_queue&lt;int&gt; q;int a[1003], b[1003];int main() &#123; int n, k1, k2; read(n), read(k1), read(k2); for (int i = 0; i &lt; n; ++i) read(a[i]); for (int i = 0; i &lt; n; ++i)&#123; read(b[i]); q.push(abs(a[i] - b[i])); &#125; int k = k1 + k2; while(k--)&#123; int u = q.top(); q.pop(); q.push(abs(u - 1)); &#125; ll ans = 0; while(!q.empty())&#123; int u = q.top(); q.pop(); ans += 1ll * u * u; // 注意会爆long long &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 4. 后继 会爆ll， 前面 * 1ll。 I SCU 4444 【The__Flash】的旅行1. 题目大意n个城市（1 - n）， 有n * (n - 1) / 2条路， 其中有m条路权值为a（具体哪m条已给出）， 剩下的权值为b， 无向图， 问城市1到城市n的最短路。 2. 分析打比赛的时候想的有点多， 其中有一个情况没想出来，o(╥﹏╥)o 肯定要分为 a &lt;= b 和 a &gt; b 当a &lt;= b时， 如果dis[1][n] == a, 那就是a。 否则跑a的最短路dis[1][n], 答案就是min(dis[1][n], b)。当a &gt; b时， 如果dis[1][n] == b , 那就是b。否则， 判断m条a边是不是把 城市1 或 城市n 堵上， 换句话说， 判断城市1 或者城市n所连的所有边是不是都是权值为a的边， 如果 城市1 或者城市n全是， 那么答案就是a， 因为 如果被全堵上， 走两条边的话， 其中一条边肯定是a边， 那就不如直接走1-n了。 如果都没被堵上， 答案就是走一条a边和走2条b边的最小值 min(a, 2 * b)。 如果不会自定义优先队列优先级， 请戳 优先队列定义优先级的方法 3. AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int M = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;struct edge&#123; int v, w, ne;&#125;ed[M];int head[N], vis[N], cnt;ll dis[N];int n, m, a, b;inline void init()&#123; for (int i = 0; i &lt;= n; ++i)&#123; head[i] = -1, vis[i] = 0, dis[i] = llINF; &#125; cnt = 0;&#125;inline void add(int u, int v, int w)&#123; ed[cnt] = &#123;v, w, head[u]&#125;; head[u] = cnt++;&#125;priority_queue&lt;P, vector&lt;P&gt; , greater&lt;P&gt; &gt;q;void dijk(int u)&#123; dis[u] = 0; q.push(P(0, u)); while(!q.empty())&#123; u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v, w = ed[i].w; if (dis[v] &gt; dis[u] + w)&#123; dis[v] = dis[u] + w; q.push(P(dis[v], v)); &#125; &#125; &#125;&#125;int main()&#123; int u, v, dis1n, in1, in2; while(~scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;a, &amp;b))&#123; init(); dis1n = b; in1 = in2 = 0; while(m--)&#123; read(u), read(v); if (u &gt; v) swap(u, v); add(u, v, a); add(v, u, a); if (u == 1) in1++; if (v == n) in2++; if (u == 1 &amp;&amp; v == n) dis1n = a; &#125; if (a &lt;= b)&#123; if (dis1n == a) cout &lt;&lt; a &lt;&lt; \"\\n\"; else&#123; dijk(1); if (dis[n] &lt;= b) cout &lt;&lt; dis[n] &lt;&lt; \"\\n\"; else cout &lt;&lt; b &lt;&lt; \"\\n\"; &#125; &#125; else&#123; if (dis1n == b)&#123; cout &lt;&lt; b &lt;&lt; \"\\n\"; continue; &#125; int sum = 0; if (in1 == n - 1) sum++; if (in2 == n - 1) sum++; if (sum &gt;= 1) cout &lt;&lt; a &lt;&lt; \"\\n\"; else cout &lt;&lt; min(a, 2 * b) &lt;&lt; \"\\n\"; &#125; &#125;&#125; J HDU 1556 【The__Flash】的球球1. 题目大意中文题， qaqN个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？ 2. 分析差分模板题。 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int n, l, r;int diff[N], ans[N];int main() &#123; while(~scanf(\"%d\", &amp;n) &amp;&amp; n)&#123; ms(diff, 0); for (int i = 0; i &lt; n; ++i)&#123; read(l), read(r); diff[l] ++; diff[r + 1]--; &#125; int add = 0; for (int i = 1; i &lt;= n; ++i)&#123; add += diff[i]; ans[i] = add; &#125; for (int i = 1; i &lt; n; ++i) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; ans[n] &lt;&lt; \"\\n\"; &#125; return 0;&#125; K POJ 2018 【The__Flash】的牛牛1. 题目大意给你一个长为n（n &lt;= 1e5）的序列， 求其长度至少为F区间， 其平均值*1000的最大值。 2. 分析一开始以为是dp， 然后没思路qaq 二分答案qaq， tql 没想到居然是二分答案， qaq。 关键是如何以更小的时间判断二分出来的值 （mid）是不是符合要求的，也就是 判断 长度至少为F的区间的平均值， 有没有大于mid的。 先说二分， 我要求最大的满足条件的数， 所以就是从后向前查询。 从后向前详情请点击 二分总结 然后如何判断呢， 那就把区间都减去mid， 就变成找一段区间[l, r]， 使 sum[r] - sum[l - 1] &gt;= 0 , 这样记录 sum[l - 1]的最小值即可。 还有一种做法， 请参考 POJ2018 Best Cow Fences (二分答案+类前缀和) 3. AC代码第一种做法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int M = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int n, k;double sum[N];int a[N];inline bool is(double x)&#123; for (int i = 1; i &lt;= n; ++i) sum[i] = a[i] - x; for (int i = 1; i &lt;= n; ++i) sum[i] += sum[i - 1]; double mi = INF * 1.0; for(int i = k; i &lt;= n; ++i)&#123; mi = min(mi, sum[i - k]); if (sum[i] - mi &gt;= -eps) // 特别注意这里。。 return 1; &#125; return 0;&#125;int main()&#123; read(n), read(k); for (int i = 1; i &lt;= n; ++i)&#123; read(a[i]); &#125; int l = 0, r = 2000000, m; while(l &lt; r)&#123; m = l + (r - l + 1) / 2; if (is(1.0 * m / 1000)) l = m; else r = m - 1; &#125; cout &lt;&lt; l &lt;&lt; \"\\n\"; return 0;&#125; 第二种做法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int M = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int n, k;int sum[N];int a[N];double rsum[N];inline bool is(double x)&#123; rsum[n] = a[n] - x; for (int i = n - 1; i &gt;= 1; --i)&#123; rsum[i] = a[i] - x; if (rsum[i + 1] &gt; 0) rsum[i] += rsum[i + 1]; &#125; for (int i = 1; i &lt;= n - k + 1; ++i)&#123; if (sum[i + k - 1] - sum[i - 1] &gt;= x * k) return true; if (sum[i + k - 1] - sum[i - 1] - x * k + rsum[i + k] &gt;= 0) return true; &#125; return false;&#125;int main()&#123; read(n), read(k); for (int i = 1; i &lt;= n; ++i)&#123; read(a[i]); sum[i] = sum[i - 1] + a[i]; &#125; int l = 0, r = 2000000, m; while(l &lt; r)&#123; m = l + (r - l + 1) / 2; if (is(1.0 * m / 1000)) l = m; else r = m - 1; &#125; cout &lt;&lt; l &lt;&lt; \"\\n\"; return 0;&#125; 4. 后继 知道如何在O(n)求 长度至少为k的 区间和的最大值 L CodeForces 621B 【The__Flash】的鲨鲨1. 题目大意1000 * 1000 的网格中， 处于对角线上的鲨鲨会互相打架， 求有对少对鲨鲨会打架。 2. 分析画图可分析， 处于对角线上的鲨鲨满足 x + y = t (0&lt;= t &lt;= 2000) 或者满足 x - y = t (-1000 &lt;= t &lt;= 1000)， 分别用两个数组储存在每一条对角线上的个数， 然后n * (n - 1) / 2 计算即可， 注意x - y的范围， 可以化成 x - y + 1000 = t (0 &lt;= t &lt;= 2000) ， 因为这个我re了两次QAQ 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int M = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;struct node&#123; int hp, atk; double v;&#125;a[N];bool cmp(node x, node y)&#123; if (fabs(x.v - y.v) &lt;= eps) return x.hp &gt; y.hp; return x.v &gt; y.v;&#125;int a1[10003], a2[10003];int main() &#123; int n, x, y; read(n); for (int i = 0; i &lt; n; ++i)&#123; read(x), read(y); a1[x + y]++; a2[x - y + 1000]++; &#125; ll ans = 0; for (int i = 0; i &lt;= 2000; ++i)&#123; if (a1[i] &gt; 1)&#123; ans += ll(a1[i]) * ll(a1[i] - 1) / 2; &#125; if (a2[i] &gt; 1)&#123; ans += ll(a2[i]) * ll(a2[i] - 1) / 2; &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 4. 后继 注意数组下标是不是负数 o(╥﹏╥)o M Gym 102222H 【The__Flash】的达拉崩吧斑得贝迪卜多比鲁翁1. 题目大意12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152很久很久以前巨龙突然出现带来灾难带走了公主又消失不见王国十分危险世间谁最勇敢一位勇者赶来大声喊“我要带上最好的剑翻过最高的山闯进最深的森林把公主带回到面前”国王非常高兴忙问他的姓名年轻人想了想他说“陛下我叫达拉崩吧斑得贝迪卜多比鲁翁再来一次达拉崩巴斑得贝迪卜多比鲁翁”“是不是达拉崩吧斑得贝迪卜多比鲁翁”“对对达拉崩巴斑得贝迪卜多比鲁翁”...幽幽小路上，英雄达拉崩吧遇到 n 只怪兽每只怪兽有其相应的体力值 HP 和 攻击值 ATK达拉崩吧每次可对怪物造成一次伤害，伤害值为 K（其中，K 在数值上为达拉崩吧攻击这只怪兽的次数）然鹅，每次存活的怪兽都可以攻击我们的英雄达拉崩吧当怪兽的体力值小于等于时，怪兽死亡.现请你选择一种打怪兽的顺序，使得达拉崩吧收到的伤害和最小，并输出收到最小的伤害和.————————————————版权声明：本文为CSDN博主「The___Flash」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/The___Flash/article/details/103939876 2. 分析显而易见， 贪心， 但是当时没会用理解的思维推理， 而是臆测， 不过差一点（很多）就猜对了QAQ 最优情况肯定是把一只怪兽打到死。先只考虑攻击两只怪兽的优先级问题。 设t[i] 是把第i只怪兽打死需要的次数， sum是所有怪兽的总攻击力和 先进攻第一只 所受的攻击 是 sum * t[1] + (sum - atk[1]) * t[2]先进攻第二只 所受的攻击 是 sum * t[2] + (sum - atk[2]) * t[1] 如果要先攻击第二只 1234sum * t[1] + (sum - atk[1]) * t[2] &gt;= sum * t[2] + (sum - atk[2]) * t[1]sum * t[1] + sum * t[2] - atk[1] * t[2] &gt;= sum * t[2] + sum * t[1] - atk[2] * t[1]atk[2] * t[1] &gt;= atk[1] * t[2]atk[2] / t[2] &gt;= atk[1] / t[1] 所以按照 atk[i] / t[i]排序就行。 那么怎么求把第i只怪兽打死需要的次数呢， 二分次数就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define eps 1e-7#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int M = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 4611686018427387903;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;struct node&#123; int hp, atk; double v;&#125;a[N];bool cmp(node x, node y)&#123; if (fabs(x.v - y.v) &lt;= eps) return x.hp &gt; y.hp; return x.v &gt; y.v;&#125;int search(int x)&#123; int low = 0, high = 500, m; while(low &lt; high)&#123; m = low + (high - low) / 2; if (m * (m + 1) / 2 &gt;= x) high = m; else low = m + 1; &#125; return low;&#125;int main() &#123; int t, n; ll ans, sum; read(t); for (int tt = 1; tt &lt;= t; ++tt)&#123; read(n); sum = 0; for (int i = 0; i &lt; n; ++i)&#123; read(a[i].hp), read(a[i].atk); a[i].hp = search(a[i].hp); a[i].v = 1.0 * a[i].atk / a[i].hp; // 这里也可以不用v ， 而直接用 atk[2] * search(hp[1]) &gt;= atk[1] * search(hp[2]) 也行 sum += a[i].atk; &#125; ans = 0; sort(a, a + n, cmp); for (int i = 0; i &lt; n; ++i)&#123; ans += sum * (a[i].hp); sum -= a[i].atk; &#125; printf(\"Case #%d: %lld\\n\", tt, ans); &#125; return 0;&#125; 4. 后继常见贪心证明手段： 临项交换： 证明在任何局面下，任何对局部最优策略的微小改变都会造成整体结果变差，经常用于以“排序”为贪心策略的证明. 范围缩放： 证明任何对局面最优策略作用范围的拓展都不会造成整体结果变差. 决策包容性： 证明在任意局面下，作出局部最优决策以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略提供的可能性包含其他所有策略提供的可能性. 反证法 数学归纳法 例题： POJ-3614 POJ-3190 POJ-1328 国王游戏 POJ-2054 恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan 千万不要图快——如果没有足够的时间用来实践， 那么学得快， 忘得也快。","tags":[{"name":"最短路","slug":"最短路","permalink":"https://solodance.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://solodance.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://solodance.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"Acm","slug":"Acm","permalink":"https://solodance.top/tags/Acm/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://solodance.top/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"离散化","slug":"离散化","permalink":"https://solodance.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"线段树","slug":"线段树","permalink":"https://solodance.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"差分","slug":"差分","permalink":"https://solodance.top/tags/%E5%B7%AE%E5%88%86/"},{"name":"二分","slug":"二分","permalink":"https://solodance.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"SDNU_ACM_ICPC_2020_Winter_Practice_1st【解题报告】","date":"2020-01-29T02:51:58.191Z","path":"2020/01/29/SDNU_ACM_ICPC_2020_Winter_Practice_1st【解题报告】/","text":"欢迎评论提问， 纠错 文章篇幅较长， 请参考右侧文章目录食用。 专题链接： SDNU_ACM_ICPC_2020_Winter_Practice_1st A CodeForces 854A1. 题目大意把一个数n分成两个互质的数(a, b, a &lt; b)， 使 a / b 最大。 2. 分析从 i = n / 2 –&gt; 1遍历， 如果 gcd(i, n - i) == 1 ， 输出i 和 n - i。 3. AC代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1;char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w; &#125;int main()&#123; int n = read(); for (int i = n / 2; i &gt;= 1; --i)&#123; if (__gcd(i, n - i) == 1)&#123; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; n - i &lt;&lt; \"\\n\"; return 0; &#125; &#125; return 0;&#125; 4. 后继 QAQ， 当时没看到要两个数互质， wa了一发 B CodeForces 854B1. 题目大意公寓编号 1 - n ， 其中k间已经有人入住（不知道具体是哪k间）， 如果这个人入住了一间房子并且他的邻居有人入住， 他就会感到快乐， 问能让他感到快乐的位置数量的 最小值， 最大值。 2. 分析最小值的情况肯定是 1-k入住， 答案为0 （住满）或 1（没住满） 。最大值的情况是 入住一个人 会有两个位置使他感到愉悦的，但总位置不能超过 n-k， 答案就是min(2 * k, n - k)。 3. AC代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1;char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w; &#125;int main()&#123; int n, k; n = read(), k = read(); if (n == k || k == 0)&#123; cout &lt;&lt; \"0 0\\n\"; return 0; &#125; int mx = 2 * k; mx = min(mx, n - k); cout &lt;&lt; \"1 \" &lt;&lt; mx &lt;&lt; \"\\n\"; return 0;&#125; 4. 后继 当时以为 2 4 6 这种空一个是最优的， 其实 2 5 8 这种空两个才是最优的， 然后就wa了两发。 C CodeForces 854C1. 题目大意给你n个飞机的花费和开始时间k， 第i个飞机的最早起飞时间是i， 要求飞机从 k + 1 到 k + n， 全都飞完， 求什么顺序能使总花费最小， 输出最小花费和n个飞机实际起飞的时间， 起飞花费的计算公式为 (实际起飞时间 - 要求起飞时间) * 这个飞机的花费 2. 分析实际上就是求 [1, i] | k + 1 &lt;= i &lt;= k + n 区间内， 飞机花费的最大值， 就是第i时间应该起飞的飞机。 为什么不是求 (实际起飞时间 - 要求起飞时间) * 这个飞机的花费这个最大的呢， 因为， 第i + 1 下， 飞机的 花费大的 涨的多， 所以 应当取飞机花费的最大值。 用优先队列， 现在为cnt时， 把1-cnt的飞机都加进去， 然后取top为时间为cnt时应该起飞的飞机，pop（）， 再把cnt + 1的飞机加进去。 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 3e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1;char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;struct node&#123; int c, j; // c 是花费， j 是起飞时间 bool operator &lt; (const node &amp;x) const&#123; return c &lt; x.c; &#125;&#125;a[N];int ans[N]; // 第i个飞机的实际起飞时间ll res;priority_queue &lt;node&gt; q;int main()&#123; int n, k; n = read(), k = read(); for (int i = 1; i &lt;= n; ++i)&#123; a[i].c = read(); a[i].j = i; &#125; for (int i = 1; i &lt;= k + 1; ++i)&#123; if (i &gt; n) break; q.push(a[i]); &#125; int cnt = k + 1; while(!q.empty())&#123; res += (ll)(q.top().c) * (cnt - q.top().j); // 计算总花费 ans[q.top().j] = cnt++; // 第q.top().j个飞机的实际起飞时间 q.pop(); if (cnt &lt;= n) q.push(a[cnt]); &#125; cout &lt;&lt; res &lt;&lt; \"\\n\"; for (int i = 1; i &lt;= n; ++i)&#123; cout &lt;&lt; ans[i]; if (i != n) cout &lt;&lt; \" \"; else cout &lt;&lt; \"\\n\"; &#125; return 0;&#125; D CodeForces 854D1. 题目大意一共有n+1个城市（0 - n）， 然后 1 - n 城市每个城市一个人， 要到0号城市去会晤， 这n个人至少要一起在0号城市待k天， 现给出 1 - n 城市到0号城市以及 0号城市到 1- n 城市的机票价钱，以及航班开始时间， 并且这一天一定能到达， 问如何安排能使总花费最少。 2. 分析维护两个数组， sum1[i] 表示前i个（包括第i个）航班 能使 1 - n 号城市 到 0 号城市 的最小花费， sum2[i] 表示后i个（包括第i个）航班 能使 0 号城市 到 1 - n 号城市 的最小花费。 就是维护这两个数组有点小小麻烦。 全都求出来， 暴力求 sum1[i] + sum2[i + k + 1]的最小值即可。 具体如何维护。请看代码注释 3. AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int M = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;struct node&#123; int d, f, t, c; // 题意中的d, f, t, c&#125;a[N];bool cmp(node x, node y)&#123; return x.d &lt; y.d;&#125;ll sum1[M], sum2[M];ll val[N];int main()&#123; int n, m, k, d, f, t, c, en = 0; n = read(), m = read(), k = read(); for (int i = 1; i &lt;= m; ++i)&#123; d = read(), f = read(), t = read(), c = read(); a[i] = &#123;d, f, t, c&#125;; en = max(en, d); &#125; sort(a + 1, a + m + 1, cmp); // 先按照飞机起飞时间排序 ms(sum1, llINF); ms(sum2, llINF); // 下面3个是辅助维护的 ms(val, llINF); ll sum = 0; int len = 0; // 下面是维护sum1 for (int i = 1; i &lt;= m; ++i)&#123; if (a[i].f == 0) continue; // 剔除出发地是0号城市的 // val[i]是储存，出发地是i的飞机票的最小价值 if (val[a[i].f] == llINF)&#123; val[a[i].f] = a[i].c; sum += a[i].c; // 总价值 len++; &#125; else if (val[a[i].f] &gt; a[i].c)&#123; sum += -val[a[i].f] + a[i].c; val[a[i].f] = a[i].c; &#125; if (len == n)&#123; // 如果n个城市都有航班飞向0城市了， 那就可以安排了 sum1[a[i].d] = sum; &#125; &#125; // 由于上面循环并没有照顾到每一天的航班， 就是有的天， 没有航班， 不是真正的 sum1， 下面就是维护没有航班的天 for (int i = 1; i &lt;= en; ++i)&#123; if (sum1[i - 1] != llINF)&#123; sum1[i] = min(sum1[i - 1], sum1[i]); &#125; &#125; // 维护sum2， 同理 len = 0; ms(val, llINF); sum = 0; for (int i = m; i &gt;= 1; --i)&#123; if (a[i].t == 0) continue; if (val[a[i].t] == llINF)&#123; val[a[i].t] = a[i].c; sum += a[i].c; len++; &#125; else if (val[a[i].t] &gt; a[i].c)&#123; sum += -val[a[i].t] + a[i].c; val[a[i].t] = a[i].c; &#125; if (len == n)&#123; sum2[a[i].d] = sum; &#125; &#125; for (int i = en - 1; i &gt;= 1; --i)&#123; if (sum2[i + 1] != llINF)&#123; sum2[i] = min(sum2[i + 1], sum2[i]); &#125; &#125; ll ans = llINF; for (int i = 1; i &lt;= en - k - 1; ++i)&#123; ans = min(ans, sum1[i] + sum2[i + k + 1]); &#125; if (ans == llINF) puts(\"-1\"); else cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 4. 后继 这代码是我后来写的， 刚刚补题时的代码是用set维护的， 没用val， 感觉没这个好用， 也没这个简洁。 维护sum1/sum2 的时候别忘了照顾到没有航班的天， 最后的for循环至关重要。总之最后补题的时候debug de了一小时。详见哭o(╥﹏╥)o E CodeForces 705B1. 题目大意n轮游戏， 第i轮游戏有前i个数， 没一轮一个人可以把一个大于2的数x拆成 p(p &gt;= 1) ,x - p (x - p &gt;= 1)， 如果最后没得拆， 就算那个人输。 2. 分析博弈， 每个数被拆多少次是固定的， qaq， 这一轮的所有数能被拆的次数统计下， 奇数先手赢， 偶数先手输。 3. AC代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 3e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;int main() &#123; int n = read(); ll sum = 0, a; while(n--)&#123; a = read(); sum += a - 1; if (sum &amp; 1) puts(\"1\"); else puts(\"2\"); &#125; return 0;&#125; F CodeForces 705C1. 题目大意一共有n个app， 有q次操作。 1231 x app-x 产生一条通知2 x 把所有 app-x 产生的通知标记为已读3 t 把前t个产生的通知（不论已读未读）标记为已读 输出每一次操作后， 未读通知的数量 2. 分析一开始真的是毫无头绪， 想着大暴力铁定超时， 后来看题解， 只想大喊一声 stlnb！ 思想， 通知用cnt编号， 每次都放进set&lt;int&gt;se里， x产生的通知放进vector&lt;int&gt;ve[i] 里 1234567891011// 操作一ve[x].push_back(cnt);se.insert(cnt++);// 操作二se.erase(ve[x][i]);ve[x].clear();// 操作三 做一个小优化， 否则会tlelast = 1;for (int i = last; i &lt;= t; ++i) se.erase(i);last = max(last, t); 3. AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 3e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;vector&lt;int&gt; ve[N];set&lt;int&gt; se;int main() &#123; int n, q, op, x; n = read(), q = read(); int cnt = 1, last = 1; for (int i = 1; i &lt;= q; ++i) &#123; op = read(); x = read(); if (op == 1) &#123; ve[x].push_back(cnt); se.insert(cnt++); &#125; else if (op == 2) &#123; for (int j = 0; j &lt; ve[x].size(); ++j) se.erase(ve[x][j]); ve[x].clear(); &#125; else &#123; // 此处可以换成后继部分优化代码， 稍微更优哦~ for (int j = last; j &lt;= x; ++j) se.erase(j); last = max(last, x); &#125; printf(\"%d\\n\", se.size()); &#125; return 0;&#125; 4. 后继 在优化部分， 为什么我令last = *se.begin()， 他就会超时呢？ 求解决o(╥﹏╥)o 解决了QAQ， 原来当 se 为空时， 取 se.begin()会出错， QAQ， 优化部分代码， 这样更优化一点点 1234if (!se.empty()) last = *se.begin();else last = x + 1;for (int j = last; j &lt;= x; ++j) se.erase(j); G CodeForces 706C1. 题目大意给你n个字符串， 以及翻转字符串所需要的花费， 问要使得这n个字符串按字典序排序， 最小花费是多少， 如果没有， 输出-1. 2. 分析简单的dp， 但我打比赛的时候没敢想。但也就4中情况， 前 翻转/没翻转 ，后 翻转/没翻转 ， 设f[i][0] / f[i][1] 没翻转， 翻转的最小花费。 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;string s[N], ds[N];int c[N];ll f[N][2];int main()&#123; int n = read(); for (int i = 1; i &lt;= n; ++i) c[i] = read(); for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; s[i]; ds[i] = s[i]; reverse(ds[i].begin(), ds[i].end()); &#125; ms(f, llINF); f[1][0] = 0, f[1][1] = c[1]; for (int i = 2; i &lt;= n; ++i)&#123; if (s[i] &gt;= s[i - 1]) f[i][0] = f[i - 1][0]; if (s[i] &gt;= ds[i - 1]) f[i][0] = min(f[i][0], f[i - 1][1]); if (ds[i] &gt;= s[i - 1]) f[i][1] = min(f[i][1], f[i - 1][0] + c[i]); if (ds[i] &gt;= ds[i - 1]) f[i][1] = min(f[i][1], f[i - 1][1] + c[i]); &#125; ll ans = min(f[n][1], f[n][0]); if (ans == llINF) puts(\"-1\"); else cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; H HYSBZ 4337树哈希， 还没补，QAQ， 我打算把比较普通的哈希学完再来补这个题 I HDU 6638最大字段和， 还没补， QAQ， 打算把线段树专题做一遍在补这个题 J HDU 65141. 题目大意给一个n * m的矩阵， 然后给p个矩阵， 然后再给q个矩阵， 问着q个矩阵之一， 是否被那p个矩阵全覆盖。 2. 分析把p个矩阵覆盖的区域全赋值1， 问题就转化成 q个矩阵之一 覆盖区域的和 是不是等于矩阵的面积。 如何把p个矩阵全赋值1， 二维差分。 如何求q个矩阵之一 覆盖区域之和， 二维前缀和。 对了， 这题特坑， 要把二维矩阵转化为一维。。 3. AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 1e7 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;int m, n, p, q;inline int _(int x, int y)&#123; //二维矩阵转化为一维 return (x - 1) * m + y - 1;&#125;int diff[N];int x1, x2, y, y2;int main() &#123; while(~scanf(\"%d%d\", &amp;n, &amp;m))&#123; p = read(); ms(diff, 0); // 差分 for (int i = 0; i &lt; p; ++i)&#123; x1 = read(), y = read(), x2 = read(), y2 = read(); diff[_(x1, y)] += 1; if (x2 + 1 &lt;= n) diff[_(x2 + 1, y)] -= 1; if (y2 + 1 &lt;= m) diff[_(x1, y2 + 1)] -= 1; if (x2 + 1 &lt;= n &amp;&amp; y2 + 1 &lt;= m) diff[_(x2 + 1, y2 + 1)] += 1; &#125; // 通过差分还原矩阵 for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j)&#123; if (i == 1 &amp;&amp; j == 1) continue; else if (i == 1)&#123; diff[_(i, j)] += diff[_(i, j - 1)]; &#125; else if (j == 1)&#123; diff[_(i, j)] += diff[_(i - 1, j)]; &#125; else diff[_(i, j)] += diff[_(i - 1, j)] + diff[_(i, j - 1)] - diff[_(i - 1, j - 1)]; &#125; &#125; // 把被多次覆盖的变为1 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (diff[_(i, j)] &gt;= 1) diff[_(i, j)] = 1; &#125; &#125; // 求前缀和 for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j)&#123; if (i == 1 &amp;&amp; j == 1) continue; else if (i == 1)&#123; diff[_(i, j)] += diff[_(i, j - 1)]; &#125; else if (j == 1)&#123; diff[_(i, j)] += diff[_(i - 1, j)]; &#125; else diff[_(i, j)] += diff[_(i - 1, j)] + diff[_(i, j - 1)] - diff[_(i - 1, j - 1)]; &#125; &#125; q = read(); int sum; for (int i = 0; i &lt; q; ++i)&#123; // 每一次询问求前缀和， 与矩形面积进行比较 x1 = read(), y = read(), x2 = read(), y2 = read(); sum = diff[_(x2, y2)]; if (y &gt; 1) &#123; sum -= diff[_(x2, y - 1)]; &#125; if (x1 &gt; 1) &#123; sum -= diff[_(x1 - 1, y2)]; &#125; if (y &gt; 1 &amp;&amp; x1 &gt; 1) &#123; sum += diff[_(x1 - 1, y - 1)]; &#125; if (sum == (x2 - x1 + 1) * (y2 - y + 1)) puts(\"YES\"); else puts(\"NO\"); &#125; &#125; return 0;&#125; 4. 后继 正是因为这个题我才开始学二维前缀和， 二维差分的。 K 计蒜客 A1951状压Dp， 等着在补， 等着在补， QAQ L HDU 13841. 题目大意给你n个闭区间， 要求最后的集合中要包含这些区间[a, b]的至少c个数， 求最后集合的最小size。 2. 分析差分约束。 推荐两篇博客 差分约束系统学习笔记 差分约束系统 设f[i]为[0, i]中在最后集合里的数的个数。由题意可知 f[b] - f[a - 1] &gt;= c， 求最小值要跑最长路。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 5e4 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll read() &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; return x * w;&#125;struct edge &#123; int u, v, w, ne;&#125; ed[4 * N];int head[N], dis[N], vis[N], cnt;inline void init() &#123; ms(head, -1); ms(dis, -INF); ms(vis, 0); cnt = 0;&#125;inline void add(int u, int v, int w) &#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125;queue&lt;int&gt; q;void spfa(int u) &#123; vis[u] = 1; dis[u] = 0; q.push(u); while (!q.empty()) &#123; u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; ~i; i = ed[i].ne) &#123; int v = ed[i].v; if (dis[v] &lt; dis[u] + ed[i].w) &#123; dis[v] = dis[u] + ed[i].w; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125; &#125;&#125;int a, b, c, n;int main() &#123; while (~scanf(\"%d\", &amp;n)) &#123; init(); int mx = 0, mi = INF; for (int i = 0; i &lt; n; ++i) &#123; a = read(), b = read(), c = read(); add(a - 1, b, c); mx = max(mx, b); mi = min(mi, a); &#125; for (int i = mi - 1; i &lt; mx; ++i) &#123; add(i + 1, i, -1); add(i, i + 1, 0); &#125; spfa(mi - 1); printf(\"%d\\n\", dis[mx]); &#125; return 0;&#125; M POJ 36131. 题目大意给出一张图， 求k边最短路， 即经过k条边的最短路。 2. 分析思考一下：如果一个矩阵，表示走k条边后，一张图的点与点的最短路径，(a,b)表示从a到b的最短路径，然后我们把它与自己，按照矩阵乘法的格式“相乘”，把其中的乘改为取min，c.a[i][j] = min(c.a[i][j],x.a[i][k]+y.a[k][j]) ， 那么两个矩阵”相乘“之后的结果就是 经过k + k条边后的最短路。 c中的一个点(a,b)，当我们用x矩阵和y矩阵求它时，我们枚举了x矩阵的a行所有数，与y矩阵的b列所有数，并且他们的坐标只能是相对应的，比如x矩阵的(a,2)这个点，相应的y矩阵点就是(2,b)，那么放到图上去理解，即从a点经过2点到b点的距离，类似的点不只有2，把所有点枚举完后，c.a[a][b]就是从a到b的最短距离。（意会一下） 这样下来，会得到走k+k条边的最短路径，对于其他的矩阵这样操作，得到的是他们两个，经过的边数相加的结果。（一个经过a条边后的矩阵 与 一个经过b条边后的矩阵这样操作后，是经过a+b条边后的矩阵，矩阵中存的是最短路径）。解释一下：向上面的例子一样，(a,2)(2,b)，是即从a点经过2点到b点的距离,因为x矩阵和y矩阵都是走k条边后的最短路径，那么x矩阵中的(a,2)是走k步后的最短路径，(2,b)也是，那么他们相加不就是走k+k条边后的最短路径吗？其他的矩阵一样。 部分转自 https://www.cnblogs.com/mjtcn/p/7308870.html 因为就100头牛， 离散化一下。 那么就转化成矩阵快速幂问题了。 3. AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define eps 1e-8#define ms(a, b) memset((a), (b), sizeof (a))using namespace std;typedef long long ll;typedef std::pair&lt;ll, ll&gt; P;const int N = 5e4 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;void read(int &amp;ans) &#123; ll x = 0, w = 1; char ch = 0; while (!isdigit(ch)) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch - '0'); ch = getchar(); &#125; ans = x * w;&#125;int n;struct matrix&#123; int m[205][205]; matrix()&#123; ms(m, INF); &#125; matrix operator * (const matrix &amp; x) const&#123; matrix c; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= n; ++j)&#123; for (int k = 1; k &lt;= n; ++k)&#123; c.m[i][j] = min(c.m[i][j], m[i][k] + x.m[k][j]); &#125; &#125; &#125; return c; &#125;&#125;x;matrix qpow(matrix a, int b)&#123; matrix ans = a; b--; while(b)&#123; if (b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; &#125; return ans;&#125;map&lt;int, int&gt;ma;int k, t, s, e, a, b, c;int main() &#123; int cnt = 0; scanf(\"%d%d%d%d\", &amp;k, &amp;t, &amp;s, &amp;e); while(t--)&#123; scanf(\"%d%d%d\", &amp;c, &amp;a, &amp;b); if (ma[a]) a = ma[a]; else a = ma[a] = ++cnt; if (ma[b]) b = ma[b]; else b = ma[b] = ++cnt; x.m[a][b] = x.m[b][a] = c; &#125; n = cnt; x = qpow(x, k); printf(\"%d\\n\", x.m[ma[s]][ma[e]]); return 0;&#125; 4. 后继 矩阵快速幂居然还能用重载 * 来写， 太美妙了。 恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan 千万不要图快——如果没有足够的时间用来实践， 那么学得快， 忘得也快。","tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://solodance.top/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"Acm","slug":"Acm","permalink":"https://solodance.top/tags/Acm/"},{"name":"博弈","slug":"博弈","permalink":"https://solodance.top/tags/%E5%8D%9A%E5%BC%88/"},{"name":"stl","slug":"stl","permalink":"https://solodance.top/tags/stl/"},{"name":"dp","slug":"dp","permalink":"https://solodance.top/tags/dp/"},{"name":"矩阵","slug":"矩阵","permalink":"https://solodance.top/tags/%E7%9F%A9%E9%98%B5/"},{"name":"差分约束","slug":"差分约束","permalink":"https://solodance.top/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"优先队列定义优先级的方法","date":"2020-01-27T11:45:04.425Z","path":"2020/01/27/优先队列定义优先级的方法/","text":"默认优先级是从大到小. 12345678910111213141516171819202122232425262728293031323334353637383940414243// 最大值优先struct cmp1&#123; bool operator () (int &amp;a, int &amp;b)&#123; return a &lt; b; &#125;&#125;;// 最小值优先struct cmp2&#123; bool operator () (int &amp;a, int &amp;b)&#123; return a &gt; b; &#125;&#125;;struct node1&#123; int a, b; bool operator &lt; (const node1 &amp;temp) const&#123; return a + b &lt; temp.a + temp.b; // 以a + b 的值 最大值优先 &#125;&#125;;struct node2&#123; int a, b; bool operator &lt; (const node2 &amp; temp) const&#123; return a + b &gt; temp.a + temp.b; // 以a + b 的值 最小值优先 &#125;&#125;;int main()&#123; // 最大值优先 priority_queue&lt;int&gt;q1; priority_queue&lt;int, vector&lt;int&gt; , less&lt;int&gt; &gt;q2; // 注意 less&lt;int&gt;&gt;q2; 中间不加空格的话会报错， 因为是右移&gt;&gt; 运算符 priority_queue&lt;int, vector&lt;int&gt; , cmp1&gt;q3; // 最小值优先 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q4; // 注意 greater&lt;int&gt;&gt;q4; 中间不加空格的话会报错， 因为是右移&gt;&gt; 运算符 priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q5; // 结构体自定义优先级, 具体优先级顺序看上面 priority_queue&lt;node1&gt;q6; priority_queue&lt;node2&gt;q7; return 0;&#125; 如何理解结构体中overload的小于号呢？ (只能重载小于号) 可以理解为重载后小于号作用是比较出数组中优先级更小的数据，如果返回的是某个数据值更大的一方则值越大优先级越小，相反则值越小优先级越大。 优先队列是输出优先级最高的数据的队列。 可以简单的记为与sort中的cmp函数效果相反。 恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan 千万不要图快——如果没有足够的时间用来实践， 那么学得快， 忘得也快。","tags":[{"name":"Acm","slug":"Acm","permalink":"https://solodance.top/tags/Acm/"},{"name":"优先队列","slug":"优先队列","permalink":"https://solodance.top/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"数据结构","slug":"数据结构","permalink":"https://solodance.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Jetbrains实用技巧汇总","date":"2020-01-27T11:44:53.009Z","path":"2020/01/27/Jetbrains实用技巧汇总/","text":"Jetbrains Tools 关闭 vim模式菜单栏 :tools-&gt;vim emulator 恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan 千万不要图快——如果没有足够的时间用来实践， 那么学得快， 忘得也快。","tags":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://solodance.top/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"Jetbrains","slug":"Jetbrains","permalink":"https://solodance.top/tags/Jetbrains/"}]},{"title":"关于处理博客旧文章的说明","date":"2020-01-24T11:27:46.134Z","path":"2020/01/24/关于处理博客旧文章的说明/","text":"由于博客重做， 以前博客的文章显示时间都变成一样的了， 以后这个博客也不会怎么像这样大改了， 毕竟是怀念。 先说以前文章的诟病markdown语法不标准 tags 乱写 分类也乱写 题解格式不理想，看起来乱七八糟的 处理计划等着按时间把一些没用的博客， 看着不顺眼的博客， 都给整理一下， 去其糟粕， 取其精华。 新年加油。 恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan 千万不要图快——如果没有足够的时间用来实践， 那么学得快， 忘得也快。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://solodance.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2019牛客国庆集训派对 H-Highway (dijk求树的直径（当然还有更优的）)","date":"2020-01-23T13:42:35.154Z","path":"2020/01/23/2019牛客国庆集训派对 H-Highway (dijk求树的直径（当然还有更优的）)/","text":"题目大意题目链接n个点从1-n, 有(n - 1)条边连接。现在要重新修（n - 1）条路， 修i 到 j 所用的代价为i到j的最短路，问最多的代价是多少 分析就是求树的直径， 然后跑两边最短路求其他点到直径两端点的最短路， 最后把最大值加起来就可。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, int&gt; P;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = int(1e9) + 7;const int N = int(1e5) + 10;struct edge&#123; int u, v, ne; ll w;&#125;ed[2 * N];int n, cnt, head[N];ll dis1[N], dis2[N];bool vis[N];void init()&#123; cnt = 0; memset(head, -1, sizeof head);&#125;void add(int u, int v, ll w)&#123; ed[cnt].u = u, ed[cnt].v = v, ed[cnt].w = w, ed[cnt].ne = head[u]; head[u] = cnt++;&#125;int dijk(ll dis[], int st)&#123; for (int i = 1; i &lt;= n; i++) dis[i] = ll(1e15); memset(vis, false, sizeof vis); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;q; dis[st] = 0; q.emplace(0, st); while(!q.empty())&#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v; if (dis[v] &gt; dis[u] + ed[i].w)&#123; dis[v] = dis[u] + ed[i].w; q.emplace(dis[v], v); &#125; &#125; &#125; ll ans = 0, ansj; for (int i = 1; i &lt;= n; ++i)&#123; if (dis[i] != ll(1e15) &amp;&amp; dis[i] &gt; ans)&#123; ans = dis[i], ansj = i; &#125; &#125; return ansj;&#125;int main() &#123; std::ios::sync_with_stdio(0); int a, b; ll c; while(cin &gt;&gt; n)&#123; init(); for (int i = 0; i &lt; n - 1; ++i)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; int s1 = dijk(dis1, 1); int s2 = dijk(dis1, s1); dijk(dis1, s1); dijk(dis2, s2); ll ans = dis1[s2]; for (int i = 1; i &lt;= n; i++)&#123; if (i == s1 || i == s2) continue; ans += max(dis1[i], dis2[i]); &#125; cout &lt;&lt; ans &lt;&lt;\"\\n\"; &#125; return 0;&#125;、 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"树的直径","slug":"树的直径","permalink":"https://solodance.top/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"}]},{"title":"2019牛客国庆集训派对 E-Partial Sum （绝对值的特殊性）","date":"2020-01-23T13:42:35.139Z","path":"2020/01/23/2019牛客国庆集训派对 E-Partial Sum （绝对值的特殊性）/","text":"题目大意题目链接给定长为n的数组， 找到m组(L, R)， 使得|sum（L,R）| - C的和最大， 其中C为常数（输入中给出）， 每个(L, R)只出现一次。 思路求区间前缀和， 因为绝对值的特性， |sumi - sumj = sumj - sumi| 所以前后减的顺序没关系， 他也没要求具体是那m组， 所以sort后 最大减最小就可。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define eps 1e-8typedef long long ll;typedef pair&lt;ll, int&gt; P;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = int(1e9) + 7;const int N = int(1e5) + 10;int sum[N];int main() &#123; std::ios::sync_with_stdio(0); int n, m, c, x; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; c)&#123; sum[0] = 0; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; x; sum[i] = sum[i - 1] + x; &#125; sort(sum, sum + n + 1); int l = 0, r = n; ll ans = 0; while(m--)&#123; int temp = sum[r] - sum[l] - c; if (temp &lt;= 0) break; l++, r--; ans += ll(temp); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"绝对值的特殊性","slug":"绝对值的特殊性","permalink":"https://solodance.top/tags/%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7/"},{"name":"思维","slug":"思维","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"2019牛客多校训练赛第五场B题generator 1（十进制矩阵快速幂）","date":"2020-01-23T13:42:35.123Z","path":"2020/01/23/2019牛客多校训练赛第五场B题generator 1（十进制矩阵快速幂）/","text":"题目链接题干 题目大意 给你四个数： x0, x1, a, b 都&gt;=1 &lt;=1e9 x(i) = a * x (i - 1) + b * x(i - 2) i &gt;= 2 给你两个数： n, mod. 1&lt;=n&lt;=10 ^ (10 ^ 6) (超大) 1e9 &lt;= mod &lt;= 2e9 输出x(n) 思路用十进制快速幂， tql时间复杂度是 10 ^ 6 * log 10变换矩阵也很好推 具体看代码 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define esp 1e-6using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e2 + 5;const int M = 1e9 + 5;;int mod;struct Matrix&#123; ll m[3][3];&#125;unit;Matrix mul(Matrix a, Matrix b, int n, int m)&#123; // a * b n为a的行数， m为b的列数 Matrix c; memset(c.m, 0, sizeof c.m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod ; // 取模在这里取 return c;&#125;Matrix q_pow2(Matrix a, ll b, int n) &#123; // a^b n为矩阵大小 Matrix ans = unit; while(b)&#123; if (b &amp; 1) ans = mul(ans, a, n, n); a = mul(a, a, n, n); b &gt;&gt;= 1; &#125; return ans;&#125;Matrix q_pow_10(Matrix a, string b, int n)&#123; Matrix ans = unit; int len = b.length(); for (int i = len - 1; i &gt;= 0; i--)&#123; int num = b[i] - '0'; ans = mul(ans, q_pow2(a, num, n), n, n); a = q_pow2(a, 10, n); &#125; return ans;&#125;int main()&#123; unit.m[1][1] = unit.m[2][2] = 1; Matrix A, B, C; string s; int x0, x1, a, b; cin &gt;&gt; x0 &gt;&gt; x1 &gt;&gt; a &gt;&gt; b &gt;&gt; s &gt;&gt; mod; A.m[1][1] = a; A.m[1][2] = b; A.m[2][1] = 1; A.m[2][2] = 0; B.m[1][1] = x1; B.m[2][1] = x0; int len = s.length(); if (len == 1 &amp;&amp; s[0] == '1')&#123; cout &lt;&lt; x1 &lt;&lt; \"\\n\"; return 0; &#125; // 将s减1 while(len--)&#123; if (s[len] != '0')&#123; s[len] --; break; &#125; else s[len] = '9'; &#125; if (s[0] == '0') s.erase(0, 1); A = q_pow_10(A, s, 2); A = mul(A, B, 2, 1); cout &lt;&lt; A.m[1][1] &lt;&lt; \"\\n\"; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"2019牛客多校训练赛","slug":"2019牛客多校训练赛","permalink":"https://solodance.top/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%B5%9B/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://solodance.top/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"2019牛客多校训练赛第五场A题 （思维题）","date":"2020-01-23T13:42:35.123Z","path":"2020/01/23/2019牛客多校训练赛第五场A题 （思维题）/","text":"题目描述（看不清图片可以右击图片-&gt; 复制图片地址 -&gt;浏览器新开一个标签页，粘贴此地址就可看大图（也可以右击图片-&gt; 在新标签页打开图片 题解题意：给你一个整型x（x &lt;= 100）， 让你输出一个整型y， y要满足3个条件: y 能被 x 整除 y和各个数位的数字之和能被 x 整除(就是个位， 十位， 百位，… 之和) y的位数不超过 10^4 思维题， 真是太妙了。最简单的构造方法就是， 把n看做字符串， 输出n个头尾相连的字符串n即可。 第一个条件： 这肯定是满足的呀。 1234举个例子x = 99y = 99个99用竖式除一下， 就是（1010101...) 第二个条件：这也肯定了呀。 1234举个例子x = 99y = 99个99求和就是99个(18) 第三个条件， x最大是100， 100个100正好10 ^ 4 AC代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;const int mod = 998244353;int main()&#123; ios::sync_with_stdio(0); int t, n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)&#123; cout &lt;&lt; n; &#125; cout &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"2019牛客多校训练赛","slug":"2019牛客多校训练赛","permalink":"https://solodance.top/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%B5%9B/"}]},{"title":"2019牛客多校训练赛第二场H题（单调栈＋思维）Second Large Rectangle","date":"2020-01-23T13:42:35.108Z","path":"2020/01/23/2019牛客多校训练赛第二场H题（单调栈＋思维）Second Large Rectangle/","text":"题目描述（看不清图片可以右击图片-&gt; 复制图片地址 -&gt;浏览器新开一个标签页，粘贴此地址就可看大图（也可以右击图片-&gt; 在新标签页打开图片 题解听师哥讲得才明白怎么做， 我好菜啊~！单调栈的应用把题目中矩阵拆开看， 看成以第i行为底的直方图， 然后暴力这i行， 根据单调栈求即可。可以转化成这题来做： 点此 有几个小问题需要注意： 以第i行的矩阵可以由第i-1行求出 添加的时候需要注意， 不仅仅要把所求的添加上， 还要加上原矩阵 宽减一 乘以 高 和 宽 乘以 高减一。 ac代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;struct node&#123; int height; int width; node()&#123; height = 0; width = 0; &#125;&#125;;int n, m;int ans1, ans2;stack &lt;node&gt; st;string s;int a[1003][1003];void max2(int a)&#123; if (ans1 &lt; a)&#123; ans2 = ans1; ans1 = a; &#125; else if (ans2 &lt; a) ans2 = a;&#125;void solotion(int x[])&#123; node a; for (int i = 1; i &lt;= m + 1; i++)&#123; if (i &lt;= m) a.height = x[i]; else a.height = -1; // 最后加入一个0元素， 使栈全部元素弹出, 巧妙啊 a.width = i; while(!st.empty() &amp;&amp; st.top().height &gt;= a.height) &#123; int x1 = st.top().height, x2 = i - st.top().width; max2(x1 * x2); max2(x1 * (x2 - 1)); max2((x1 - 1) * x2); a.width = st.top().width; st.pop(); &#125; st.push(a); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; s; for (int j = 1; j &lt;= m; j++)&#123; if (i == 1) a[i][j] = s[j - 1] - '0'; else&#123; if (s[j - 1] == '1') a[i][j] = a[i - 1][j] + 1; else a[i][j] = 0; &#125; &#125; &#125; /*for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; cout &lt;&lt; a[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\"; &#125;*/ for (int i = 1; i &lt;= n; i++) solotion(a[i]); cout &lt;&lt; ans2 &lt;&lt; \"\\n\"; return 0;&#125;/*5 7000100000110001011011101101111111117 */ 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"2019牛客多校训练赛","slug":"2019牛客多校训练赛","permalink":"https://solodance.top/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%B5%9B/"},{"name":"单调栈","slug":"单调栈","permalink":"https://solodance.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"2019牛客多校训练赛第二场F题Partition problem（dfs + 暴力枚举）","date":"2020-01-23T13:42:35.092Z","path":"2020/01/23/2019牛客多校训练赛第二场F题Partition problem（dfs + 暴力枚举）/","text":"题目描述（看不清图片可以右击图片-&gt; 复制图片地址 -&gt;浏览器新开一个标签页，粘贴此地址就可看大图（也可以右击图片-&gt; 在新标签页打开图片 题解题意： 给你2 * n个人， 以及他们之间的竞争值（用矩阵表示），让你分成两组， 每组n个人， 问你如何分才能让竞争值最大（同队之间不存在竞争）， 输出最大竞争值 。 分析： 用dfs爆搜， 从1开始， 当groupA 组员数小于n时， 就可以放进A， 同理groupB也是。最后当搜索到第 2 * n + 1时return。 ac代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;ll val[102][102];int n;ll ans;int group1[102], group2[102];void dfs(int cur, int cnt1, int cnt2, ll sum)&#123; if (cur &gt;= 2 * n + 1)&#123; ans = max(ans, sum); return; &#125; if (cnt1 &lt; n)&#123; ll tem = sum; group1[cnt1 + 1] = cur; for (int i = 1; i &lt;= cnt2; i++) tem += val[group2[i]][cur]; dfs(cur + 1, cnt1 + 1, cnt2, tem); &#125; if (cnt2 &lt; n)&#123; ll tem = sum; group2[cnt2 + 1] = cur; for (int i = 1; i &lt;= cnt1; i++)&#123; tem += val[group1[i]][cur]; &#125; dfs(cur + 1, cnt1, cnt2 + 1, tem); &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= 2 * n; i++)&#123; for (int j = 1; j &lt;= 2 * n; j++)&#123; cin &gt;&gt; val[i][j]; &#125; &#125; dfs(1, 0, 0, 0); cout &lt;&lt; ans &lt;&lt; \"\\n\";&#125; 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"dfs","slug":"dfs","permalink":"https://solodance.top/tags/dfs/"},{"name":"暴力枚举","slug":"暴力枚举","permalink":"https://solodance.top/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"},{"name":"2019牛客多校训练赛","slug":"2019牛客多校训练赛","permalink":"https://solodance.top/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%B5%9B/"}]},{"title":"为萌新准备的如何用codeblocks新建c or c++代码并编译运行","date":"2020-01-23T13:42:35.092Z","path":"2020/01/23/为萌新准备的如何用codeblocks新建c or c++代码并编译运行/","text":"1. 安装直接默认走起， 需要勾选的就都勾选上， 一直next就好， 注意一点，安装位置建议安装在固态里， 或者c盘就行。ps： 安装包在群里 2. 如何新建c / c++文件， 编译并运行首先注明一点， 不建议汉化， 汉化很容易出bug， 你所需要的那一点东西， 完全看到懂。 安装完成打开后界面如下， 点击 Create a new project 按照下图一直操作 新建完成后出现以下界面， 双击 Sources文件夹 双击 main.cpp or main.c 编译运行可能会等一下， 然后就会弹出命令窗了 3. 经常遇到的问题 若遇到无法编译， 就是点编译并运行按钮时， 右下角会弹出黄色警告， 并且命令窗也没弹出来， 一般解决方案：点击Setting(最上面哪一行倒数第二个) -&gt; Compiler...然后点击， 出现什么都点yes, 最后完成后重启就好了 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"零碎小知识","slug":"零碎小知识","permalink":"https://solodance.top/tags/%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"codeblocks","slug":"codeblocks","permalink":"https://solodance.top/tags/codeblocks/"}]},{"title":"做题时文件的读入（c++）","date":"2020-01-23T13:42:35.092Z","path":"2020/01/23/做题时文件的读入（c++）/","text":"直接看代码： 123456789101112131415161718 FILE *fp = fopen(\"input.txt\", \"r\"); // 根据题目中要求的写 有的是text.txt FILE *fpw = fopen(\"output.txt\", \"w\"); int i = -1; // 第一行特殊就专门输入 while(!feof(fp))&#123; // 把整个文件一个个读进去 if (i == -1) // 第一行特殊就专门输入 fscanf(fp, \"%d %d %d\", &amp;n, &amp;m, &amp;K); else&#123; fscanf(fp, \"%d%d\", &amp;a[i], &amp;b[i]); &#125; i++; &#125; // 正常主体代码 // 最后输出 fprintf(fpw, \"%d %d\\n\", indx, indy); return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小知识","slug":"小知识","permalink":"https://solodance.top/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"组合数打表模板","date":"2020-01-23T13:42:35.092Z","path":"2020/01/23/组合数打表模板/","text":"组合数打表模板组合数打表模板,适用于N&lt;=3000c[i][j]表示从i个中选j个的选法。 123456789101112long long C[N][N];const int mod = 1e9 + 5;void get_C(int maxn) &#123; C[0][0] = 1; for (int i = 1; i &lt;= maxn; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; // C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; &#125; &#125;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"组合数打表","slug":"组合数打表","permalink":"https://solodance.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E6%89%93%E8%A1%A8/"}]},{"title":"为Clion配置mingw32或mingw64","date":"2020-01-23T13:42:35.076Z","path":"2020/01/23/为Clion配置mingw32和mingw64/","text":"1. 安装MinGW32 或者 MinGW64我不教怎么用官方的软件安装（我也不会， 直接交给你们一个技巧MinGW32 和 MinGW64 选择其一安装即可 安装 MinGW32 ： 安装codeblocks， 官方下载链接， 在其安装目录里就有MinGW32 安装MinGW64: ： 同样， 安装devc++， 下载链接 ， 在其安装目录里就有MinGW64 2. 配置CLion C/C++ 运行环境按照下图配置即可（若看不清就右击图片， 在新窗口打开， 或者复制图片地址在新窗口打开） 3. 新建项目配置文件在你项目的根目录下， 新建 CMakeLists.txt， 然后在其填入下列代码 123456cmake_minimum_required(VERSION 3.10)project(project1) set(CMAKE_CXX_STANDARD 11)add_executable(project1 main.cpp) 解释一下 1234567891011121314cmake_minimum_required(VERSION 3.10) 这个不用管project(project1) 括号里的是你的项目名称, 也就是你项目根文件夹的名称set(CMAKE_CXX_STANDARD 11) 不用管add_executable(project1 main.cpp) 这句话的意思是 project1 项目下的 main.cpp 可以编译运行了add_executable(template template.cpp) 若是想运行多个cpp文件， 那就要这样配置， 第一个template 是另一个项目名称， 随便起（但不能和上面出现过的项目名相同）， template.cpp 是你想运行的另一个cpp文件你也可以添加很多个add_executable(template1 template1.cpp) add_executable(template2 template2.cpp) add_executable(template3 template3.cpp) 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"clion","slug":"clion","permalink":"https://solodance.top/tags/clion/"},{"name":"零碎小知识","slug":"零碎小知识","permalink":"https://solodance.top/tags/%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"数据结构实验12 ：排序","date":"2020-01-23T13:42:35.076Z","path":"2020/01/23/数据结构实验12： 排序/","text":"实验12 ： 排序要求： 直接插入排序； 折半插入排序； 希尔排序; 冒泡排序 简单选择排序 树型选择排序 堆排序 详情见代码，注释应该比较清晰。（树形排序暂时还没有， 等着补上（因为这个太费时间了）） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e4 + 5;int b[N], a[N];int n;void InsertSort(int a[]) &#123; // 直接插入排序（升序） int i, j; for (i = 2; i &lt;= n; i++) &#123; if (a[i] &lt; a[i - 1]) &#123; // 反之， 若a[i] &gt;= a[i - 1] ，则此时这部分数组是升序的， 则不用处理 a[0] = a[i]; // a[0] 叫监视哨 for (j = i - 1; a[0] &lt; a[j]; j--) &#123; // 这里的判断条件不 加等号即不是 a[0] &lt;= a[j] 有两个原因 // 1. 保持排序的稳定性 // 2. 如果加了等号， 那么当 i == 2 时， j == 0 ， 然后 a[0] &lt;= a[j] 此循环继续 j 变为-1 那么就变成 a[-1] 虽然这是合法的， 但会出现莫名的错误 a[j + 1] = a[j]; &#125; a[j + 1] = a[0]; &#125; &#125;&#125;void BInsertSort(int a[]) &#123; // 折半插入排序 int i, j, high, low, mid; for (i = 2; i &lt;= n; i++) &#123; if (a[i] &lt; a[i - 1]) &#123; a[0] = a[i]; low = 1, high = i - 1; while (low &lt;= high) &#123; mid = low + high &gt;&gt; 1; // 二进制运算， 相当于 （low + high）/ 2 if (a[0] &lt; a[mid]) high = mid - 1; else low = mid + 1; &#125; for (j = i - 1; j &gt;= high + 1; j--) &#123; a[j + 1] = a[j]; &#125; a[high + 1] = a[0]; &#125; &#125;&#125;void ShellInsert(int a[], int dk) &#123; // 一趟 增量为dk的希尔排序 for (int i = dk + 1; i &lt;= n; i++) &#123; // dk + 1 是最小的 单位了 if (a[i] &lt; a[i - dk]) &#123; a[0] = a[i]; int j; for (j = i - dk; j &gt; 0 &amp;&amp; a[0] &lt; a[j]; j -= dk) &#123; a[j + dk] = a[j]; &#125; a[j + dk] = a[0]; &#125; &#125;&#125;void ShellSort(int a[]) &#123; // t 趟 希尔排序 int k, t, dk[N]; t = int(log(n + 1));// 书上给的/* cout &lt;&lt; \"t : \" &lt;&lt; t &lt;&lt; \"\\n\";*/ for (int i = 1; i &lt;= t; i++) &#123; dk[i] = pow(2, t - i + 1) - 1; // 书上给的/* cout &lt;&lt; \"dk\" &lt;&lt; i &lt;&lt; ':' &lt;&lt; dk[i] &lt;&lt; \"\\n\";*/ &#125; for (int i = 1; i &lt;= t; i++) &#123; ShellInsert(a, dk[i]); &#125;&#125;void BubbleSort(int a[]) &#123; // 冒泡排序 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n - i + 1; j++) &#123; if (a[j - 1] &gt; a[j]) &#123; swap(a[j - 1], a[j]); &#125; &#125; &#125;&#125;void SelectSort(int a[]) &#123; // 简单选择排序 for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (a[i] &gt; a[j]) &#123; swap(a[i], a[j]); &#125; &#125; &#125;&#125;void HeapAdjust(int a[], int s, int m) &#123; // 筛法调整堆 // 假设a[s + 1..m] 已经是堆， 将a[s..m] 调整为以a[s] 为根的大根堆 int rc = a[s]; for (int j = 2 * s; j &lt;= m; j *= 2) &#123; // 从2 * s 开始 if (j &lt; m &amp;&amp; a[j] &lt; a[j + 1]) // 注意 莫忘j &lt; m j++; if (rc &gt;= a[j]) break; a[s] = a[j]; s = j; &#125; a[s] = rc;&#125;void CreatHeap(int a[]) &#123; // 建大根堆 for (int i = n / 2; i &gt; 0; i--) &#123; HeapAdjust(a, i, n); // 序号大于 int (n / 2) 的节点都是叶子节点 注意 n / 2 - 1 不行 因为 n / 2 * 2 ?= n &#125;&#125;void HeapSort(int a[]) &#123; CreatHeap(a); for (int i = n; i &gt; 1; i--) &#123; swap(a[1], a[i]); HeapAdjust(a, 1, i - 1); &#125;&#125;int TSelect(int c[], int s, int m) &#123; if (m == 1) return c[1]; for (int i = s; i &lt;= m; i += 2) &#123; c[i / 2] = min(c[i], c[i + 1]); &#125; int d = m - s + 1; m = s - 1; s = m - d / 2 + 1;&#125;void TSelectSort(int a[]) &#123; // 因为实在不知道如何记录 value 对应的 key 我就用map写吧 int c[N]; // 储存树 map&lt;int, int&gt; ma; // 记录 value 对应key int k, nn = n; if (n % 2 == 1) &#123; a[n + 1] = INF; nn++; &#125; /*让第 n + 1 个数变成正无穷， 叶子节点为偶数个 *如果 n 为 偶数， 那就不起作用 * 如果n 为奇数， 起作用 */ k = nn / 2 + 1; for (int i = 1; i &lt;= n; i++) &#123; c[k] = a[i]; ma[a[i]] = k++; &#125; for (int i = 1; i &lt;= n; i++) &#123; a[i] = TSelect(c, nn / 2 + 1, nn); c[ma[a[i]]] = INF; &#125;&#125;int main() &#123; printf(\"请输入你要排序的序列中的元素个数：\\n\"); while (cin &gt;&gt; n) &#123; if (n == 0) break; printf(\"请输入各元素：\\n\"); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; a[i] = b[i]; // 复制此数组， 以便于再次利用原数组 &#125; printf(\"请选择你要排序的方法的下标：\\n\" \"1、直接插入排序；\\n\" \"2、折半插入排序；\\n\" \"3、希尔排序;\\n\" \"4、冒泡排序\\n\" \"5、简单选择排序\\n\" \"6、堆排序\\n\"); int o; cin &gt;&gt; o; switch (o) &#123; case 1: InsertSort(a); break; case 2: BInsertSort(a); break; case 3: ShellSort(a); break; case 4: BubbleSort(a); break; case 5: SelectSort(a); break; case 6: HeapSort(a); break; &#125; printf(\"排序后的结果为：\\n\"); for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n\"; printf(\"请输入你要排序的序列中的元素个数(结束请输入0)：\\n\"); &#125; return 0;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://solodance.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"查找","slug":"查找","permalink":"https://solodance.top/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"如何通过学生邮箱（教育邮箱）申请Jetbrains系列软件无限期试用","date":"2020-01-23T13:42:35.045Z","path":"2020/01/23/如何通过学生邮箱（教育邮箱）申请Jetbrains系列软件无限期试用/","text":"1. 获得（学生邮箱）教育邮箱作为山师er， 我们在入学时学校已经给了我们教育邮箱， 只是大多数人都不知道罢了，邮箱为 12账号 : 学号+@stu.sdnu.edu.cn 如 201811010121@stu.sdnu.edu.cn密码 ： 初始密码为身份证后8位， 记住 是 后8位！！ 如何登陆呢， 这里附上山师学生邮箱官网， 点击下面链接登陆即可http://mail.stu.sdnu.edu.cn/ 注意， 若是用手机端进入的同学， 一定要切换到电脑版在登陆。如下图： 2. 申请试用Jetbrains试用当你拥有了你的学生邮箱， 就可以申请试用啦。 进入Jetbrains官网 https://account.jetbrains.com/login ， 用自己的学生邮箱注册账号 （有时候Jetbrains官网相应的比较慢， 请耐心等待）若看不清下图请右击在新窗口打开~ 点击sign up后，官方会发一封确认验证邮件到你的邮箱上， 有时候过好几分钟才会发过来， 请耐心等待一下吧。收到邮件设置好账号密码， 然后进入下一步2. 进入 https://www.jetbrains.com/shop/eform/students， 开始填写资料。（有时候Jetbrains官网相应的比较慢~请耐心等待）如下图， 若看不懂请翻译… 填写完成后， 你就等着Jetbrains给你发送申请成功的邮件， 一般一星期内就可~ 当你收到邮件时那么恭喜你申请成功了， 接下来就是下载Jetbrains了， 进入Jetbrains官网 https://www.jetbrains.com/， 把鼠标放在tool那一栏， 选择你要下载的工具， 比如你要下载WebStorm， 那就点击WebStorm， 然后中间有个大大的 download， 等待下载就行了， 当然有时候也会比较慢~ 当然你也可以安装Toolbox App， 在这里面可以下载Jetbrains里的一系列软件， 网速就稍微快点了， 管理更新也很方便。不过它默认在c盘， 建议更改一下下载位置。 3. 教育邮箱的其他用处教育邮箱的妙用， 请百度或者知乎， 这里贴一个知乎https://www.zhihu.com/question/53297353 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"Jetbrains","slug":"Jetbrains","permalink":"https://solodance.top/tags/Jetbrains/"},{"name":"零碎小知识","slug":"零碎小知识","permalink":"https://solodance.top/tags/%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"数据结构整理笔记（提纲） （数据结构 C语言版 第二版 严蔚敏）","date":"2020-01-23T13:42:35.045Z","path":"2020/01/23/数据结构笔记/","text":"第一章 绪论基本概念数据结构（这门学科）： 是一门研究数据的组织， 存储， 和运算的一般方法。 数据： 是客观事物的符号表示， 是所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素： 是数据的基本单位， 在计算机中通常作为一个整体进行考虑和处理。数据元素用于完整地描述一个对象。 数据项： 组成数据元素的、 有独立含义的、 不可分割的最小单位。例如 ：学生的姓名学号等。 数据对象： 是性质相同的数据元素的集合， 是数据的一个子集。只要集合内的性质均相同， 都可称之为一个数据对象。 数据结构： 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构 逻辑结构 集合结构（离散结构， 因为太简单， 所以不考虑） 线性结构 非线性结构 树结构 图结构或网状结构 存储结构 顺序存储结构 链式存储结构 逻辑结构二元组 （D， R） D是数据关系的集合 R是D关系上的集合（） 代表无序 &lt;&gt; 代表有序 抽象数据类型抽象数据类型 ： 一般指由用户定义的、 表示应用问题的数学模型， 以及定义在这个模型上的一组操作的总称。具体包括三部分： 数据对象， 数据对象上关系的集合 以及 对数据对象的基本操作的集合。定义格式： 12345ADT 抽象数据类型名&#123; 数据对象:&lt;数据对象的定义&gt; 数据关系:&lt;数据关系的定义&gt; 基本操作:&lt;基本操作的定义&gt;&#125; ADT 抽象数据类型名 算法算法 ：是为了解决某类问题而规定的一个有限长的操作序列。重要特性 有穷性 确定性 可行性 输入 输出 评价算法优劣的基本标准 正确性 能在有限的运行时间内得到正确的结果。 可读性 健壮性 高效性 时间空间 语句频度： 一条语句重复执行的次数 算法的时间复杂度： （一般指的是最坏时间复杂度） 常量阶实例 123for (int i = 1; i &lt;= 100000000; i++)&#123; puts(\"我爱你啊亲！\");&#125; 此算法时间复杂度 T(n) = O(1)。 算法的空间复杂度 常量阶12345for (int i = 0; i &lt;= n / 2; i++)&#123; t = a[i]; a[i] = a[n - i + 1]; a[n - i - 1] = t;&#125; 线性阶1234for (int i = 0; i &lt; n; i++) b[i] = a[n - i + 1];for (int i = 0; i &lt; n; i++) a[i] = b[i]; 此算法需要借助大小为n的辅助数组， 所以其空间复杂度为O(n)。 第二章 线性表线性表： 由n（n &gt;= 0）个数据特性相同的元素构成的有限序列。空表： n = 0的线性表。 非空的线性表或线性结构的特点：（1） 存在唯一的一个被称作“第一个”的数据元素；（2） 存在唯一的一个被称作“最后一个”的数据元素；（3） 除第一个元素外， 结构中的每个数据元素均只有一个前驱；（4） 除最后一个元素外， 结构中的每个数据元素均只有一个后继。 顺序表线性表的顺序存储结构是一种随机存取的存储结构。 平均查找长度： 在查找时， 为确定元素在顺序表中的位置， 需和给定的值进行比较的数据元素个数的期望值称为查找算法在查找成功时的平均查找长度（Average Search Length ASL） 假设pi 是查找第i个元素的概率， Ci 为找到其中关键字与给定值相等的第i个记录时， 和给定值已进行过比较的关键字个数， 则在长度为n的线性表中， 查找成功时的平均查找长度为ASL = piCi （i : 1 - n 之和） 链表链表这东西没什么好说的， 会一些基本的操作就行。 待解决的问题把链表的基本操作写一下。 第三章 栈和队列栈 （后进先出的数据结构（Last In First Out, LIFO））栈顶， 栈底。 顺序栈 链栈 递归*： 定义是递归的 比如： 阶乘，二阶Fibonacci数列 分治法： 能将一个问题变成一个新问题， 而新问题与原问题的解法相同或类同， 不同的仅是处理的对象， 并且这些处理对象更小且变化有规律。 可以通过上述转化而使问题简化。 必须有一个明确的递归出口， 或称递归的边界。 数据结构是递归的 比如： 链表 问题的解法是递归的 比如： Hanoi塔问题， 八皇后问题， 迷宫问题 递归的算法效率分析：通过迭代法求解递归方程来计算时间复杂度。 队列 （先进先出的数据结构（First In First Out, FIFO））队头， 队尾 顺序队列（循环队列）少用一个元素空间；队空的条件： Q.front == Q.rear队满的条件： (Q.rear + 1) % MAXQSIZE == Q.front 链队 遗留的问题链栈， 顺序队， 链队的代码 第四章 串、数组和广义表串（或字符串）串的模式匹配算法 BF算法（Brute-Force）就是暴力、这个 太简单就不写代码了。 KMP算法最主要的是如何构造next数组和nextval数组 next数组（模式串）： 0 j = 1 max k(1 &lt; k &lt; j) ‘p1 p2 … p(k - 1)’ == ‘p(j - k + 1) … p(j - 2) p(j - 1)’通俗的来说 就是看 j 前面的 k - 1（1 &lt; k &lt; j）字符 和 从 1 到k - 1的字符是不是一样 1 一个字符都不匹配 nextval数组 求出next数组 根据next数组判断 s[j] ?= s[next[j]]如果相等 nextval[j] = next[next[j]]如果不想等(不相等) nextval[j] = next[j] 数组数组很简单就不说了 广义表就把一些基本的定义弄熟就行了广义表一般记作LS = (a1, a2, a2, ..., an) 其中LS是这个广义表的名称， n为其长度。ai 可以是单个元素， 也可以是广义表 分别称为 广义表LS的原子和字表。习惯上， 用大写字母表示广义表的名称， 用小写字母表示原子。显然， 广义表的定义是一个递归的定义， 因为在描述广义表时又用到了广义表的概念。例子 A = () —— A是一个空表， 其长度为0。 B = (e) —— B只有一个原子e，其长度为1。 C = (a, (b, c, d)) —— C的长度为2， 两个元素分别为原子a和字表(b, c, d)。 D = (A, B, C) —— D的长度为3， 三个字表都是广义表。 E = (a, E) —— 这是一个递归表， 长度为2。E 相当于一个无限的广义表 E = (a, (a, (a, …)))。 概念 表头（是一个元素）： 为非空广义表的以一个元素， 它可以是一个原子也可以是一个子表。 表尾（是一个广义表）：除表头之外， 由其余元素构成的表。（若只有一个元素， 那么其为空表）。 遗留的问题 KMP算法的实现 第五章 树和二叉树树树： 是n（n &gt;= 0）个结点的有限集， 它或为空树；或为非空树， 对于非空树T： 有且仅有一个称之为根的结点。 除根结点以外的其余结点可分为m(m &gt; 0) 个互不相交的有限集T1, T2, …, TM, 其中每一个集合本身又是一棵树， 并且称之为根的子树（SubTree）。 树的基本术语 结点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支 。 结点的度： 结点拥有的子树数。（这个结点后继的个数）。 树的度： 树内各结点度的最大值。 叶子： 度为0的结点称为叶子结点或者终端结点。 非终端结点： 度不为0的结点称为非终端结点或者分支结点。 除根结点以外， 非终端结点也称为内部结点。 双亲和孩子： 结点的子树的根称为该结点的孩子， 相应地， 该结点称为孩子的双亲。 兄弟： 同一个双亲的孩子之间互称兄弟。 祖先： 从根到该结点所经分支上的所有结点。 子孙： 以某结点为根的子树中的任一结点都称为该结点的子孙。 层次： 结点的层次从根开始定义起， 根为第一层， 根的孩子为第二层。 树中任一结点的层次等于其双亲结点的层次加一。 堂兄弟： 双亲在同一层的结点互为堂兄弟。 树的深度： 树中结点的最大层次称为树的深度或高度。 有序树和无序树： 如果将树中结点的各子树看成从左到右是有次序的， 则称该树为有序树， 否则称为无序树。 森林： 是m(m &gt;= 0) 课互不相交的树的集合。 二叉树二叉树：是n (n &gt;= 0) 个结点所构成的集合。对于非空树T： 有且仅有一个称之为根的结点。 除根结点外的其余结点分为两个互不相交的子集T1 和T2， 分别称为T的左子树和右子树。 二叉树与树的区别 二叉树每个结点至多只有两棵子树。 二叉树是有序树。 二叉树的性质 在二叉树的第i层上至多有2 ^ (i - 1) 个结点（i &gt;= 1）。 深度为k的二叉树至多有2 ^ k - 1个结点。 对任何一棵二叉树T， 如果其终端结点数为n0， 度为2的结点数为n2， 则n0 = n2 + 1。 证明*：1234567891011设B为总分支数二叉树结点总数n = n0 + n1 + n2除了根结点外， 每一个结点都有一个分支进入则n = B + 1由于这些分支是由度为1 和度为2 的结点射出的，所以B = n1 + 2 * n2于是得n = n1 + 2* n2 + 1所以n0 = n2 + 1 对于任意一棵树： 12345678910树的总结点个数为n = n1 + n2 + ... + nk除了根结点外， 每一个结点都有一个分支进入则n = B + 1由于这些分支是由度为1 ， 度为2， ...， 度为k的结点射出的， 所以B = n1 + 2 * n2 + 3 * n3 + ... + k * nk于是得n = n1 + 2 * n2 + 3 * n3 + ... + k * nk + 1所以n0 = 1 + n2 + 2 * n3 + ... + (k - 1) * nk 满二叉树： 深度为k且含有2 ^ k - 1个结点的二叉树。 完全二叉树： 深度为k的， 有n个结点的二叉树， 当且仅当其每一个结点都与深度为k的满二叉树中编号从1 - n 一一对应时， 称为完全二叉树。 特点 叶子节点只可能在层次最大的两层上出现（第k层和第k - 1层）； 对任一结点， 若其右分支下的子孙的最大层次为l， 则其左分支下的子孙的最大层次必为l 或 l + 1 。 具有n个结点的完全二叉树的深度为 (向下取整)[log2 n] + 1。 遍历二叉树和线索二叉树遍历二叉树 前序（先序）遍历 访问根结点 先序遍历左子树 先序遍历右子树 中序遍历 中序遍历左子树 访问根结点 中序遍历右子树 后序遍历 后序遍历左子树 后序遍历右子树 访问根结点 表达式的前缀表示：波兰式。表达式的后缀表示：逆波兰式。表达式的中缀表示：中缀式。 如何根据中缀式写出波兰表达式和逆波兰表达式？相关博客链接 线索二叉树构造中序线索二叉树在二叉树的线索链表上添加一个头结点，令其lchild 指向二叉树的根结点， rchild指向中序遍历时的最后一个节点；同时令二叉树中序遍历序列第一个节点的lchild和最后一个节点的rchild指向头结点。以结点p为根的子树中序线索化 若p非空， 左子树递归线索化 若p的左孩子为空， 则给p加上左线索， 将其LTag置为1， 让p的左孩子指针指向pre（前驱）；否则将LTag置为0。 若pre的右孩子为空，则给pre加上右线索， 将其LTag置为1， 让pre的右孩子指针指向p（后继）；否则将pre的LTag置为0； 将pre指向刚访问过的结点p， 即pre = p。 右子树递归线索化。1234567891011121314151617181920void InThreading(BiThrTree p)&#123; //pre为全局变量， 初始化时其右孩子指针为空， 便于在树的最左点开始建线索。 if (p)&#123; InThreading(p -&gt; lchild); if (!p-&gt;lchild)&#123; p-&gt;LTag = 1; p-&gt;lchild = pre; &#125; else p-&gt;LTag = 0; if (!pre-&gt;rchild)&#123; pre-&gt;RTag = 1; pre-&gt;rchild = p; &#125; else pre-&gt;RTag = 1; pre = p; InThreading(p-&gt;rchild); &#125;&#125; 带头结点的二叉树中序线索化 1234567891011121314151617void InOrderThreading(BiThrTree &amp;Thrt, BithrTree T)&#123; //中序遍历二叉树T， 并将其中序线索化。 Thrt指向头结点 Thrt = new BiThrNode; Thrt-&gt;LTag = 0; Thrt-&gt;RTag = 1; Thrt-&gt;rchild = Thrt; if (!T) Thrt-&gt;lchild = Thrt; else&#123; Thrt-&gt;lchild=T; pre = Thrt; InThreading(T); pre-&gt;rchild = Thrt; pre-&gt;RTag = 1; Thrt-&gt;rchild = pre; &#125;&#125; 遍历线索二叉树 在中序线索二叉树中查找 若p-&gt;LTag=1 ，则p的左链指向其前驱； 若p-&gt;LTag=0 ，则说明p有左子树， 结点的前驱是遍历其左子树时最后访问的一个结点。 若p-&gt;RTag=1， 则p的右链指向其后继； 若p-&gt;RTag=0， 则说明p有右子树， 结点的后继是遍历其右子树时访问的第一个结点。 在先序线索二叉树中查找 若p-&gt;LTag=1， 则p的左链指向其前驱； 若p-&gt;LTag=0， 则说明p有左子树， 此时p的前驱有两种情况：若*p是其双亲的左孩子， 则其双亲结点为其前驱；否则应该是其双亲的左子树上先序遍历的最后一个结点。 若p-&gt;RTag=1， 则p的右链指向其后继； 若p-&gt;RTag=0， 则说明p有右子树， *p的后继必为其左子树数（若存在）或右子树根。 在后序线索二叉树中查找 若p-&gt;LTag=1， 则p的左链指向其前驱； 若p-&gt;LTag=0， 当p-&gt;RTag=0时， 则p的右链指示其前驱；若p-&gt;RTag=1时， 则p的左链指向其前驱； 若p-&gt;RTag=1， 则p的右链指向其后继； 查找其后继比较复杂，若*p是二叉树的根， 则其后继为空；若*p是其双亲的右孩子， 则其后继为双亲结点；若*p是其双亲上午左孩子， 且*p没有右兄弟，则其后继为双亲结点；若*p是其双亲的左孩子， 且*p有右兄弟，， 则其后继为双亲的右子树上按后序遍历列出的第一个结点。 树和森林树的存储结构 双亲表示法 data parent 孩子表示法 孩子兄弟法又称二叉树表示法， 或二叉链表表示法， 即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点。 firstchild data nextsibling 树与二叉树的转换遵循左儿子右兄弟的原则。 树和森林的遍历树的遍历 先根遍历树：先访问数的根结点， 然后依次先根遍历根的每棵子树。 后根遍历树：先依次后根遍历每棵子树， 然后访问根结点。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://solodance.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://solodance.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"求n边形的面积","date":"2020-01-23T13:42:35.045Z","path":"2020/01/23/求n边形的面积/","text":"题目大意题目链接 给出正n边形n个点的坐标， 求n变形面积的2倍， 3&lt;=N&lt;=100000，0&lt;=xi,yi&lt;=10^9， mod = 1000000007 AC代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;#define ms(a, b) memset((a), (b), sizeof(a))typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll ll_max = 4557430888798830399;const int mod = 1e9 + 7;inline ll read() &#123; ll res = 0; bool f = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct node&#123; ll x, y;&#125;a[N];int n;ll ans;int main()&#123; while(~scanf(\"%d\", &amp;n))&#123; for (int i = 0; i &lt; n; ++i) a[i].x = read(), a[i].y = read(); a[n] = a[0]; ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + (a[i - 1].x * a[i].y - a[i].x * a[i - 1].y) % mod + mod) % mod; printf(\"%lld\\n\", ans); &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小知识","slug":"小知识","permalink":"https://solodance.top/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"判断一个数是不是2的整数次幂","date":"2020-01-23T13:42:35.029Z","path":"2020/01/23/判断一个数是不是2的整数次幂/","text":"判断一个数是不是2的整数次幂 123bool fun(int n)&#123; return (!(n &amp; (n-1))) &amp;&amp; n;&#125; 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小知识","slug":"小知识","permalink":"https://solodance.top/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"数学方法","slug":"数学方法","permalink":"https://solodance.top/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"强连通算法-tarjan","date":"2020-01-23T13:42:35.029Z","path":"2020/01/23/强连通算法-tarjan/","text":"强连通算法-tarjan先贴两篇比较好的博客https://blog.csdn.net/qq_34374664/article/details/77488976 https://blog.csdn.net/mengxiang000000/article/details/51672725 强连通分量 ：有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 直接贴模板了， 以后真正理解了在回来补。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;#define ms(a, b) memset((a), (b), sizeof(a))const int N = (int)1e5 + 5;const int INF = 0x3f3f3f3f;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge&#123; int u, v, ne;&#125;ed[N];int head[N], dis[N], vis[N], cnt, n, m, tot;int dfn[N], low[N]; int s[N], ind;inline void init()&#123; ms(head, -1); ms(dis, INF); ms(vis, 0); ind = tot = cnt = 0;&#125;inline void add(int u, int v)&#123; ed[cnt] = &#123;u, v, head[u]&#125;; head[u] = cnt++;&#125;void tarjan(int x)&#123; dfn[x] = low[x] = ++tot; s[++ind] = x; vis[x] = 1; for (int i = head[x]; ~i; i = ed[i].ne)&#123; int v = ed[i].v; if (!dfn[v])&#123; tarjan(v); low[x] = min(low[x], low[v]); &#125; else if (vis[v])&#123; low[x] = min(low[x], dfn[v]); &#125; &#125; // 下面输出强连通块 if (low[x] == dfn[x])&#123; do &#123; printf(\"%d \", s[ind]); vis[s[ind]] = 0; ind--; &#125;while(x != s[ind + 1]); printf(\"\\n\"); &#125;&#125;int main()&#123; init(); scanf(\"%d%d\", &amp;n, &amp;m); int u, v; for (int i = 1; i &lt;= m; ++i)&#123; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v); &#125; // 避免有漏的 for (int i = 1; i &lt;= n; ++i)&#123; if (!dfn[i]) tarjan(i); &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"tarjan","slug":"tarjan","permalink":"https://solodance.top/tags/tarjan/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://solodance.top/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"困时， 累时， 找些句子， 换一种方式思考","date":"2020-01-23T13:42:35.014Z","path":"2020/01/23/困时， 累时， 找些句子， 换一种方式思考/","text":"十年一品温如言， 只羡温言不羡仙谁是谁非，不过，呵呵一笑，十年含烟，梦醒时，揉揉眼睛，少年此间，哪个曾经温如言。 ——《十年一品温如言》回过头来看以前自己写的东西，才记得，原来自己曾经看过这么一本书，被这样一个句子所感动。一切，都物是人非。新的东西不断再取代旧的事物。记忆如是。第一次牵着你的手小鹿乱跳的样子，第一次亲吻幸福地要飞起来的感觉，第一次对你说那三个字信誓旦旦的模样。都已然凝结成片段，随风飘散在来时的路上了。时至今日，都已然找不回当时的纯粹了。 1这句话是出自一部小说&lt;十年一品温如言&gt; 男主叫言希 女主叫温衡 所以叫只羡温言不羡仙。 ——百度知道 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849豆瓣内容简介温衡笑眯眯，讲了个十年的故事。第一年，她从江南小镇的乌鸦变成了金光闪闪的凤凰，撞到一男一女接吻，此男长得甚是可口，心喜。第二年，他生了怪病，她趁乱，鸠占鹊巢，赖在他家。第三年，他的奸夫从维也纳飞回，她，鸡飞蛋打，灰溜溜逃窜。第四年，她奉父命，当了别人家的童养媳，他几乎忘了她。第五年，准未婚夫瞧不上她，跟别的女人跑了，他幸灾乐祸。第六年，没印象。第七年，一对奸夫淫夫，奶奶的，继续没印象！第八年，她出国留学，他为了别的男人跟家中彻底决裂。第九年，他被逼无奈，和她结婚生子。第十年，孩子出生，他干了囧事，一家三口，被驱逐出境。言希泪，颤巍巍地指，媳妇儿，你撒谎，故事明明是酱紫的。第一年，她做排骨很好吃呀很好吃。第二年，生病，没有印象。第三年，他出国度假，她被赶出温家。第四年，她失踪整整一年，他生她的气，不去找就是不去找。第五年，他躲在墙角，跟踪了她整整一年。第六年，她一生中最在意的那个男人出现。第七年，没印象。第八年，他出了车祸，她出了国。第九年，他追到法国，她背着他在雪地里走了一个冬季。第十年，情敌一号出生，回国。媳妇儿，这才是完整真实的故事，知道了吗？这是他们的故事，一种爱，两个轻转流年，谁是谁非，不过，呵呵一笑。十年含烟，梦醒时，揉揉眼睛，少年此间，哪个曾经温如言。 一种爱，两个轻转流年，谁是谁非，不过，呵呵一笑。十年含烟，梦醒时，揉揉眼睛，少年此间，哪个曾经温如言。 多数人25岁就死了，一直到75岁才埋。可我不愿意这样“只要有想见的人，就不是孤身一人” ——《夏目友人帐》不喜欢什么“乾坤未定，你我皆是黑马。” 总要为慵懒买单。“心有不甘，却无以为继”因为喜欢你 所以想借着你的光 去看一看从未见过的世界2019-8-16 20:13:58 有时候我就在想， 我自己想要的到底是什么， 我自己最终要变成什么样子， 能给我真正的快乐的人， 事， 物， 究竟是什么。自己究竟喜欢什么样的女生， 什么样的歌， 什么样的游戏。哪有什么困时， 不过是自己作息不正罢了， 那有什么累时， 你那还叫累？发现自己真可悲， 对自己亲近的人不怎么用心， 还整天觉得自己很牛逼是的， 其实就是一个***， 有一群人真正的在一起学习的感觉是真的好呀， 有个看得过去的女生更好咯（在没找对象之前）嘻嘻。 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"Solo_Dance","slug":"Solo-Dance","permalink":"https://solodance.top/tags/Solo-Dance/"}]},{"title":"快速算出一个数有多少种因子","date":"2020-01-23T13:42:35.014Z","path":"2020/01/23/快速算出一个数有多少种因子/","text":"快速算出一个数有多少种因子 123456789101112131415int count(int n)&#123; int s = 1; for(int i = 2; i * i &lt;= n; i++)&#123; if(n % i == 0)&#123; int a = 0; while(n % i == 0)&#123; n /= i; a++; &#125; s = s * (a + 1); &#125; &#125; if(n &gt; 1) s = s * 2; return s;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"数学","slug":"数学","permalink":"https://solodance.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"矩形相交问题","date":"2020-01-23T13:42:35.014Z","path":"2020/01/23/矩阵相交问题/","text":"给出矩形的 对角线上的两个点的坐标 (x11, y11)， (x12, y12)， (x21, y21), (x22, y22)。 1234567891011int x01 = max(min(x11, x12), min(x21, x22));int x02 = min(max(x11, x12), max(x21, x22));int y01 = max(min(y11, y12), min(y21, y22));int y02 = min(max(y11, y12), max(y21, y22));if (x01 &lt; x02 &amp;&amp; y01 &lt; y02)&#123; // 说明这两个矩形相交 int s = (x02 - x01) * (y02 - y01); // 相交的面积&#125;else&#123; // 这两个不相交 &#125; 例题 ： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;const int mod = 998244353;struct node&#123; int x1, y1, x2, y2; ll sum, s;&#125;arc[5005];int x01, x02, y01, y02;int main()&#123; int t, n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)&#123; arc[i].sum= 0; arc[i].s = 0; cin &gt;&gt; arc[i].x1 &gt;&gt; arc[i].y1 &gt;&gt; arc[i].x2 &gt;&gt; arc[i].y2; for (int j = 1; j &lt; i; j++)&#123; x01 = max(min(arc[i].x1, arc[i].x2), min(arc[j].x1, arc[j].x2)); x02 = min(max(arc[i].x1, arc[i].x2), max(arc[j].x1, arc[j].x2)); y01 = max(min(arc[i].y1, arc[i].y2), min(arc[j].y1, arc[j].y2)); y02 = min(max(arc[i].y1, arc[i].y2), max(arc[j].y1, arc[j].y2)); if (x01 &lt; x02 &amp;&amp; y01 &lt; y02)&#123; arc[i].sum++; arc[i].s += (x02 - x01) * (y02 - y01); arc[j].sum++; arc[j].s += (x02 - x01) * (y02 - y01); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; cout &lt;&lt; arc[i].sum &lt;&lt; ' ' &lt;&lt; arc[i].s &lt;&lt; \"\\n\"; &#125; &#125; return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小技巧","slug":"小技巧","permalink":"https://solodance.top/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"矩形相交","slug":"矩形相交","permalink":"https://solodance.top/tags/%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4/"}]},{"title":"解决爆栈问题，手动加栈","date":"2020-01-23T13:42:35.014Z","path":"2020/01/23/解决爆栈问题，手动加栈/","text":"解决爆栈问题，手动加栈1#pragma comment(linker,\"/STACK:1024000000,1024000000\") 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"手动加栈","slug":"手动加栈","permalink":"https://solodance.top/tags/%E6%89%8B%E5%8A%A8%E5%8A%A0%E6%A0%88/"}]},{"title":"解决ShadowsocksR 1080 端口被占用问题","date":"2020-01-23T13:42:35.014Z","path":"2020/01/23/解决ShadowsocksR 1080 端口被占用问题/","text":"解决ShadowsocksR 1080 端口被占用问题除了系统补丁会保留端口外，开启win10的hyper-v也会保留端口，比如我自己。 最简单的方法， 找到ssr根目录。 打开 gui-config.json， 将 localPort 1080 随便弄一个没保留的端口即可。 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"ssr","slug":"ssr","permalink":"https://solodance.top/tags/ssr/"}]},{"title":"好怕突然消失， 真的怕吗","date":"2020-01-23T13:42:34.982Z","path":"2020/01/23/好怕突然消失， 真的怕吗/","text":"好怕突然消失， 真的怕吗。网易云音乐里的账号已注销。 「账号已注销」的意思是：当你离开后， 我只好用沉溺于音乐的方式来表达我的伤心。 当我最后忘了你，我便不再用这种方式表达自己。 或是，我在想你的路上死了。 其实你喜欢的每一首歌，都不是没来由的。听别人说， 说到我们这一代人， 大概最缺乏的就是认同感了 把心情写在微博里， 有人嫌矫情； 把情绪写在朋友圈里， 有人笑傻逼； 把状态写在朋友圈里， 有人说装逼； 可是人总是需要一个地方， 一个可以光明正大写出来的地方。 不用担心被任何人看到， 不需要任何解释。 网易云音乐或许就是这么神奇的一个地方， 有时候只是一句评论， 却囊括了一整个青春。 看网易云的评论， 总感觉像是在看一段街头采访， 每个人都匆匆忙忙， 只是在镜头前留下自己的两三句话， 但总让我仿佛看到了他们的青春， 遗憾， 喜乐， 成长。 步履不停的人也总想找个与世隔绝的角落悄悄地吐露心声，静静地缅怀追忆，睁开眼我们又是赶路人。在那些不停被注销的账户同一时间里， 网易云音乐里有这样一群孤独的拾荒者， 他们每天执着地寻找那些 “已注销账号” 去听他们听过的歌， 走他们走过的路。 她就是其中一个， 直白的昵称：“收集已注销账号” 总有人笑她傻， 做这些毫无意义的事。 真正的有意义又是什么 她都只会默默笑。 终于在某一天， 关注完第520个 已注销的账号之后， 她也注销了自己的账号 只留下最后一句：“我终于自由了。” 好像是一种关于分别的仪式， 代表着：“我等过你了” 又或者是一次次失望， 明白了自己不值得等的人 有人心疼她， 守护了那么多人 直到最后自己消失也没能 也没能等到那个守护她的人。 过了一段时间， 又在评论区遇见那个“收集已注销账号” 像以前一样， 孤独地在评论区里拾着荒。 有些好奇的点开她的主页 面前的个人介绍却让我忍不住有点想哭： “这个昵称的原有者注销了，我留着这个号，等她回来。” 那是又一个掘墓人， 用了一模一样的名字 做着一模一样的事 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"Solo_Dance","slug":"Solo-Dance","permalink":"https://solodance.top/tags/Solo-Dance/"}]},{"title":"根据算数表达式（中缀式）求波兰表达式和逆波兰表达式","date":"2020-01-23T13:42:34.982Z","path":"2020/01/23/根据算数表达式（中缀式）求波兰表达式和逆波兰表达式/","text":"根据算数表达式（中缀式）求波兰表达式和逆波兰表达式一共有两种求法，直接举例。求 y+(2-3*y+4)*((4+y)*2-y) 的波兰表达式和逆波兰表达式。 第一种方法——直接画出二叉树直接画出二叉树根据前序和后序遍历求得波兰表达式和逆波兰表达式。 波兰表达式： +y*+-2*3y4-*+4y2y逆波兰表达式： y23y*-4+4y+2*y-*+ 第二种方法——括号替换法求波兰表达式： 将中缀式的括号补全（保证一对括号里有且仅有一个直接的运算符）(y+(((2-(3*y))+4)*(((4+y)*2)-y))) 将这一对括号中的运算符把前括号( 替换，忽略后括号）。+y*+-2*3y4-*+4y2y 求逆波兰表达式： 将中缀式的括号补全（保证一对括号里有且仅有一个直接的运算符）(y+(((2-(3*y))+4)*(((4+y)*2)-y))) 将这一对括号中的运算符把后括号( 替换，忽略前括号）。y23y*-4+4y+2*y-*+","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://solodance.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"波兰表达式","slug":"波兰表达式","permalink":"https://solodance.top/tags/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"逆波兰表达式","slug":"逆波兰表达式","permalink":"https://solodance.top/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"二叉树","slug":"二叉树","permalink":"https://solodance.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"给出三角形三个点的坐标求三角形面积","date":"2020-01-23T13:42:34.982Z","path":"2020/01/23/给出三角形三个点的坐标求三角形面积/","text":"给出三角形三个点的坐标求三角形面积在平面解析几何会学到。设A(x1, y1)， B(x2, y2)， C(x3, y3)由A –&gt;B–&gt;C–&gt;A按逆时针方向转。（行列式书写要求）（其实 并不非要按照逆时针旋转， 最后求得时候取一个绝对值就行了 S = （1 / 2 ) * （行列式）|x1 y1 1||x2 y2 1||x3 y3 1| 即公式为 S = (1 / 2) * (x1 * y2 + x2 * y3 + x3 * y1 - x3 * y2 + x2 * y1 + x1 * y3)","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"给出三角形三点坐标求面积","slug":"给出三角形三点坐标求面积","permalink":"https://solodance.top/tags/%E7%BB%99%E5%87%BA%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%89%E7%82%B9%E5%9D%90%E6%A0%87%E6%B1%82%E9%9D%A2%E7%A7%AF/"},{"name":"数学知识","slug":"数学知识","permalink":"https://solodance.top/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}]},{"title":"给定两个区间， 判断有多少组数是给定数的倍数","date":"2020-01-23T13:42:34.982Z","path":"2020/01/23/给定两个区间， 判断有多少组数是给定数的倍数/","text":"例题： 2017（简单）题目链接 题目大意给4个数a, b, c, d， 问有多少对(x, y) a &lt;= x &lt;= b， c &lt;= y &lt;= d 并且x * y % 2017 == 0 。 分析因为2017是质数， 所以只需要 求 [a, b]中2017的个数 乘以 [c, d]中1的个数 加上 [c, d] 中2017 的个数 乘以 [a, b] 中1的个数， 减去 [a, b]中2017的个数 乘以 [c, d] 中2017 的个数(去重)。 AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;int main() &#123; ios::sync_with_stdio(false); ll a, b, c, d; ll ans; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d)&#123; ans = 0; a--, c--; ans += (b / 2017 - a / 2017) * (d - c); ans += (d / 2017 - c / 2017) * (b - a); ans -= (b / 2017 - a / 2017) * (d / 2017 - c / 2017); cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 例题： 2018（普通）题目链接 题目大意给4个数a, b, c, d， 问有多少对(x, y) a &lt;= x &lt;= b， c &lt;= y &lt;= d 并且x * y % 2018 == 0 。 分析由于2018只有四个因数， 也是简单了不少。所以 需要 求 [a, b]中2018的个数 乘以 [c, d]中1的个数 加上 [c, d] 中2018 的个数 乘以 [a, b] 中1的个数， 减去 [a, b]中2018的个数 乘以 [c, d] 中2018 的个数(去重)。求 [a, b]中1009的个数 乘以 [c, d]中2的个数 加上 [c, d] 中1009 的个数 乘以 [a, b] 中2的个数， 不需要去重， 因为不可能有重复的。 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const int mod = 998244353;ll _(ll x)&#123; x /= 1009; if (x &amp; 1) return x / 2 + 1; return x / 2;&#125;int main() &#123; ios::sync_with_stdio(false); ll a, b, c, d; ll ans; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d)&#123; ans = 0; a--, c--; ans += (b / 2018 - a / 2018) * (d - c); ans += (d / 2018 - c / 2018) * (b - a); ans += (_(b) - _(a)) * (d / 2 - c / 2 - d / 2018 + c / 2018); ans += (_(d) - _(c)) * (b / 2 - a / 2 - b / 2018 + a / 2018); ans -= (b / 2018 - a / 2018) * (d / 2018 - c / 2018); cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 例题： 2016（困难）题目链接 题目大意 给2个数n, m， 问有多少对(x, y) 1 &lt;= x &lt;= n， 1 &lt;= y &lt;= m 并且x * y % 2016 == 0 。 分析2016有36个因子， 再用这种方法就有点难受咯。讲讲比较正的解法。任何一个数a 都可以表示为 a = a / 2016 * 2016 + a % 2016 所以只要求 (x % 2016 * y % 2016) % 2016 == 0 对于(x, y ) 有多少对。具体看AC代码 AC代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;typedef long long ll;using namespace std;ll n, m;int num1[2020], num2[2020];int main() &#123; while (scanf(\"%lld%lld\", &amp;n, &amp;m) != EOF) &#123; // num1[i] n % 2016 == i 的个数 // num2[i] m % 2016 == i 的个数 for (int i = 0; i &lt;= 2015; i++) num1[i] = n / 2016, num2[i] = m / 2016; for (int i = 1; i &lt;= 2015; i++) &#123; if (i &lt;= n % 2016) num1[i]++; if (i &lt;= m % 2016) num2[i]++; &#125; ll ans = 0; for (int i = 0; i &lt;= 2015; i++) &#123; for (int j = 0; j &lt;= 2015; j++) &#123; if (i * j % 2016 == 0) &#123; ans += num1[i] * num2[j]; &#125; &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"总结","slug":"总结","permalink":"https://solodance.top/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"给结构体初始化和定义优先级","date":"2020-01-23T13:42:34.982Z","path":"2020/01/23/给结构体初始化和定义优先级/","text":"结构体初始化和定义优先级 12345678910111213141516171819struct node&#123; int to; ll cost; bool operator &lt;(const node&amp;another) const&#123; return cost + dis[to] &gt; another.cost + dis[another.to]; // &lt;\"为从大到小排列，\"&gt;\"为从小到大排列 &#125; bool operator &lt; (const node a, const node b)&#123; return n1.to &lt; n2.to; // &lt;\"为从大到小排列，\"&gt;\"为从小到大排列 &#125; node(int a,ll c):to(a),cost(c) &#123;&#125; //为了能让node() 这个行为合法 node()&#123; to=0; cost=INF; &#125;//结构体初始化 node(int a = 0, ll c = 0) : to(a), cost(c) &#123;&#125; //初始化 加 让node() 这个行为合法&#125;; 恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 –mingfuyan```","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小知识","slug":"小知识","permalink":"https://solodance.top/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"二分总结","date":"2020-01-23T13:42:34.951Z","path":"2020/01/23/二分总结/","text":"总结嘛， 直接上代码。二分有各种各样的理解， 总会有正确或者不正确， 自己摸索之路难又难。（当然我知道是我太菜， 还不努力）现在我不是很理解， 就直接上代码了， 等着以后理解了在补回来吧。 若有错误一定要指正。 理解（更新于2019年7月29日）顿悟了顿悟了， 真爽爽。 基于闭区间[low, high]。 while循环里的条件都是 while(low &lt; high)， 即当 low == high 时退出， 为什么满足这个条件一定是low == high ， 这个下面再说。 重点重点重点 自己心里要想清楚你要求得是什么， 然后根据你要求得来分析思路。举两个例子：1234567891011121314//在非递减数组中， 查找最小的比key值大的数的下标。 既然是最小的， 又是非递减数组， 那么正查找肯定是要从前向后查找， 看下面代码分析int binary_search(int a[], int low, int high, int key)&#123; int m; while(low &lt; high)&#123; m = low + (high - low) / 2; //这里是向下取整， 因为你是从前往后找 if (a[m] &lt;= key) low = m + 1; // 从前向后， 如果不满足条件的话，所以是改变的low else high = m; // 如果满足条件， high就不变 &#125; if (a[low] &gt; key) // 如果这个值满足条件 return low; return -1;&#125; 1234567891011121314//在非递增数组中， 查找最小的比key值大的数的下标。 既然是最小的， 是非递增数组， 那么正常查找肯定是从后往前查找int binary_search(int a[], int low, int high, int key)&#123; int m; while(low &lt; high)&#123; m = low + (high - low + 1) / 2; //向上取整， 因为是从后往前找呀 if (a[m] &gt; key) // 如果满足条件， low就不变 low = m; else high = m - 1; // 从后往前， 所以改变的是high &#125; if (a[low] &gt; key) return low; return -1;&#125; 现在解决上面那个遗留问题： 从上面两段代码可以看出， 每一次二分完跨度都是1， 所以不会出现从low &lt; high 直接编程low &gt; high 只能是low = high。看完上面两个例子， 应该就理解的差不多了吧， 要是不理解， 就自己动手， 动手的时候也好动动脑，嘿嘿， 加油吧骚年。下面是我以前死记硬背的， 就不删了吧， 留作纪念。 以下全都是基于非递减， 闭区间[low, high]. 查找key值， 若存在， 返回最左边的下标， 若不存在，返回负一。12345678910111213int binary_search_1(int a[], int low, int high, int key)&#123; // low high 为闭区间 int m; while(low &lt; high)&#123; // 闭区间[low, high] m = low + (high - low) / 2; // 向下取整 if (a[m] &lt; key) // 对于非递增区间， 只需把此处换成 &gt; low = m + 1; else high = m; &#125; if (a[low] == key) return low; return -1;&#125; 查找key值， 若存在， 返回最右边的下标， 若不存在，返回负一。12345678910111213int binary_search_2(int a[], int low, int high, int key)&#123; // low high 为闭区间 int m; while(low &lt; high)&#123; m = low + (high - low + 1) / 2; // 向上取整 if (a[m] &lt;= key) // 对于非递增区间， 只需把此处换成 &gt;= low = m; else high = m - 1; &#125; if (a[low] == key) return low; return -1;&#125; 查找最小的比key值大的数的下标， 若不存在， 返回负一。1234567891011121314// 相当于upper_bound()int binary_search_3(int a[], int low, int high, int key)&#123; // low high 为闭区间 int m; while(low &lt; high)&#123; m = low + (high - low) / 2; if (a[m] &lt;= key) low = m + 1; else high = m; &#125; if (a[high] &gt; key) return high; return -1;&#125; 查找最大的比key值小的数的下标， 若不存在， 返回负一。12345678910111213int binary_search_4(int a[], int low, int high, int key)&#123; // low high 为闭区间 int m; while(low &lt; high)&#123; m = low + (high - low + 1) / 2; if (a[m] &lt; key) low = m; else high = m - 1; &#125; if (a[low] &lt; key) return low; return -1;&#125; 查找最小的比key值大于等于的数的下标， 若不存在， 返回负一。1234567891011121314// 相当于lower_bound()int binary_search_5(int a[], int low, int high, int key)&#123; // low high 为闭区间 int m; while(low &lt; high)&#123; m = low + (high - low) / 2; if (a[m] &lt; key) low = m + 1; else high = m; &#125; if (a[high] &gt;= key) return high; return -1;&#125; 查找最大的比key值小于等于的数的下标， 若不存在， 返回负一。12345678910111213int binary_search_6(int a[], int low, int high, int key)&#123; // low high 为闭区间 int m; while(low &lt; high)&#123; m = low + (high - low + 1) / 2; if (a[m] &lt;= key) low = m; else high = m - 1; &#125; if (a[low] &lt;= key) return low; return -1;&#125; 注关于非递增的数组， 具体的二分我还不知， 暂且先翻转， 然后用非递减的数组来做。 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"总结","slug":"总结","permalink":"https://solodance.top/tags/%E6%80%BB%E7%BB%93/"},{"name":"二分","slug":"二分","permalink":"https://solodance.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"导弹拦截（最长非上升子序列和最长上升子序列）","date":"2020-01-23T13:42:34.936Z","path":"2020/01/23/导弹拦截（最长非上升子序列和最长上升子序列）/","text":"题目描述题目链接某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是 \\le 50000≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式11行，若干个整数（个数 \\le 100000≤100000） 输出格式22行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例输入 1389 207 155 300 299 170 158 65 输出 1262 题解第一个要输出的显而易见是最长非上升子序列， 但是第二问就有意思了， 是求最长上升子序列。 ac代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;int a[N];int dp1[N], dp2[N], len1, len2;int main()&#123; int n = 1; char c; while(cin &gt;&gt; a[n])&#123; c = getchar(); if (c != ' ') break; n++; &#125; len1 = len2 = 1; dp1[1] = dp2[1] = a[1]; for (int i = 2; i &lt;= n; i++)&#123; if (a[i] &lt;= dp1[len1]) dp1[++len1] = a[i]; else *upper_bound(dp1 + 1, dp1 + len1 + 1, a[i], greater&lt;int&gt;()) = a[i]; if (a[i] &gt; dp2[len2]) dp2[++len2] = a[i]; else *lower_bound(dp2 + 1, dp2 + len2 + 1, a[i]) = a[i]; &#125; printf(\"%d\\n%d\\n\", len1, len2); return 0;&#125; 具体关于lis的总结： 请戳此 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"lis","slug":"lis","permalink":"https://solodance.top/tags/lis/"},{"name":"题解","slug":"题解","permalink":"https://solodance.top/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"动态规划总结","date":"2020-01-23T13:42:34.936Z","path":"2020/01/23/动态规划总结/","text":"唔， 学了两个星期的动规， 感觉入了一点点门了吧， 当时学的时候没有系统的整理， 现在回过头来整理可能又要花两三天（毕竟50多到题呢）， 趁着lintcode vip还没到期抓紧整理一下。长途路漫长， 要学的还有很多呀。加油吧骚年。有些动规可以用记忆化搜索来做， 或者可以用滚动数组 [toc] 例题669. Coin Change题目链接 题目大意：给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1. 分析： 状态变量：f[i] 表示组成i的最小方案的个数 最后一步： f[s] = f[s - a[j]] + 1 转移方程： f[i] = min(f[i], f[i - a[j]]) 初始化和边界情况： f[0] = 0, i &gt;= a[j] 计算顺序： 从前往后， 一般的动规都是这样算的 AC代码： 123456789101112131415161718192021class Solution &#123;public: const int INF = 0x3f3f3f3f; int coinChange(vector&lt;int&gt; &amp;a, int s) &#123; int n = a.size(); if (n == 0) return -1; int f[s + 1]; f[0] = 0; for (int i = 1; i &lt;= s; i++)&#123; f[i] = INF; for (int j = 0; j &lt; n; j++)&#123; if (i &gt;= a[j]) f[i] = min(f[i], f[i - a[j]] + 1); &#125; &#125; if (f[s] != INF) return f[s]; return -1; &#125;&#125;; 114. Unique Paths题目链接 题目大意 有一个机器人的位于一个 m × n 个网格左上角。 机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。 问有多少条不同的路径？ n和m均不超过100 AC代码 123456789101112131415161718class Solution &#123;public: int uniquePaths(int m, int n) &#123; int f[m][n]; for (int i = 0; i &lt; m; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (i == 0 || j == 0)&#123; //把初始化放在里面也挺常用的哦 f[i][j] = 1; continue; &#125; f[i][j] = f[i - 1][j] + f[i][j - 1]; &#125; &#125; return f[m - 1][n - 1]; &#125;&#125;; 116. Jump Game题目链接 题目大意给出一个非负整数数组，你最初定位在数组的第一个位置。 数组中的每个元素代表你在那个位置可以跳跃的最大长度。 判断你是否能到达数组的最后一个位置。 AC代码（DP） 123456789101112131415161718192021222324class Solution &#123;public: /** * @param A: A list of integers * @return: A boolean */ bool canJump(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (n == 1) return true; bool f[n]; f[0] = 1; for (int i = 1; i &lt; n; i++)&#123; f[i] = false; for (int j = i - 1; j &gt;= 0; j--)&#123; if ((j + a[j] &gt;= i) &amp;&amp; f[j])&#123; f[i] = true; break; &#125; &#125; &#125; return f[n - 1]; &#125;&#125;; AC代码（贪心） 12345678910111213141516171819class Solution &#123;public: bool canJump(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (n == 1) return true; int maxn = 0; for (int i = 0; i &lt; n; i++)&#123; if (i &gt; maxn) return false; else if (maxn &gt;= n - 1) return true; else maxn = max(maxn, i + a[i]); &#125; return true; &#125;&#125;; 115. Unique Paths II题目链接 题目描述现在考虑网格中有障碍物，那样将会有多少条不同的路径？ 网格中的障碍和空位置分别用 1 和 0 来表示。 m 和 n 均不超过100 分析一样想就行啦 AC代码 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: /** * @param obstacleGrid: A list of lists of integers * @return: An integer */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt; &amp;a) &#123; // write your code here int m = a.size(); int n = a[0].size(); int f[101][101]; f[0][0] = !a[0][0]; for (int i = 1; i &lt; m; i++)&#123; if (!a[i][0]) f[i][0] = f[i - 1][0]; else f[i][0] = 0; &#125; for (int i = 1; i &lt; n; i++)&#123; if (!a[0][i]) f[0][i] = f[0][i - 1]; else f[0][i] = 0; &#125; for (int i = 1; i &lt; m; i++)&#123; for (int j = 1; j &lt; n; j++)&#123; if (!a[i][j]) f[i][j] = f[i - 1][j] + f[i][j - 1]; else f[i][j] = 0; &#125; &#125; return f[m - 1][n - 1]; &#125; &#125;; 515. Paint House题目链接 题目描述这里有n个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小，返回最小的费用。 费用通过一个nx3 的矩阵给出，比如cost[0][0]表示房屋0染红色的费用，cost[1][2]表示房屋1染绿色的费用。 分析 状态变量 f[i][j] 代表前i个屋子（即0 ~ i - 1）当第i - 1个屋子染成j颜色时的最小话费 转移方程 f[i][j] = min(f[i][j], f[i - 1][k] + a[i - 1][j]) | k != j 初始化和边界条件 前0栋房子花费为0 f[0][j] = 0 计算顺序 从前向后 AC代码 12345678910111213141516171819202122class Solution &#123;public: int minCost(vector&lt;vector&lt;int&gt;&gt; &amp;a) &#123; // write your code here int n = a.size(); const int INF = 0x3f3f3f3f; int f[n + 1][3]; memset(f[0], 0, sizeof f[0]); for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= 2; j++)&#123; f[i][j] = INF; for (int k = 0; k &lt;= 2; k++)&#123; if (k == j) continue; f[i][j] = min(f[i][j], f[i - 1][k] + a[i - 1][j]); &#125; &#125; &#125; return min(min(f[n][0], f[n][1]), f[n][2]); &#125;&#125;; 512. Decode Ways题目链接 题目描述有一个消息包含A-Z通过以下规则编码 ‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26现在给你一个加密过后的消息，问有几种解码的方式 分析只分析一下最后一步吧， 最后一步要不就是f[n] += f[n - 1] 要不就是 f[n] += f[n - 2] | 最后两位是大于9小于27 AC代码 1234567891011121314151617181920212223242526class Solution &#123;public: /** * @param s: a string, encoded message * @return: an integer, the number of ways decoding */ int numDecodings(string &amp;s) &#123; // write your code here int l = s.length(); if (l == 0) return 0; int f[l + 1]; memset(f, 0, sizeof f); f[0] = 1; for (int i = 1; i &lt;= l; i++)&#123; if (s[i - 1] != '0') f[i] += f[i - 1]; if (i &gt;= 2)&#123; int t = (s[i - 2] - '0')* 10 + s[i - 1] - '0'; if (t &gt;= 10 &amp;&amp; t &lt;= 26) f[i] += f[i - 2]; &#125; &#125; return f[l]; &#125; &#125;; 110. Minimum Path Sum题目链接 题目描述给定一个只含非负整数的mn网格，找到一条从左上角到右下角的可以使数字和最小的路径。你在同一时间只能向下或者向右移动一步*分析**和机器人走到右下角是一样的。 AC代码 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param grid: a list of lists of integers * @return: An integer, minimizes the sum of all numbers along its path */ int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;a) &#123; // write your code here int m = a.size(); int n = a[0].size(); int f[m][n]; for (int i = 0; i &lt; m; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (i == 0 &amp;&amp; j == 0)&#123; f[i][j] = a[0][0]; continue; &#125; if (i == 0)&#123; f[i][j] = a[i][j] + f[i][j - 1]; continue; &#125; if (j == 0)&#123; f[i][j] = a[i][j] + f[i - 1][j]; continue; &#125; f[i][j] = min(f[i - 1][j], f[i][j - 1]) + a[i][j]; &#125; &#125; return f[m - 1][n - 1]; &#125;&#125;; 553. Bomb Enemy题目链接 题目描述给定一个二维矩阵, 每一个格子可能是一堵墙 W,或者 一个敌人 E 或者空 0 (数字 ‘0’), 返回你可以用一个炸弹杀死的最大敌人数. 炸弹会杀死所有在同一行和同一列没有墙阻隔的敌人。 由于墙比较坚固，所以墙不会被摧毁. 你只能在空的地方放置炸弹.分析 这题需要好好的分析一下， 对于任意一个位置， 我们可以认为他的状态f[i][j] 是由上下左右转移而来的。先分析上转移方程： 123456789101112131415if (i == 0)&#123; if (a[i][j] == 'E') f[i][j] = 1;else f[i][j] = 0; res[i][j] += f[i][j];//记录4个方向的和。 continue;&#125;if (a[i][j] == 'E') f[i][j] = f[i - 1][j] + 1;else if (a[i][j] == '0') f[i][j] = f[i - 1][j];else f[i][j] = 0; res[i][j] += f[i][j]; 然后下， 左右， 就一样了 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class Solution &#123;public: int maxKilledEnemies(vector &lt;vector&lt;char&gt;&gt; &amp;a) &#123; int m = a.size(); if (m == 0) return 0; int n = a[0].size(); int res[m][n], f[m][n]; memset(res, 0, sizeof res); // up for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0) &#123; if (a[i][j] == 'E') f[i][j] = 1; else f[i][j] = 0; res[i][j] += f[i][j]; continue; &#125; if (a[i][j] == 'E') f[i][j] = f[i - 1][j] + 1; else if (a[i][j] == '0') f[i][j] = f[i - 1][j]; else f[i][j] = 0; res[i][j] += f[i][j]; &#125; &#125; // down for (int i = m - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == m - 1) &#123; if (a[i][j] == 'E') f[i][j] = 1; else f[i][j] = 0; res[i][j] += f[i][j]; continue; &#125; if (a[i][j] == 'E') f[i][j] = f[i + 1][j] + 1; else if (a[i][j] == '0') f[i][j] = f[i + 1][j]; else f[i][j] = 0; res[i][j] += f[i][j]; &#125; &#125; //left for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j == 0) &#123; if (a[i][j] == 'E') f[i][j] = 1; else f[i][j] = 0; res[i][j] += f[i][j]; continue; &#125; if (a[i][j] == 'E') f[i][j] = f[i][j - 1] + 1; else if (a[i][j] == '0') f[i][j] = f[i][j - 1]; else f[i][j] = 0; res[i][j] += f[i][j]; &#125; &#125; //right for (int i = 0; i &lt; m; i++) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; if (j == n - 1) &#123; if (a[i][j] == 'E') f[i][j] = 1; else f[i][j] = 0; res[i][j] += f[i][j]; continue; &#125; if (a[i][j] == 'E') f[i][j] = f[i][j + 1] + 1; else if (a[i][j] == '0') f[i][j] = f[i][j + 1]; else f[i][j] = 0; res[i][j] += f[i][j]; &#125; &#125; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (a[i][j] == '0') ans = max(ans, res[i][j]); &#125; &#125; return ans; &#125;&#125;; 664. Counting Bits题目链接题目描述给出一个 非负 整数 num，对所有满足 0 ≤ i ≤ num 条件的数字 i 均需要计算其二进制表示中数字 1 的个数并以数组的形式返回。 分析二进制嘛， 肯定要想到2 。i与i / 2 的差别就是i比i / 2 多了一位二进制转移方程就是 f[i] = f[i / 2] | i &amp; 1 == 0; f[i] = f[i / 2] + 1 | i &amp; 1 == 1 AC代码 123456789101112131415161718class Solution &#123;public: /** * @param num: a non negative integer number * @return: an array represent the number of 1's in their binary */ vector&lt;int&gt; countBits(int a) &#123; // write your code here vector&lt;int&gt; f(a + 1, 0); for (int i = 0; i &lt;= a; i++)&#123; if (i &amp; 1) f[i] = f[i / 2] + 1; else f[i] = f[i / 2]; &#125; return f; &#125;&#125;; 516. Paint House II题目链接 题目描述这里有n个房子在一列直线上，现在我们需要给房屋染色，共有k种颜色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小。 费用通过一个nxk 的矩阵给出，比如cost[0][0]表示房屋0染颜色0的费用，cost[1][2]表示房屋1染颜色2的费用。 所有费用都是正整数 分析和上面515. Paint House一样就是把3改成n，时间复杂度为m * n * n但是还有更快的做法：对于花费矩阵， 从第一行到第二行， 最优的情况是第二行加上第一行的最小的值， 当第一行最小的值得下标之外的第二行， 全都加上最小值， 等于第一行最小值的下标的加上次小值， 就OK了。 当然把这个思路运用到动规里也是可以的， 找出上一行的最小值次小值， 然后就不用遍历了。 AC代码（动规） 12345678910111213141516171819202122232425262728293031class Solution &#123;public: /** * @param costs: n x k cost matrix * @return: an integer, the minimum cost to paint all houses */ int minCostII(vector&lt;vector&lt;int&gt;&gt; &amp;a) &#123; int m = a.size(); if (m == 0) return 0; int n = a[0].size(); int f[m + 1][n]; memset(f[0], 0, sizeof f[0]); const int INF = 0x3f3f3f3f; for (int i = 1; i &lt;= m; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; f[i][j] = INF; for (int k = 0; k &lt; n; k++)&#123; if (k == j) continue; f[i][j] = min(f[i][j], f[i - 1][k] + a[i - 1][j]); &#125; &#125; &#125; int ans = INF; for (int i = 0; i &lt; n; i++) ans = min(ans, f[m][i]); return ans; &#125;&#125;; AC代码（另一种思路） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: &#x2F;** * @param costs: n x k cost matrix * @return: an integer, the minimum cost to paint all houses *&#x2F; int minCostII(vector&lt;vector&lt;int&gt;&gt; &amp;a) &#123; int m &#x3D; a.size(); if (!m) return 0; int n &#x3D; a[0].size(); int min1 &#x3D; INT_MAX, min2 &#x3D; INT_MAX, indx; for (int i &#x3D; 0; i &lt; n; i++)&#123; if (min1 &gt; a[0][i])&#123; min2 &#x3D; min1; min1 &#x3D; a[0][i]; indx &#x3D; i; &#125; else if (min2 &gt; a[0][i])&#123; min2 &#x3D; a[0][i]; &#125; &#125; for (int i &#x3D; 1; i &lt; m; i++)&#123; for (int j &#x3D; 0; j &lt; n; j++)&#123; if (j !&#x3D; indx) a[i][j] +&#x3D; min1; else a[i][j] +&#x3D; min2; &#125; min1 &#x3D; min2 &#x3D; INT_MAX; for (int j &#x3D; 0; j &lt; n; j++)&#123; if (min1 &gt; a[i][j])&#123; min2 &#x3D; min1; min1 &#x3D; a[i][j]; indx &#x3D; j; &#125; else if (min2 &gt; a[i][j])&#123; min2 &#x3D; a[i][j]; &#125; &#125; &#125; return min1; &#125;&#125;; AC代码（优化后的动规） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: /** * @param costs: n x k cost matrix * @return: an integer, the minimum cost to paint all houses */ int minCostII(vector&lt;vector&lt;int&gt;&gt; &amp;cost) &#123; // write your code here if (cost.empty() || cost.size() == 0 || cost[0].size() == 0) return 0; int n = cost.size(); int m = cost[0].size(); int f[n + 1][m]; const int INF = 0x3f3f3f3f; memset(f, INF, sizeof f); memset(f[0], 0, sizeof f[0]); int min1, min2; int j1, j2; for (int i = 1; i &lt;= n; i++)&#123; min1 = min2 = INF; for (int j = 0; j &lt; m; j++)&#123; if (f[i - 1][j] &lt; min1)&#123; min2 = min1; j2 = j1; min1 = f[i - 1][j]; j1 = j; &#125; else if (f[i - 1][j] &lt; min2)&#123; min2 = f[i - 1][j]; j2 = j; &#125; &#125; for (int j = 0; j &lt; m; j++)&#123; if (j != j1) f[i][j] = min1 + cost[i - 1][j]; else f[i][j] = min2 + cost[i - 1][j]; &#125; &#125; int ans = INF; for (int i = 0; i &lt; m; i++) ans = min(ans, f[n][i]); return ans; &#125;&#125;; 392. House Robber题目链接 题目描述假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。 给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，在不触动报警装置的情况下, 你最多可以得到多少钱 。 分析因为存在约束， 偷与不偷， 那就把此约束放在状态里， 设0为不偷， 1为偷。转移方程 12f[i][0] = max(f[i - 1][0], f[i - 1][1]);f[i][1] = f[i - 1][0] + a[i - 1]; 但是观察此状态方程， 我们可以化简。 12345becausef[i - 1][0] = max(f[i - 2][0], f[i - 2][1]);sof[i][0] = max(f[i - 1][0], f[i - 1][1]);f[i][1] = max(f[i - 2][0], f[i - 2][1]) + a[i - 1]; 所以我们完全可以设成一维f[i] 表示在前i个房子中最多能偷多少钱 AC代码 1234567891011121314151617181920212223class Solution &#123;public: /** * @param A: An array of non-negative integers * @return: The maximum amount of money you can rob tonight */ long long houseRobber(vector&lt;int&gt; &amp;a) &#123; // write your code here typedef long long ll; int n = a.size(); if (n == 0) return 0; ll f[n + 1]; f[0] = 0; for (int i = 1; i &lt;= n; i++)&#123; if (i == 1) f[i] = a[i - 1]; if (i &gt; 1) f[i] = max(f[i - 1], f[i - 2] + a[i - 1]); &#125; return f[n]; &#125;&#125;; 534. House Robber II题目链接 题目描述在上次打劫完一条街道之后，窃贼又发现了一个新的可以打劫的地方，但这次所有的房子围成了一个圈，这就意味着第一间房子和最后一间房子是挨着的。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。 给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，在不触动报警装置的情况下, 你最多可以得到多少钱 。 这题是House Robber的扩展，只不过是由直线变成了圈 分析环形dp就是转化成非环形的呗。对于这一题而言， 最后一个和第一个不可能一起选， 那就拆成 1 ~ n - 1 和 0 ~ n - 2 。分别dp（写个函数就行）。 AC代码 12345678910111213141516171819202122232425262728class Solution &#123;public: /** * @param nums: An array of non-negative integers. * @return: The maximum amount of money you can rob tonight */ int solve(int st, int en, vector&lt;int&gt; &amp;a)&#123; int f[en + 1]; f[st] = 0; f[st + 1] = a[st]; for (int i = st + 2; i &lt;= en; i++)&#123; f[i] = max(f[i - 1], f[i - 2] + a[i - 1]); &#125; return f[en]; &#125; int houseRobber2(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (n == 0) return 0; if (n == 1) return a[0]; return max(solve(0, n - 1, a), solve(1, n, a)); &#125;&#125;; 149. Best Time to Buy and Sell Stock题目链接 题目描述假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交易(例如,一次买卖股票),设计一个算法来找出最大利润。 分析 其实这一题也算不上dp， 之所以做着题因为他是铺垫， 有两个方法 维护前i个元素的最小值 贪心 AC代码（维护区间最小值） 1234567891011121314151617181920212223242526class Solution &#123;public: /** * @param prices: Given an integer array * @return: Maximum profit */ int maxProfit(vector&lt;int&gt; &amp;a) &#123; // write your code here if (a.empty() || !a.size()) return 0; int n = a.size(); int f[n + 1]; f[0] = a[0]; for (int i = 1; i &lt; n; i++)&#123; if (a[i] &lt; f[i - 1]) f[i] = a[i]; else f[i] = f[i - 1]; &#125; int m = 0; for (int i = n - 1; i &gt;= 1; i--)&#123; m = max(m, a[i] - f[i - 1]); &#125; return m; &#125;&#125;; AC代码（贪心） 123456789101112131415161718class Solution &#123;public: /** * @param prices: Given an integer array * @return: Maximum profit */ int maxProfit(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if(n == 0 || n == 1) return 0; int ans = 0, min1 = a[0]; for (int i = 1; i &lt; n; i++)&#123; ans = max(ans, a[i] - min1); min1 = min(min1, a[i]); &#125; return ans; &#125;&#125;; 150. Best Time to Buy and Sell Stock II题目链接 题目描述给定一个数组 prices 表示一支股票每天的价格. 你可以完成任意次数的交易, 不过你不能同时参与多个交易 (也就是说, 如果你已经持有这支股票, 在再次购买之前, 你必须先卖掉它). 设计一个算法求出最大的利润. 分析这算是个思维题吧， 就是只要今天的股票比昨天的股票值钱， 就买卖。 AC代码 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;a) &#123; int ans = 0; for (int i = 1; i &lt; a.size(); i++)&#123; if (a[i] - a[i - 1] &gt; 0) ans += a[i] - a[i - 1]; &#125; return ans; &#125;&#125;; 151. Best Time to Buy and Sell Stock III题目链接 题目描述假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成两笔交易。 你不可以同时参与多笔交易(你必须在再次购买前出售掉之前的股票) 分析最难的不是只买一次或者说买无数次， 而是能买特定的次数。 我们同时将两次拓展到k次， 先看两次。 我们有五种状态， 分别是 1.第一次股票未买， 2.买第一支股票， 3.卖第一支股票（此时手中无股票）， 4.买第二支股票， 5.卖第二支股票（此时手中无股票） 状态转移： 状态一只能由状态一转换 （不盈利） 状态二可以由状态一或者状态二转换 （由状态二转换需要盈利， 由状态一转换不需要盈利） 状态三能够由状态二转换或者状态三转换 （若是由状态二转换能够盈利） 状态四能够由状态二（卖了手中的那支股票然后当天在买一只股票）， 状态三或者状态四转换（这个比较特殊， 若是由状态二转换， 则不盈利， 若是由状态二或者状态四转换， 都要盈利） 状态五可以由状态四或者状态五转换 （若是由状态四转换能够盈利） 有人或许会对第2， 4条中的由状态二转化为状态二 和 状态四化为状态四 会盈利感到不解， 其实这个盈利是“假盈利”， 这是一条链的关系。 怎么理解呢， 正常的盈利是卖的股票那一天减买的股票那一天， 但是在dp中很难储存你是在那一天买的股票（我这种弱鸡想不到， 不过应该会有大佬想到qaq）， 所以我们采取了这样一条链的方法， 我们举个简单的例子。 1234567891011假如我们第一天就买了一直股票， 就处于阶段二了， 然后我们到第n天才卖出股票， 肉眼观察盈利是 a[n] - a[1]中间一直处于阶段二， 就是一直处于盈利状态， 第一天盈利 f[1] = 0第二天盈利 f[2] = a[2] - a[1] + f[1]第三天盈利 f[3] = f[2] + a[3] - a[2]...第n天盈利 f[n] = f[n - 1] + a[n] - a[n - 1]我们累加一下就得到f[n] = a[n] - a[1]这就是巧妙之处 AC代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: const int INF = 0x3f3f3f3f; int maxProfit(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (n == 0) return 0; int f[n + 1][6]; memset(f[0], -INF, sizeof f[0]); f[0][1] = 0; //除了f[0][1] 意外其他f[0]都是没有意义的 for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= 5; j += 2)&#123; //对于现阶段处于1， 3， 5 f[i][j] = f[i - 1][j]; if (i &gt;= 2 &amp;&amp; j &gt; 1 &amp;&amp; f[i - 1][j - 1] != -INF)&#123; f[i][j] = max(f[i][j], f[i - 1][j - 1] + a[i - 1] - a[i - 2]); &#125; &#125; for (int j = 2; j &lt;= 5; j += 2)&#123;//对于现阶段处于2， 4 f[i][j] = f[i - 1][j - 1]; if (i &gt;= 2 &amp;&amp; f[i - 1][j] != -INF)&#123; f[i][j] = max(f[i][j], f[i - 1][j] + a[i - 1] - a[i - 2]); &#125; if (i &gt;= 2 &amp;&amp; j &gt;= 3 &amp;&amp; f[i - 1][j - 2] != -INF)&#123; f[i][j] = max(f[i][j], f[i - 1][j - 2] + a[i - 1] - a[i - 2]); &#125; &#125; &#125; return max(f[n][1], max(f[n][3], f[n][5])); //最后结果一定是从1， 3， 5中取最大值 &#125;&#125;; 393. Best Time to Buy and Sell Stock IV题目链接 题目大意给定数组 prices, 其中第 i 个元素代表某只股票在第 i 天第价格. 你最多可以完成 k 笔交易. 问最大的利润是多少? 你不可以同时参与多(k)笔交易(你必须在再次购买前出售掉之前的股票) 分析就是上一题的升级版， 把代码中的5改成 2 * k + 1 即可当然你若仔细想一下， 当k &gt;= n / 2 时可以改成任意次。这里稍微证明下， 显而易见， 当 k &gt; n时是可以当成任意次来做的。首先， 我们先思考当股票价格一直上升时， 最优策略就是第一天买最后一天卖，所以只需要一次即可。当股票价格一直下降时， 一次也不买卖就是0。所以我们可以把连续上升的部分只需要一次买， 连续下降的部分0次买所以用的次数最多的情况就是升降升降， 也就是n / 2 次。 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: const int INF = 0x3f3f3f3f; int maxProfit(int k, vector&lt;int&gt; &amp;a) &#123; // write your code here if (!k || a.empty() || !a.size()) return 0; int n = a.size(); if (k &gt;= n / 2)&#123; int ans = 0; for (int i = 1; i &lt; n; i++)&#123; if (a[i] - a[i - 1] &gt; 0) ans += a[i] - a[i - 1]; &#125; return ans; &#125; int f[n + 1][2 * k + 1 + 1]; memset(f[0], -INF, sizeof f[0]); f[0][1] = 0; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= 2 * k + 1; j += 2)&#123; f[i][j] = f[i - 1][j]; if (i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; f[i - 1][j - 1] != -INF) f[i][j] = max(f[i][j], f[i - 1][j - 1] + a[i - 1] - a[i - 2]); &#125; for (int j = 2; j &lt;= 2 * k + 1; j += 2)&#123; f[i][j] = f[i - 1][j - 1]; if (i &gt; 1 &amp;&amp; f[i - 1][j] != -INF) f[i][j] = max(f[i][j], f[i - 1][j] + a[i -1] - a[i - 2]); if (i &gt; 2 &amp;&amp; j &gt; 2 &amp;&amp; f[i - 1][j - 2] != -INF) f[i][j] = max(f[i][j], f[i - 1][j - 2] + a[i -1] - a[i - 2]); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= 2 * k + 1; i += 2) ans = max(ans, f[n][i]); return ans; &#125;&#125;; 76. Longest Increasing Subsequence题目链接 题目大意给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。 分析就是lis详情可看此博客：传送门 n方， nlogn， 打印路径全都有 AC代码（n方解法） 12345678910111213141516171819202122232425class Solution &#123;public: int longestIncreasingSubsequence(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (n == 0) return 0; // f[i] 代表以a[i] 为结尾的lis的长度 int f[n + 1]; f[0] = 1; for (int i = 1; i &lt; n; i++)&#123; f[i] = 1; for (int j = 0; j &lt; i; j++)&#123; if (a[j] &lt; a[i])&#123; f[i] = max(f[i], f[j] + 1); &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) ans = max(ans, f[i]); return ans; &#125; &#125;; AC代码nlogn解法 1234567891011121314151617181920212223242526class Solution &#123;public: int longestIncreasingSubsequence(vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (n == 0) return 0; // f[i] 代表的是 长度为i 的lis的最优解得最后一个数 int f[n + 1]; f[0] = 0; f[1] = a[0]; int len = 1; for (int i = 1; i &lt; n; i++)&#123; if (a[i] &gt; f[len]) f[++len] = a[i]; else&#123; int cnt = lower_bound(f + 1, f + len + 1, a[i]) - f; f[cnt] = a[i]; &#125; &#125; return len; &#125; &#125;; 602. Russian Doll Envelopes题目链接 题目大意给一定数量的信封，带有整数对 (w, h) 分别代表信封宽度和高度。一个信封的宽高均大于另一个信封时可以放下另一个信封。求最大的信封嵌套层数。 分析俄罗斯套娃问题 二维的简单些 首先先将w 或者 h从小到大排序， 然后让另一个变量从大到小（当前面的变量相同时），这样对排序后的第二个变量求一下其lis就行了， 为啥要第二个变量从大到小呢， 因为要保证求lis时只选一个第一个变量相同的变量 那我们思考一下三维甚至多维的该怎么办呢？（我也是这才有的想法）我的一个想法是先按照二维的做法， 用lis打印路径， 保存起来， 这就相当于去了两维， 重复去就行啦。然后我们在百度看一看怎么做 AC代码 1234567891011121314151617181920212223242526272829class Solution &#123;public: typedef pair&lt;int, int&gt; P; static bool cmp(P a, P b)&#123; if (a.first != b.first) return a.first &lt; b.first; return a.second &gt; b.second; &#125; int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; a) &#123; int n = a.size(); if (n == 0 || n == 1) return n; int f[n + 1]; sort(a.begin(), a.end(), cmp); f[1] = a[0].second; int len = 1; for (int i = 1; i &lt; n; i++)&#123; if (a[i].second &gt; f[len]) f[++len] = a[i].second; else *lower_bound(f + 1, f + len + 1, a[i].second) = a[i].second; &#125; return len; &#125;&#125;; 513. Perfect Squares题目大意题目链接给一个正整数 n, 请问最少多少个完全平方数(比如1, 4, 9…)的和等于n。 分析很容易就分析出来 转移方程了。直接看代码吧。当然这题可以打表找规律优化到O(n) 。AC代码 123456789101112131415161718class Solution &#123;public: /** * @param n: a positive integer * @return: An integer */ int numSquares(int n) &#123; int f[n + 1]; f[0] = 0; for (int i = 1; i &lt;= n; i++)&#123; f[i] = INT_MAX; for (int j = 1; j * j &lt;= i; j++)&#123; f[i] = min(f[i], f[i - j * j] + 1); &#125; &#125; return f[n]; &#125;&#125;; 108. Palindrome Partitioning II题目大意timulianjie给定字符串 s, 需要将它分割成一些子串, 使得每个子串都是回文串. 最少需要分割几次? 分析题目中就是求能把s分成最少几个回文子串。考虑最后一步， s[i … n - 1] 一定是一个回文子串那就ok了设f[i] 为前i个字符最少分成多少个回文子串f[i] = min(f[i], f[j] + 1 | s[j...i - 1] 为回文子串) 现在问题又来了， 如何判断 s[j… i - 1]是不是回文子串， 那就要预处理了。回文串的长度只有两种情况， 奇数和偶数， 我们预预处理， 生成一下回文子串即可， 详情看代码及注释 AC代码 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: /** * @param s: A string * @return: An integer */ int minCut(string &amp;s) &#123; if (s == \"\") return 0; int n = s.length(); bool is[n][n]; // 表示 is[i][j] 表示 s[i..j] 是不是为回文子串 memset(is, false, sizeof is); int i, j; for (int k = 0; k &lt; n; k++)&#123; // 回文串长度为奇数的情况 i = j = k; while(i &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) is[i][j] = true, i--, j++; // 回文串长度为偶数的情况 i = j = k; j++; while(i &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) is[i][j] = true, i--, j++; &#125; int f[n + 1]; f[0] = 0; for (int i = 1; i &lt;= n; i++)&#123; f[i] = INT_MAX; for (int j = 0; j &lt; i; j++)&#123; if (is[j][i - 1]) f[i] = min(f[i], f[j] + 1); &#125; &#125; // 最后减一是因为题目中问的是最少切几刀， f[n] 表示的是最少切成多少个回文子串 return f[n] - 1; &#125;&#125;; 437. Copy Books题目大意题目链接给定 n 本书, 第 i 本书的页数为 pages[i]. 现在有 k 个人来复印这些书籍, 而每个人只能复印编号连续的一段的书, 比如一个人可以复印 pages[0], pages[1], pages[2], 但是不可以只复印 pages[0], pages[2], pages[3] 而不复印 pages[1]. 所有人复印的速度是一样的, 复印一页需要花费一分钟, 并且所有人同时开始复印. 怎样分配这 k 个人的任务, 使得这 n 本书能够被尽快复印完? 返回完成复印任务最少需要的分钟数. 分析 dp做法： 设 f[k][i] 为 k个人复印前i本书所需要的最短时间。 二分做法： 二分最大值与和， 找出满足条件的数。 AC代码（DP） 12345678910111213141516171819202122232425262728293031class Solution &#123;public: /** * @param pages: an array of integers * @param k: An integer * @return: an integer */ int copyBooks(vector&lt;int&gt; &amp;a, int K) &#123; if(a.size() == 0) return 0; int n = a.size(); int f[K + 1][n + 1]; f[1][0] = 0; for (int i = 1; i &lt;= n; i++) f[1][i] = f[1][i - 1] + a[i - 1]; for (int k = 2; k &lt;= K; k++)&#123; for (int i = 1; i &lt;= n; i++)&#123; f[k][i] = INT_MAX; for (int j = 1; j &lt;= i; j++)&#123; f[k][i] = min(f[k][i], max(f[k - 1][j], f[1][i] - f[1][j])); &#125; &#125; &#125; return f[K][n]; &#125;&#125;; AC代码（二分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: /** * @param pages: an array of integers * @param k: An integer * @return: an integer */ bool check(int n, int m, vector&lt;int&gt; a, int k)&#123; int res = 1, sum = 0; for (int i = 0; i &lt; n; i++)&#123; if (sum + a[i] &lt;= m) sum += a[i]; else sum = a[i], res++; &#125; return res &lt;= k; &#125; int copyBooks(vector&lt;int&gt; &amp;a, int K) &#123; if(a.size() == 0) return 0; int n = a.size(); int ans = 0, sum = 0; for (int i = 0; i &lt; n; i++)&#123; sum += a[i]; ans = max(ans, a[i]); &#125; int low = ans, high = sum; int m; while(low &lt; high)&#123; m = low + (high - low) / 2; if (check(n, m, a, K)) high = m; else low = m + 1; &#125; return low; &#125;&#125;; 394. Coins in a Line题目大意题目链接有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。 请判定 先手玩家 必胜还是必败? 分析 AC代码 12345678910111213141516171819202122class Solution &#123;public: /** * @param n: An integer * @return: A boolean which equals to true if the first player will win */ bool firstWillWin(int n) &#123; if(n == 0) return false; int f[n + 1]; f[0] = false; f[1] = f[2] = true; for (int i = 3; i &lt;= n; i++)&#123; if (f[i - 1] &amp;&amp; f[i - 2]) f[i] = false; else f[i] = true; &#125; return f[n]; &#125;&#125;; 找到规律后更简单的写法 12345678910111213 class Solution &#123;public: /** * @param n: An integer * @return: A boolean which equals to true if the first player will win */ bool firstWillWin(int n) &#123; // write your code here if (n % 3 != 0) return true; return false; &#125;&#125;; 92. Backpack题目大意题目链接在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]（每个物品只能选一件） 分析背包， 设f[i][j] 为前i件物品， 能不能装满j AC代码 12345678910111213141516171819202122232425262728class Solution &#123;public: /** * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @return: The maximum size */ int backPack(int m, vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (!n || !m) return 0; int f[n + 1][m + 1]; memset(f, false, sizeof f); f[0][0] = true; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= m; j++)&#123; f[i][j] = f[i - 1][j]; if (j &gt;= a[i - 1]) // j 能不能由 a[i - 1] 和 j - a[i - 1] 组成 f[i][j] = f[i][j] | f[i - 1][j - a[i - 1]]; &#125; &#125; for (int i = m; i &gt;= 0; i--) if (f[n][i]) return i; &#125;&#125;; 由上面转移方程可知f[i][j] 是由 f[i - 1][j] 和 f[i - 1][j - a[i - 1]转移所以用一维即可 AC代码 1234567891011121314151617181920212223class Solution &#123;public: /** * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @return: The maximum size */ int backPack(int m, vector&lt;int&gt; &amp;a) &#123; int n = a.size(); if (!n || !m) return 0; int f[m + 1]; memset(f, false, sizeof f); f[0] = true; for (int i = 1; i &lt;= n; i++)&#123; for (int j = m; j &gt;= a[i - 1]; j--)&#123; f[j] = f[j] | f[j - a[i - 1]]; &#125; &#125; for (int i = m; i &gt;= 0; i--) if (f[i]) return i; &#125;&#125;; 564. Combination Sum IV题目大意题目链接给出一个都是正整数的数组 nums，其中没有重复的数。从中找出所有的和为 target 的组合个数。 一个数可以在组合中出现多次。数的顺序不同则会被认为是不同的组合。 分析转移方程很好想， 具体看AC代码吧。 AC代码 1234567891011121314151617181920212223class Solution &#123;public: /** * @param nums: an integer array and all positive numbers, no duplicates * @param target: An integer * @return: An integer */ int backPackVI(vector&lt;int&gt; &amp;a, int W) &#123; if(W == 0) return 0; int f[W + 1]; int n = a.size(); memset(f, 0, sizeof f); f[0] = 1; for (int i = 1; i &lt;= W; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (i &gt;= a[j]) f[i] += f[i - a[j]]; &#125; &#125; return f[W]; &#125;&#125;; 563. Backpack V题目大意题目链接 给出 n 个物品, 以及一个数组, nums[i] 代表第i个物品的大小, 保证大小均为正数, 正整数 target 表示背包的大小, 找到能填满背包的方案数。每一个物品只能使用一次 分析f[i][j] 表示用前i个物品拼出 重量j 的方案数f[i][j] = f[i - 1][j] + f[i - 1][j - a[i - 1]]然后可以优化成一维数组， 如何优化看上面两题 AC代码二维数组 12345678910111213141516171819202122232425262728class Solution &#123;public: /** * @param nums: an integer array and all positive numbers * @param target: An integer * @return: An integer */ int backPackV(vector&lt;int&gt; &amp;a, int W) &#123; int n = a.size(); if (n == 0) return 0; int f[n + 1][W + 1]; memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; f[i][j] = f[i - 1][j]; if (j &gt;= a[i - 1]) f[i][j] += f[i - 1][j - a[i - 1]]; &#125; &#125; return f[n][W]; &#125;&#125;; 一维数组 123456789101112131415161718192021222324252627class Solution &#123;public: /** * @param nums: an integer array and all positive numbers * @param target: An integer * @return: An integer */ int backPackV(vector&lt;int&gt; &amp;a, int W) &#123; int n = a.size(); if (n == 0) return 0; int f[W + 1]; memset(f, 0, sizeof f); f[0] = 1; for (int i = 1; i &lt;= n; i++)&#123; for (int j = W; j &gt;= 0; j--)&#123; if (j &gt;= a[i - 1]) f[j] += f[j - a[i - 1]]; &#125; &#125; return f[W]; &#125;&#125;; 125. Backpack II题目大意题目链接有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值. 问最多能装入背包的总价值是多大? 分析f[i][j] 表示 前i件物品 重量为j的最大价值f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i - 1]] + v[i - 1])化简为一位数组也是一样 AC代码二维 1234567891011121314151617181920212223242526class Solution &#123;public: /** * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @param V: Given n items with value V[i] * @return: The maximum value */ int backPackII(int W, vector&lt;int&gt; &amp;w, vector&lt;int&gt; &amp;v) &#123; int n = w.size(); if (!n) return 0; int f[n + 1][W + 1]; memset(f[0], 0 , sizeof f[0]); for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= W; ++j) &#123; f[i][j] = f[i - 1][j]; if (j &gt;= w[i - 1]) f[i][j] = max(f[i][j], f[i - 1][j - w[i - 1]] + v[i - 1]); &#125; &#125; return f[n][W]; &#125; &#125;; 一维 123456789101112131415161718192021222324class Solution &#123;public: /** * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @param V: Given n items with value V[i] * @return: The maximum value */ int backPackII(int W, vector&lt;int&gt; &amp;w, vector&lt;int&gt; &amp;v) &#123; int n = w.size(); if (!n) return 0; int f[W + 1]; memset(f, 0, sizeof f); for (int i = 1; i &lt;= n; i++)&#123; for (int j = W; j &gt;= w[i - 1]; --j) &#123; f[j] = max(f[j], f[j - w[i - 1]] + v[i - 1]); &#125; &#125; return f[W]; &#125; &#125;; 667. Longest Palindromic Subsequence题目描述题目链接给一字符串 s, 找出在 s 中的最长回文子序列的长度. 你可以假设 s 的最大长度为 1000. 分析 1234567891011最优策略产生最长回文子串T， 长度为M情况1: 回文串长度是1， 即一个字母情况2： 回文串长度大于1， 那么必有T[0] = T[M - 1]设T[0]是S[i], T[M - 1]是S[j]那么T剩下的部分T[1...M - 2]仍然是一个回文串， 而且是S[i + 1 ... j - 1]的最长回文子序列要求S[i..j]s的最长回文子序列如果S[i] = S[j]， 需要知道S[i + 1 ... j - 1] 的最长回文子序列否则答案就是S[i + 1 ... j] 的最长回文子序列或者S[i ... j - 1]的最长回文子序列的最大值设 f[i][j] 为S[i ... j] 的最长回文子序列的长度f[i][j] = max(f[i + 1][j], f[i][j + 1], f[i + 1][j - 1] +2 | S[i] == S[j]) 这题我用记忆化搜索写下， dp也写 AC代码记忆化搜索 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string s; int f[1003][1003]; void _(int l, int r)&#123; if (f[l][r] != -1) return ; if (l == r)&#123; f[l][r] = 1; return ; &#125; if (l + 1 == r)&#123; f[l][r] = (s[l] == s[r]) ? 2 : 1; return; &#125; _(l + 1, r); _(l, r - 1); _(l + 1, r - 1); f[l][r] = max(f[l + 1][r], f[l][r - 1]); if (s[l] == s[r]) f[l][r] = max(f[l][r], f[l + 1][r - 1] + 2); &#125; int longestPalindromeSubseq(string &amp;ss) &#123; s = ss; int n = s.length(); if (n == 0 || n == 1) return n; memset(f, -1, sizeof f); _(0, n - 1); return f[0][n - 1]; &#125;&#125;; DP 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int longestPalindromeSubseq(string &amp;s) &#123; int n = s.length(); if (n == 0 || n == 1) return n; int f[1003][1003]; for (int l = 0; l &lt; n; ++l)&#123; for (int i = 0; i &lt; n; i++)&#123; int j = i + l; if (l == 0)&#123; f[i][j] = 1; continue; &#125; if (l == 1)&#123; f[i][j] = s[i] == s[j] ? 2 : 1; continue; &#125; f[i][j] = max(f[i + 1][j], f[i][j - 1]); if (s[i] == s[j])&#123; f[i][j] = max(f[i][j], f[i + 1][j - 1] + 2); &#125; &#125; &#125; return f[0][n - 1]; &#125;&#125;; 396. Coins In A Line III题目大意题目链接• 题意：• 给定一个序列a[0], a[1], …, a[N-1]• 两个玩家Alice和Bob轮流取数• 每个人每次只能取第一个数或最后一个数• 双方都用最优策略，使得自己的数字和尽量比对手大• 问先手是否必胜– 如果数字和一样，也算先手胜 分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748• 这题是一道博弈题，目标是让自己拿到的数字之和不比对手小• 设己方数字和是A，对手数字和是B，即目标是A&gt;=B• 等价于A-B&gt;=0• 也就是说，如果Alice和Bob都存着自己的数字和与对手的数字和之差，分别记为SA=A-B，SB=B-A• 则Alice的目标是最大化SA，Bob的目标是最大化SB• 当一方X面对剩下的数字，可以认为X就是当前的先手，他的目标就是最大化SX=X-Y• 当他取走一个数字m后，对手Y变成先手，同理他也要最大化SY=Y-X• 对于X来说，SX = -SY + m• 其中，m是当前这步的数字，-SY是对手看来的数字差取相反数（因为先手是X）• 现在X有两种选择，取第一个数字m1或最后一个数字m2，为了最大化SX，应该选择较大的那个SX• 如果Alice第一步取走a[0]，Bob面对a[1..N-1]• Bob的最大数字差是SY• Alice的数字差是a[0]-SY• 如果Alice第一步取走a[N-1]，Bob面对a[0..N-2]• Bob的最大数字差是S’-Y• Alice的数字差是a[N-1]-S’-Y• Alice选择较大的数字差• 当Bob面对a[1..N-1]，他这时是先手• 他的目标同样是最大化先手（自己）和后手（Alice）的数字差• 但是此时的数字少了一个：a[1..N-1]• 子问题• 状态：设f[i][j]为一方先手在面对a[i..j]这些数字时，能得到的最大的与对手的数字差设f[i][j]为一方在面对a[i..j]这些数字时，能得到的最大的与对手的数字差f[i][j] = max&#123;a[i] - f[i+1][j], a[j] - f[i][j-1]&#125;为一方在面对a[i..j]时，能得到的最大的与对手的数字差选择a[i]，对手采取最优策略时自己能得到的最大的与对手的数字差选择a[j]，对手采取最优策略时自己能得到的最大的与对手的数字差• 设f[i][j]为一方在面对a[i..j]这些数字时，能得到的最大的与对手的数字差• f[i][j] = max&#123;a[i]-f[i+1][j], a[j]-f[i][j-1]&#125;• 只有一个数字a[i]时，己方得a[• 长度1：f[0][0], f[1][1], f[2][2], …, f[N-1][N-1]• 长度2： f[0][1], …, f[N-2][N-1]• …• 长度N： f[0][N-1]• 如果f[0][N-1]&gt;=0，先手Alice必赢，否则必输• 时间复杂度O(N2)，空间复杂度O(N2) AC代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: /** * @param values: a vector of integers * @return: a boolean which equals to true if the first player will win */ bool firstWillWin(vector&lt;int&gt; &amp;a) &#123; // write your code here if (a.empty()) return true; int n = a.size(); int f[n][n]; int i, j; for (i = 0; i &lt; n; i++)&#123; f[i][i] = a[i]; &#125; for (int len = 1; len &lt; n; len++)&#123; i = 0, j = len; while(j &lt; n)&#123; f[i][j] = max(a[j] - f[i][j - 1], a[i] - f[i + 1][j]); i++, j++; &#125; &#125; return f[0][n - 1] &gt;= 0; &#125;&#125;; 430. Scramble String题目大意 题目链接 12345678910111213141516171819202122232425262728293031323334给定一个字符串 s1, 将其递归地分割成两个非空子字符串, 然后可以得到一棵二叉树.下面是 s1 = \"great\" 可能得到的一棵二叉树: great / \\ gr eat / \\ / \\ g r e at / \\ a t在攀爬字符串的过程中, 我们可以选择其中任意一个非叶节点, 交换该节点的两个子节点.例如，我们选择了 \"gr\" 节点, 并将该节点的两个子节点进行交换, 并且将祖先节点对应的子串部分也交换, 最终得到了 \"rgeat\". 我们认为 \"rgeat\" 是 \"great\" 的一个攀爬字符串. rgeat / \\ rg eat / \\ / \\ r g e at / \\ a t类似地, 如果我们继续将其节点 \"eat\" 和 \"at\" 的子节点交换, 又可以得到 \"great\" 的一个攀爬字符串 \"rgtae\". rgtae / \\ rg tae / \\ / \\ r g ta e / \\ t a给定两个相同长度的字符串 s1 和 s2，判断 s2 是否为 s1 的攀爬字符串.你可以从任何一棵 s1 可以构造出的二叉树开始攀爬, 但是在攀爬得到 s2 的过程中不能重新构造二叉树. 分析 123456789101112131415161718192021222324252627• 显然，T如果长度和S不一样，那么肯定不能由S变换而来• 如果T是S变换而来的，并且我们知道S最上层二分被分成S=S1 S2，那么一定有：– T也有两部分T=T1 T2，T1是S1变换而来的，T2是S2变换而来的– T也有两部分T=T1 T2，T1是S2变换而来的，T2是S1变换而来的• 要求T是否由S变换而来• 需要知道T1是否由S1变换而来的，T2是否由S2变换而来• 需要知道T1是否由S2变换而来的，T2是否由S1变换而来• S1, S2, T1, T2长度更短• 子问题• 状态：f[i][j][k][h]表示T[k..h]是否由S[i..j]变换而来• 这里所有串都是S和T的子串，且长度一样• 所以每个串都可以用(起始位置，长度)表示• 例如：– S1长度是5，在S中位置7开始– T1长度是5，在T中位置0开始– 可以用f[7][0][5]=True/False表示S1能否通过变换成为T1• 状态：设f[i][j][k]表示S1能否通过变换成为T1– S1为S从字符i开始的长度为k的子串– T1为T从字符j开始的长度为k的子串• 设f[i][j][k]表示S1能否通过变换成为T1– S1为S从字符i开始的长度为k的子串– T1为T从字符j开始的长度为k的子串f[i][j][k] = OR1&lt;=w&lt;=k-1&#123;f[i][j][w] AND f[i+w][j+w][k-w]&#125;OR1&lt;=w&lt;=k-1&#123;f[i][j+k-w][w] AND f[i+w][j][k-w]&#125; AC代码 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param s1: A string * @param s2: Another string * @return: whether s2 is a scrambled string of s1 */ bool isScramble(string &amp;s1, string &amp;s2) &#123; // write your code here int n = s1.length(); bool f[n][n][n + 1]; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) f[i][j][1] = (s1[i] == s2[j]); for (int k = 2; k &lt;= n; ++k)&#123; for (int i = 0; i &lt;= n - k; ++i)&#123; for (int j = 0; j &lt;= n - k; ++j)&#123; f[i][j][k] = false; for (int w = 1; w &lt; k; ++w)&#123; if (f[i][j][w] &amp;&amp; f[i + w][j + w][k - w])&#123; f[i][j][k] = true; break; &#125; if (f[i][j + k - w][w] &amp;&amp; f[i + w][j][k - w])&#123; f[i][j][k] = true; break; &#125; &#125; &#125; &#125; &#125; return f[0][0][n]; &#125;&#125;; 168. Burst Balloons题目大意题目链接有n个气球，编号为0到n-1，每个气球都有一个分数，存在nums数组中。每次吹气球i可以得到的分数为 nums[left] * nums[i] * nums[right]，left和right分别表示i气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。 你可以假设nums[-1] = nums[n] = 1。-1和n位置上的气球不真实存在，因此不能吹爆它们。0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 分析 123456789101112• 所有N个气球都被扎破• 最后一步：一定有最后一个被扎破的气球，编号是i• 扎破i时，左边是气球0，右边是气球N+1，获得金币1*ai*1=ai• 此时气球1~i-1以及i+1~N都已经被扎破，并且已经获得对应金币• 要求扎破1~N号气球，最多获得的金币数• 需要知道扎破1~i-1号气球，最多获得的金币数和扎破i+1~N号气球，最多获得的金币数• 子问题• 状态：设f[i][j]为扎破i+1~j-1号气球，最多获得的金币数• 设f[i][j]为扎破i+1~j-1号气球，最多获得的金币数– i和j不能扎破f[i][j] = maxi&lt;k&lt;j&#123;f[i][k] + f[k][j] + a[i] * a[k] * a[j]&#125; AC代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: /** * @param nums: A list of integer * @return: An integer, maximum coins */ int maxCoins(vector&lt;int&gt; &amp;aa) &#123; // write your code here int n = aa.size(); vector&lt;int&gt;a; a.push_back(1); for (int i = 0; i &lt; n; ++i)&#123; a.push_back(aa[i]); &#125; a.push_back(1); int f[n + 2][n + 2]; memset(f, 0, sizeof f); int i, j; for (int l = 2; l &lt;= n + 1; ++l)&#123; for (i = 0; i &lt;= n; ++i)&#123; j = i + l; if (j &gt; n + 1) break; for (int k = i + 1; k &lt; j; k++) f[i][j] = max(f[i][j], f[i][k] + f[k][j] + a[i] * a[j] * a[k]); &#125; &#125; return f[0][n + 1]; &#125;&#125;; 77. Longest Common Subsequence题目大意题目链接给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。 分析 1234567891011121314151617• 设A长度是m, B长度是n• 现在我们考虑最优策略产生出的最长公共子串（虽然还不知道是什么）• 最后一步：观察A[m-1]和B[n-1]这两个字符是否作为一个对子在最优策略中• 最长公共子串也是公共子串：长度是L选定了L个对应的对子情况一：对子中没有A[m-1]推论：A和B的最长公共子串就是A前m-1个字符和B前n个字符的最长公共子串情况二：对子中没有B[n-1]推论：A和B的最长公共子串就是A前m个字符和B前n-1个字符的最长公共子串情况三：对子中有A[m-1]-B[n-1]推论：A和B的最长公共子串就是A前m-1个字符和B前n-1个字符的最长公共子串+A[m-1]• 状态：设f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子串的长度• 设f[i][j]为A前i个字符A[0..i-1]和B前j个字符[0..j-1]的最长公共子串的长度• 要求f[m][n]f[i][j] = max&#123;f[i-1][j], f[i][j-1], f[i-1][j-1]+1|A[i-1]=B[j-1]&#125; AC代码 1234567891011121314151617181920212223242526272829class Solution &#123;public: /** * @param A: A string * @param B: A string * @return: The length of longest common subsequence of A and B */ int longestCommonSubsequence(string &amp;a, string &amp;b) &#123; // write your code here int n = a.length(); int m = b.length(); int f[n + 1][m + 1]; for (int i = 0; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= m; j++)&#123; if (i == 0 || j == 0)&#123; f[i][j] = 0; continue; &#125; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i - 1] == b[j - 1]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; &#125; return f[n][m]; &#125;&#125;; 29. Interleaving String题目大意题目大意给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成 分析 123456789101112131415161718• 首先，如果X的长度不等于A的长度+B的长度，直接输出False• 设A长度是m, B长度是n，X的长度是m+n• 最后一步：假设X是由A和B交错形成的，那么X的最后一个字符X[m+n-1]– 要么是A[m-1]• 那么X[0..m+n-2]是由A[0..m-2]和B[0..n-1]交错形成的– 要么是B[n-1]• 那么X[0..m+n-2]是由A[0..m-1]和B[0..n-2]交错形成的• 要求X[0..m+n-1]是否由A[0..m-1]和B[0..n-1]交错形成• 需要知道X[0..m+n-2]是否由A[0..m-2]和B[0..n-1]交错形成，以及X[0..m+n-2]是否由A[0..m-1]和B[0..n-2]交错形成• 子问题• 状态：设f[s][i][j]为X前s个字符是否由A前i个字符A[0..i-1]和B前j个字符B[0..j-1]交错形成• 但是s=i+j，所以可以简化为：设f[i][j]为X前i+j个字符是否由A前i个字符A[0..i-1]和B前j个字符B[0..j-1]交错形成• 设f[i][j]为X前i+j个字符是否由A前i个字符A[0..i-1]和B前j个字符B[0..j-1]交错形成f[i][j] = (f[i-1][j] AND X[i+j-1]==A[i-1]) OR (f[i][j-1] AND X[i+j-1]==B[j-1]) AC代码 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: /** * @param s1: A string * @param s2: A string * @param s3: A string * @return: Determine whether s3 is formed by interleaving of s1 and s2 */ bool isInterleave(string &amp;s1, string &amp;s2, string &amp;s3) &#123; // write your code here int n = s1.length(); int m = s2.length(); bool f[n + 1][m + 1]; if (s3.length() != n + m) return false; for (int i = 0; i &lt;= n; ++i)&#123; for (int j = 0; j &lt;= m; ++j)&#123; if (i == 0 &amp;&amp; j == 0)&#123; f[i][j] = true; continue; &#125; f[i][j] = false; if (i &gt; 0 &amp;&amp; s1[i - 1] == s3[i + j - 1]) f[i][j] |= f[i - 1][j]; if (j &gt; 0 &amp;&amp; s2[j - 1] == s3[i + j - 1]) f[i][j] |= f[i][j - 1]; &#125; &#125; return f[n][m]; &#125;&#125;; 119. Edit Distance题目描述题目链接给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。 分析 123• 设f[i][j]为B前j个字符B[0..j-1]在A前i个字符A[0..i-1]中出现多少次• 要求f[m][n]f[i][j] = f[i-1][j-1]|A[i-1]=B[j-1] + f[i-1][j] AC代码 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param word1: A string * @param word2: A string * @return: The minimum number of steps. */ int minDistance(string &amp;s1, string &amp;s2) &#123; // write your code here if (s1 == s2) return 0; int n = s1.length(); int m = s2.length(); int f[n + 1][m + 1]; for (int i = 0; i &lt;= n; ++i)&#123; for (int j = 0; j &lt;= m; ++j)&#123; if (i == 0 || j == 0)&#123; f[i][j] = max(i, j); continue; &#125; if (s1[i - 1] == s2[j - 1])&#123; f[i][j] = f[i - 1][j - 1]; continue; &#125; f[i][j] = min(f[i - 1][j], min(f[i - 1][j - 1], f[i][j - 1])) + 1; &#125; &#125; return f[n][m]; &#125;&#125;; 118. Distinct Subsequences题目大意题目链接给定字符串 S 和 T, 计算 S 的所有子序列中有多少个 T. 子序列字符串是原始字符串删除一些(或零个)字符之后得到的字符串, 并且要求剩下的字符的相对位置不能改变. (比如 “ACE” 是 ABCDE 的一个子序列, 而 “AEC” 不是) 分析 12345678• 双序列型动态规划• B在A中出现多少次（可以不连续）• 如果至少出现一次，那么A和B的最长公共子串就是B，而且也不能更长• 用最长公共子串的思路：对应对子• 状态：设f[i][j]为B前j个字符B[0..j-1]在A前i个字符A[0..i-1]中出现多少次• 设f[i][j]为B前j个字符B[0..j-1]在A前i个字符A[0..i-1]中出现多少次• 要求f[m][n]f[i][j] = f[i-1][j-1]|A[i-1]=B[j-1] + f[i-1][j] AC代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: /** * @param S: A string * @param T: A string * @return: Count the number of distinct subsequences */ int numDistinct(string &amp;s, string &amp;t) &#123; // write your code here int m = s.length(); int n = t.length(); int f[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; if (j == 0)&#123; f[i][j] = 1; continue; &#125; if (i == 0)&#123; f[i][j] = 0; continue; &#125; f[i][j] = f[i - 1][j]; if (s[i - 1] == t[j - 1]) f[i][j] += f[i - 1][j - 1]; &#125; &#125; return f[m][n]; &#125;&#125;; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"总结","slug":"总结","permalink":"https://solodance.top/tags/%E6%80%BB%E7%BB%93/"},{"name":"动态规划总结","slug":"动态规划总结","permalink":"https://solodance.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"}]},{"title":"带权并查集HDU How Many Answers Are Wrong","date":"2020-01-23T13:42:34.904Z","path":"2020/01/23/带权并查集HDU How Many Answers Are Wrong/","text":"带权并查集HDU How Many Answers Are Wrong题目链接 题意：给出m组 三个数x, y, v, 表示的含义是闭区间[x, y] 的权值为v， 让你计算出现矛盾的组数。 为什么要用并查集？以我现在的知识， 这种判断矛盾的好的解决方法貌似只有并查集这一种了。 如何判断真假呢， 首先我们输入三个整数x, y, v 只要找到 x == x &amp;&amp; y == y &amp;&amp; v == v 就可以判断他是真的了， 要是找不到了 就不确定了。 要怎么比？首先就是要找到一个基准（祖先）A 判断(y - A) - (x - A) ?= v 就行了呗。 就这样， 带权并查集就出来了 具体如何合并看下图 看ac代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include \"algorithm\"#include \"cstdio\"#include \"set\"#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 2e5 + 5;int f[N], v[N];int tofind(int x)&#123; if (f[x] != x)&#123; int t = f[x]; f[x] = tofind(f[x]); v[x] += v[t]; &#125; return f[x];&#125;void init(int n)&#123; for (int i = 0; i &lt;= n; i++)&#123; f[i] = i; v[i] = 0; &#125;&#125;int main()&#123; int n, m, a, b, c; while(cin &gt;&gt; n &gt;&gt; m)&#123; // 注意这里特别坑， 题目中没说多组输入 但是不多组输入就WA init(n); int ans = 0; while(m--)&#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); a--; // a-- 是使得原来的区间编程半开半闭区间 而半开半闭区间的好处就是(1, 3] + (3, 5] = (1, 5] 这样可以合并 int fa = tofind(a); int fb = tofind(b); if (fa != fb)&#123; f[fa] = fb; v[fa] = -(v[a] + c - v[b]); &#125; else&#123; if (v[b] - v[a] != c) ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"带权并查集","slug":"带权并查集","permalink":"https://solodance.top/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"差分约束系统","date":"2020-01-23T13:42:34.904Z","path":"2020/01/23/差分约束系统/","text":"差分约束系统简介差分约束系统（System of Difference Constraints），是求解关于一组变数的特殊不等式组之方法。 如何一个系统由n个变量和m个约束条件组成， 其中每个约束条件形如x[i] - x[j] &lt;= d (i, j ∈ [1, n], t ∈ [1, m])， 则称其为差分约束系统。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。 如果 x[i] - x[j] &lt;= d ， 那么从 j 到 i 链接一条长度为d的边。那么就是求最短路。如果 x[i] - x[j] &gt;= d ， 那么从 j 到 i 链接一条长度为d的边。那么就是求最长路。 判断有无解判断图有没有负环即可，如果发现了负环，说明找到了矛盾。 用spfa判负环123456789101112131415161718192021bool spfa(int s) &#123; dis[s] = 0; vis[s] = 1; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = 0; tim[u]++; if (tim[u] &gt; sqrt(n + m)) return 0; for (int i = head[u]; ~i; i = ed[i].ne) &#123; int v = ed[i].v; if (dis[v] &gt; dis[u] + ed[i].w) &#123; dis[v] = dis[u] + ed[i].w; if (!vis[v]) q.push(v), vis[v] = 1; &#125; &#125; &#125; return 1;&#125; dfs判负环12345678910111213141516171819202122232425262728inline bool spfa(int u)&#123; vis[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v, w = ed[i].w; if (dis[v] &gt; dis[u] + w)&#123; if (vis[v]) &#123; vis[v] = 0; return 0; &#125; dis[v] = dis[u] + w; if (!spfa(v)) &#123; vis[v] = 0; return 0; &#125; &#125; &#125; vis[u] = 0; return 1;&#125;int main()&#123; for (int i = 1; i &lt;= n; ++i)&#123; if (!spfa(i))&#123; cout &lt;&lt; \"No\\n\"; return 0; &#125; &#125; cout &lt;&lt; \"Yes\\n\";&#125; 例题 1. [SCOI2011]糖果题目链接这是一道没给数据范围的题， 而且还是一个很玄学的题， 最短路过不了（要是有大佬过了欢迎留言）最长路过了， 正向建超级源点过不了， 反向建过了。。AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;deque&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; #define eps 1e-8#define ms(i, val) memset(i, val, sizeof i)using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 3e5 + 5;const int M = 3e6 + 5;const int INF = 0x3f3f3f3f;const ll ll_max = 4557430888798830399; inline int read() &#123; int res = 0; bool f = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge &#123; int u, v;ll w; int ne;&#125; ed[M];int cnt, n, m, head[N], tim[N];ll dis[N];bool vis[N]; void init() &#123; ms(vis, false); ms(head, -1); cnt = 0; ms(tim, 0);&#125;inline void add(int u, int v, ll w) &#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125; deque&lt;int&gt;q;inline bool spfa(int u)&#123; dis[u] = 0; vis[u] = 1; q.push_back(u); while(!q.empty())&#123; u = q.front();q.pop_front(); vis[u] = 1; tim[u]++; if (tim[u] &gt; sqrt(n + m)) return 0; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int &amp;v = ed[i].v; ll &amp;w = ed[i].w; if (dis[v] &lt; dis[u] + w)&#123; dis[v] = dis[u] + w; if (!q.empty() &amp;&amp; dis[v] &lt;= dis[q.front()]) q.push_back(v); else q.push_front(v); vis[v] = 1; &#125; &#125; &#125; return 1;&#125; int main() &#123; int a, b, op; n = read(), m = read(); init(); for (int i = 0; i &lt; m; ++i)&#123; op = read(), a = read(), b = read(); if (op == 1) add(a, b, 0), add(b, a, 0); if (op == 2) add(a, b, 1); if (op == 3) add(b, a, 0); if (op == 4) add(b, a, 1); if (op == 5) add(a, b, 0); &#125; for (int i = n; i &gt;= 1; --i)&#123; add(0, i, 1); &#125; ll ans = 0; if (spfa(0))&#123; for (int i = 1; i &lt;= n; ++i)&#123; ans += dis[i]; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; else cout &lt;&lt; \"-1\\n\"; return 0;&#125; 例题2. HDU3666. THE MATRIX PROBLEM题目链接隐藏比较深的差分约束了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 1001;const int INF = 0x3f3f3f3f;const ll ll_max = 4557430888798830399;struct edge &#123; int u, v, ne; double w;&#125; ed[340444];int cnt, n, m, head[N], tim[N];bool vis[N];double dis[N];queue&lt;int&gt; q;void init() &#123; memset(tim, 0, sizeof tim); for (int i = 0; i &lt;= m + n; ++i) dis[i] = INF, tim[i] = 0, head[i] = -1, vis[i] = 0; cnt = 0;&#125;void add(int u, int v, double w) &#123; ed[cnt].u = u, ed[cnt].v = v, ed[cnt].w = w; ed[cnt].ne = head[u]; head[u] = cnt++;&#125;int u, v;bool spfa(int u) &#123; vis[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int &amp;v = ed[i].v; double &amp;w = ed[i].w; if (dis[v] &gt; dis[u] + w)&#123; dis[v] = dis[u] + w; if (vis[v])&#123; vis[v] = 0; return 0; &#125; if (!spfa(v))&#123; vis[v] = 0; return 0; &#125; &#125; &#125; vis[u] = 0; return 1;&#125;double L, U, x;int main() &#123; while (~scanf(\"%d%d%lf%lf\", &amp;n, &amp;m, &amp;L, &amp;U)) &#123; init(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%lf\", &amp;x); add(j + n, i, log(U / x)); add(i, j + n, log(x / L)); &#125; &#125; int flag = 1; for (int i = 1; i &lt;= n + m; ++i) &#123; if (!spfa(i)) &#123; puts(\"NO\"); flag = 0; break; &#125; &#125; if (flag) puts(\"YES\"); &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"最短路","slug":"最短路","permalink":"https://solodance.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"差分约束","slug":"差分约束","permalink":"https://solodance.top/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://solodance.top/tags/ubuntu/"},{"name":"spfa","slug":"spfa","permalink":"https://solodance.top/tags/spfa/"}]},{"title":"并查集-POJ 1182食物链","date":"2020-01-23T13:42:34.904Z","path":"2020/01/23/并查集-POJ 1182食物链/","text":"题目链接 由题意可知， 一共有3种关系， 就开3倍大的数组。 看别人的概念解释（反正我写不来） 注意， 种类并查集求的并非种类， 而是关系！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 5e4 + 5;int f[3 * N];int tofind(int x)&#123; if (f[x] != x)&#123; f[x] = tofind(f[x]); &#125; return f[x];&#125;void tojoin(int x, int y)&#123; x = tofind(x); y = tofind(y); if (x != y)&#123; f[x] = y; &#125;&#125;int main() &#123; /* a 吃 b a == b + n a + n == b + 2 * n a + 2 * n == b a 和 b 同类 a == b a + n == b + n a + 2 * n == b + 2 * n b 吃 a b == a + n b + n == a + 2 * n b + 2 * n == a */ int n, k, d, x, y; int sum = 0; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt;= 3 * n; i++)&#123; f[i] = i; &#125; while(k--)&#123; scanf(\"%d%d%d\", &amp;d, &amp;x, &amp;y); if (x &gt; n || y &gt; n)&#123; sum++; continue; &#125; if (d == 1)&#123; if (tofind(x) == tofind(y + n) || tofind(x + n) == tofind(y))&#123; sum++; &#125; else&#123; tojoin(x, y); tojoin(x + n, y + n); tojoin(x + n + n, y + n + n); &#125; &#125; else&#123; if (tofind(x) == tofind(y) || tofind(y) == tofind(x + n))&#123; sum++; &#125; else&#123; tojoin(x, y + n); tojoin(x + n, y + n + n); tojoin(x + n + n, y); &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; \"\\n\"; return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"种类并查集","slug":"种类并查集","permalink":"https://solodance.top/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"题解","slug":"题解","permalink":"https://solodance.top/tags/%E9%A2%98%E8%A7%A3/"},{"name":"kuangbin带你飞","slug":"kuangbin带你飞","permalink":"https://solodance.top/tags/kuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E/"}]},{"title":"并查集  HDU - 1272","date":"2020-01-23T13:42:34.873Z","path":"2020/01/23/并查集 HDU - 1272/","text":"题目链接 题意：判断所给的图中 两点间的路径是否唯一（不走回头路） 坑点/思想： 没加入一条边， 判断他们的祖先是否相同，如果相同， 那么他们之间的路径不唯一 判断这个图是否只有一个连通块（用set储存（突然又想到直接用队列更好一些 ）然后判断tofind（i） == i 的个数 如果大于1， 则证明不仅仅只有一个连通块） 针对上面的题， 特殊情况， 边界情况要考虑在内 Ac代码：（set实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include \"algorithm\"#include \"cstdio\"#include \"set\"#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 2e5 + 5;int f[N];set&lt;int&gt;se;set&lt;int&gt;::iterator it;int tofind(int x)&#123; if (f[x] != x)&#123; f[x] = tofind(f[x]); &#125; return f[x];&#125;void tojoin(int a, int b)&#123; a = tofind(a); b = tofind(b); if (a != b)&#123; f[a] = b; &#125;&#125;void init()&#123; for (int i = 0; i &lt;= N; i++)&#123; f[i] = i; &#125; se.clear();&#125;int main()&#123; int a, b; int f = 0; init(); while(cin &gt;&gt; a &gt;&gt; b)&#123; if (!a &amp;&amp; !b)&#123; if (f) puts(\"No\"); else&#123; int sum = 0; for (it = se.begin(); it != se.end(); it ++)&#123; if (tofind(*it) == *it) sum++; if (sum &gt;= 2) break; &#125; if (sum &gt;= 2) puts(\"No\"); else&#123; puts(\"Yes\"); &#125; &#125; f = 0; init(); &#125; else if (a == -1 &amp;&amp; b == -1) break; else&#123; se.insert(a); se.insert(b); if (tofind(a) != tofind(b)) tojoin(a, b); else f = 1; &#125; &#125; return 0;&#125; Ac代码：（队列实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 2e5 + 5;int f[N];queue&lt;int&gt;q;int tofind(int x)&#123; if (f[x] != x)&#123; f[x] = tofind(f[x]); &#125; return f[x];&#125;void tojoin(int a, int b)&#123; a = tofind(a); b = tofind(b); if (a != b)&#123; f[a] = b; &#125;&#125;void init()&#123; for (int i = 0; i &lt;= N; i++)&#123; f[i] = i; &#125; while(!q.empty()) q.pop();&#125;int main()&#123; int a, b; int f = 0; init(); while(cin &gt;&gt; a &gt;&gt; b)&#123; if (!a &amp;&amp; !b)&#123; if (f) puts(\"No\"); else&#123; int sum = 0; while(!q.empty())&#123; int k = q.front(); q.pop(); if (tofind(k) == k) sum++; if (sum &gt;= 2) break; &#125; if (sum &gt;= 2) puts(\"No\"); else&#123; puts(\"Yes\"); &#125; &#125; f = 0; init(); &#125; else if (a == -1 &amp;&amp; b == -1) break; else&#123; q.push(a); q.push(b); if (tofind(a) != tofind(b)) tojoin(a, b); else f = 1; &#125; &#125; return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"并查集","slug":"并查集","permalink":"https://solodance.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"ZOJ-3195Design the city（树上三点最短距离）","date":"2020-01-23T13:42:34.857Z","path":"2020/01/23/ZOJ-3195Design the city（树上三点最短距离）/","text":"题目大意题目链接 Cerror is the mayor of city HangZhou. As you may know, the traffic system of this city is so terrible, that there are traffic jams everywhere. Now, Cerror finds out that the main reason of them is the poor design of the roads distribution, and he want to change this situation. In order to achieve this project, he divide the city up to N regions which can be viewed as separate points. He thinks that the best design is the one that connect all region with shortest road, and he is asking you to check some of his designs. Now, he gives you an acyclic graph representing his road design, you need to find out the shortest path to connect some group of three regions. InputThe input contains multiple test cases! In each case, the first line contian a interger N (1 &lt; N &lt; 50000), indicating the number of regions, which are indexed from 0 to N-1. In each of the following N-1 lines, there are three interger Ai, Bi, Li (1 &lt; Li &lt; 100) indicating there’s a road with length Li between region Ai and region Bi. Then an interger Q (1 &lt; Q &lt; 70000), the number of group of regions you need to check. Then in each of the following Q lines, there are three interger Xi, Yi, Zi, indicating the indices of the three regions to be checked. Process to the end of file. OutputQ lines for each test case. In each line output an interger indicating the minimum length of path to connect the three regions. Output a blank line between each test cases. Sample Input12345678910111213141540 1 10 2 10 3 121 2 30 1 250 1 10 2 11 3 11 4 120 1 21 0 3 Sample Output 1234322 分析树上三点最短距离为 所有两点距离之和除以二。明白这个就可以了， 还有就是注意别pe…… AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;#define ms(a, b) memset((a), (b), sizeof(a))const int N = (int)5e4 + 5;const int M = (int)2e5 + 10;const int INF = 0x3f3f3f3f;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge&#123; int u, v, w, ne;&#125;ed[N &lt;&lt; 1];int head[N], dis[N], cnt, n, m;int deep[N], fa[N][20];bool vis[N];inline void init()&#123; ms(head, -1); cnt = 0; ms(deep, 0); ms(dis, 0); ms(vis, 0);&#125;inline void add(int u, int v, int w)&#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125;inline void dfs(int u, int pre)&#123; deep[u] = deep[pre] + 1; // deep数组表示深度 fa[u][0] = pre; // fa[i][j] 表示i的第2^j辈的祖先 for (int i = 1; i &lt; 20; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; // fa[i][j] = fa[fa[i][j - 1]][j - 1] i的第2^j辈的祖先 等于 i的第2^(j-1)辈的祖先的第2^(j-1)辈的祖先 for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v; if(v == pre) continue; dis[v] = dis[u] + ed[i].w; dfs(v, u); &#125;&#125;inline int lca(int a, int b)&#123; if (deep[a] &lt; deep[b]) swap(a, b); // 运用二进制的思想 使得deep[a] == deep[b] 比如 7 可以用4 2 1表示 for (int i = 19; i &gt;= 0; --i) if (deep[a] - (1 &lt;&lt; i) &gt;= deep[b]) a = fa[a][i]; if (a == b) return a; // 倍增 2^k 步的爬, 找最小的满足 a != b 的 for (int i = 19; i &gt;= 0; --i)&#123; if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; &#125; return fa[a][0];&#125;int t, u, v, w, q;int main()&#123; t = 1; while(~scanf(\"%d\", &amp;n))&#123; if (t++ != 1) // 防pe putchar(10); init(); for (int i = 1; i &lt;= n - 1; ++i)&#123; u = read(), v = read(), w = read(); add(u, v, w); add(v, u, w); &#125; dfs(0, -1); q = read(); while(q--)&#123; u = read(), v = read(), w = read(); int x1 = lca(u, v); int x2 = lca(u, w); int x3 = lca(w, v); printf(\"%d\\n\", dis[u] + dis[v] + dis[w] - dis[x1] - dis[x2] - dis[x3]); &#125; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"lca","slug":"lca","permalink":"https://solodance.top/tags/lca/"}]},{"title":"把vstdio调成ACMer的使用习惯总结","date":"2020-01-23T13:42:34.857Z","path":"2020/01/23/把vstdio调成ACMer的使用习惯总结/","text":"把scanf_s 改成 scanf在项目属性里， 把SDL 检查关了 关闭 pch.h在项目属性里 vs默认tab 补全， 将其更改为 回车补全工具–&gt;选项–&gt;文本编辑器–&gt;C/C++ –&gt;高级–&gt;主动提交成员列表 添加c++万能头文件 在安装路径下，依次进入:VC –&gt; Tools –&gt; MSVC –&gt; 14.13.26128(此文件夹名每个人会有不同) –&gt; include 在 include 文件夹下新建一个 bits 文件夹，在此文件夹下添加 stdc++.h 头文件， 你需要在外面任意一文件夹新建一个txt文件文件名为stdc++.h， 记住.txt也不要， 不是stdc++.h.txt 而是stdc++.h。 然后右击用文本编辑， 复制以下代码放到里面， 然后保存， 在复制到bits 文件夹 重启vstdio就可以使用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"零碎小知识","slug":"零碎小知识","permalink":"https://solodance.top/tags/%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"Windows+ubuntu装双系统步骤以及遇到的问题总结","date":"2020-01-23T13:42:34.842Z","path":"2020/01/23/Windows+ubuntu装双系统步骤以及遇到的问题总结/","text":"Windows+ubuntu装双系统步骤以及遇到的问题总结1. 下载镜像 ：官网：https://ubuntu.com/download/desktop2. 将镜像写入u盘中。推荐软件 ： 软碟通： 下载地址 使用方法： 文件 -&gt; 打开 -&gt; 打开下完的镜像。 启动 -&gt; 写入U盘镜像 （此操作会格式化U盘， 请提前备份好数据） 耐心等 3. 安装前的准备在你想安装ubuntu的硬盘上分出100GB或者50GB的未分配空间 （如何分空间自己百度）， 未分配空间尽量是位于硬盘尾部， 不容易出现意外 要是你windows某天凉了的话。 4. 安装 设置bios开机启动项为 UEFI （也就是你的U盘） 特别注意： 如果你的显卡比较好的话， 不要直接点击 install Ubuntu， 正确的操作是： 按e进入启动编辑， 你会发现很多英文， 倒数第二行最后会有两个横线， 删除横线 输入 nomodeset 然后按F10启动。 语言看自己爱好， 选中文的话就很容易看得懂了， 不连接网络， 正常安装， 然后最重要的是在某一步的时候， 你要选其它选项。 找到你空出来的未分配空间， 右击 添加 分别输入（500， 逻辑分区， EFI系统分区）， 然后等待， 继续（8000， 逻辑分区， 交换分区) ， 然后等待， 继续（ 剩下分区的一半或者2/3 ， 主分区， 分区类型不用动， 下面选 /）， 然后等待， 继续（剩下的所有， 逻辑分区， 分区类型不用动， 下面选 /HOME） 看看的EFI分区前面的一串字符， 在下面挂载驱动器选择那个， 然后开始安装 不出意外， 安装成功。 重启的时候， 也别直接回车进去Ubuntu， 还是按e， 然后在倒数第二行后部分&amp;符号的前面输入nomodeset， F10引导启动。 5. 基本配置 如何切换到root用户 新装的系统， 先执行 sudo passwd root, 设置密码 执行su root， 就可以切换到root用户。 统一windows和ubuntu的时间 更新时间sudo apt-get install ntpdate sudo ntpdate time.windows.com 更新到硬件 sudo hwclock --localtime --systohc 安装vim， g++ vim sudo apt-get install vim g++ sudo apt-get install g++ 设置windows为首启动项 进入grub sudo vim /etc/default/grub 将GRUB_DEFAULT=0 改为2（从0开始 windows是第三个所以是2） 更新下sudo update-grub 安装显卡驱动 查看推荐显卡驱动 ubuntu-drivers devices 安装推荐驱动 sudo ubuntu-deivers autoinstall 重启即可 查看显卡信息（重启后） nvidia-smi 安装anaconda3 去官网或者清华， 中科大 下载镜像 直接 bash ~.sh ~是文件名称 路径默认即可 安装过程中提示添加环境变量， yes添加即可。 anaconda2与anaconda3共存 下好镜像 ， 执行下列命令 12345678910bash ~.sh -b -p $HOME/anaconda3/envs/anaconda2rm -f $HOME/anaconda3/envs/anaconda2/bin/conda*rm -f $HOME/anaconda3/envs/anaconda2/conda-meta/conda-*rm -f $HOME/anaconda3/envs/anaconda2/bin/acticaterm -f $HOME/anaconda3/envs/anaconda2/bin/deactivatecd $HOME/anaconda3/envs/anaconda2/binln -s ../../../bin/conda .ln -s ../../../bin/activate .ln -s ../../../bin/deactivate . 安装tim deepin wine QQ 添加右键以管理员身份运行功能 sudo apt install nautilus-admin 安装完重启 nautilus -q 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://solodance.top/tags/ubuntu/"},{"name":"双系统","slug":"双系统","permalink":"https://solodance.top/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"}]},{"title":"vps评测","date":"2020-01-23T13:42:34.826Z","path":"2020/01/23/vps评测/","text":"对新入手的华为云学生机评测记录 1.用一键测试脚本Superspeed.sh 测试服务器到国内的速度123wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.shchmod +x superspeed.sh./superspeed.sh 测试截图： 可以发现下载速度很好（毕竟1M宽带）， 就是上传速度差了点。 2.用一键检测VPS的CPU、内存、负载、IO读写、机房带宽等的脚本：bench.sh1234567891011121314命令1：wget -qO- bench.sh | bash或者curl -Lso- bench.sh | bash命令2：wget -qO- 86.re/bench.sh | bash或者curl -so- 86.re/bench.sh | bash备注：bench.sh 既是脚本名，同时又是域名。如果以上失效，请使用以下地址下载再执行脚本：下载地址：https://github.com/teddysun/across/blob/master/bench.sh 可以看到此vps一些详细信息， IO的读取还是很不错的。 可以发现下载速度达到3MB/s 。 对1M的宽带来说很好啦。 3.用一键带宽检测工具：speedtest-cli， 检测实际带宽情况安装命令 123sudo apt-get updateapt-get install python-pipsudo pip install speedtest-cli 使用方法 12345678910speedtest-cli#后面也可以接以下参数：-h, --help show this help message and exit --share 分享你的网速，该命令会在speedtest网站上生成网速测试结果的图片。 --simple Suppress verbose output, only show basic information --list 根据距离显示speedtest.net的测试服务器列表。 --server=SERVER 指定列表中id的服务器来做测试。 --mini=MINI URL of the Speedtest Mini server --source=SOURCE Source ip address to bind to --version Show the version number and exit emmm 和上面测试的差不多， 给个赞。 4.用VPS性能综合跑分工具：unixbench 跑分123wget --no-check-certificate https://github.com/teddysun/across/raw/master/unixbench.shchmod +x unixbench.sh./unixbench.sh emm， 链接超时， 这个等着以后再跑吧， 5.用一键测试回程Ping值工具：mPing12wget https://raw.githubusercontent.com/helloxz/mping/master/mping.shbash mping.sh emm， 可能是安全组策略问题， 等着以后再测吧。 简单的做了几项测试， 总的来说， 这个vps超值， 我买了一年的， 何况还有牛客报销， 简直美滋滋了呀， 快来参加活动吧， 活动详情请见https://www.nowcoder.com/discuss/306554","tags":[{"name":"vps","slug":"vps","permalink":"https://solodance.top/tags/vps/"}]},{"title":"SDNU-1522陆历川学数学（求最大素因子）","date":"2020-01-23T13:42:34.811Z","path":"2020/01/23/SDNU-1522陆历川学数学（求最大素因子）/","text":"先看题： 题目描述题目链接陆历川很热爱数学，最近他学了质数，他被质数深深的吸引了，但是陆历川有个习惯，他喜欢给一些东西编号，所以他决定给所有的质数编号，例如给2编号1，3编号2，5编号3……..这样2，3，5就是质数里面的大当家，二当家和三当家了，陆历川现在知道了这些编号，现在他会给你一个数，他想知道这个数的所有的质因子里面的最大编号是多少？注：0和1的编号都是0。 Input一个自然数N(0&lt;= N &lt;= 1000000)多组输入样例 Output最大编号 Sample Input1234512345 Sample Output1234501213 题解思路： 只要求求最大的素因数的所在编号。我一开始的思路是求出这个数的质因数， 然后排序找最大， TLE，之后不论是遍历n还是遍历素数集， 都TLE了，搜了一下才想到在编号上做文章。根据这一题， 埃氏筛的那一点点瑕疵就没有了。 具体怎么变得请看下面代码注释 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int N = 1e6 + 5;const int M = 1e9;int pri[N];int ma[N];bool is[N];int len = 0;void sushu(int n)&#123; memset(is, true, sizeof is); is[0] = is[1] = 0; for (int i = 2; i &lt;= n; i++)&#123; if (is[i])&#123; pri[len++] = i; ma[i] = len; for (int j = 2 * i; j &lt;= n; j += i)&#123; is[j] = 0; ma[j] = len; // 在这， 每一次更新， 都是的答案更正确化 &#125; &#125; &#125;&#125;int main()&#123; sushu(1000000); int n; while(~scanf(\"%d\", &amp;n))&#123; printf(\"%d\\n\", ma[n]); &#125; return 0;&#125; 举一反三：如何求出这个最大素因子？根据上面的题我们可知求出了这个最大素因子的编号，我们直接输出pri[ma[i] - 1]就可，当然，根据这个题很容易看出， 要是脱落了这个题呢？ 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"数学","slug":"数学","permalink":"https://solodance.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Sublime_c++配置文件","date":"2020-01-23T13:42:34.811Z","path":"2020/01/23/Sublime_c++配置文件/","text":"蓝总的sublime配置文件 1234567891011121314151617181920212223&#123; \"encoding\": \"utf-8\", \"working_dir\": \"$file_path\", \"shell_cmd\": \"g++ -Wall -std=c++11 \\\".\\\\$file_name\\\" -O2 \\\".\\\\$file_base_name\\\"\", \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\", \"selector\": \"source.c++\", \"variants\": [ &#123; \"name\": \"Run Normal\", \"shell_cmd\": \"g++ \\\"$file\\\" -o \\\"$file_base_name\\\" -std=c++11 -O2 -Wl,--stack=4194304 &amp;&amp; start cmd /c \\\"\\\"$&#123;file_path&#125;/$&#123;file_base_name&#125;\\\" &amp; pause\\\"\" &#125;, &#123; \"name\": \"Run Full Stack\", \"shell_cmd\": \"g++ \\\"$file\\\" -o \\\"$file_base_name\\\" -O2 -Wl,--stack=268435456 &amp;&amp; start cmd /c \\\"\\\"$&#123;file_path&#125;/$&#123;file_base_name&#125;\\\" &amp; pause\\\"\" &#125;, &#123; \"name\": \"Run C++14\", \"shell_cmd\": \"g++ \\\"$file\\\" -o \\\"$file_base_name\\\" -std=c++14 -O2 -Wl,--stack=4194304 &amp;&amp; start cmd /c \\\"\\\"$&#123;file_path&#125;/$&#123;file_base_name&#125;\\\" &amp; pause\\\"\" &#125;, ] &#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"零碎小知识","slug":"零碎小知识","permalink":"https://solodance.top/tags/%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"SDNU-1045.石子合并1和SDNU-1048.石子合并2（区间dp和环形区间dp）","date":"2020-01-23T13:42:34.764Z","path":"2020/01/23/SDNU-1045.石子合并1和SDNU-1048.石子合并2（区间dp和环形区间dp）/","text":"SDNU-1045.石子合并1题目大意题目链接 有n堆石子排成一行，每次选择相邻的两堆石子，将其合并为一堆，记录该次合并的得分为两堆石子个数之和。已知每堆石子的石子个数，求当所有石子合并为一堆时，最小的总得分。 分析妥妥的区间dp。f[i][j] 代表的是合成区间[i, j]的石子最小的分。g(i, j) = sum[j] - sum[i - 1]sum[i] 为前缀和转移方程f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + g(i, k) + g(k + 1, j)) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;const int N = 1e7 + 5;const int INF = 0x3f3f3f3f;int f[1003][1003];int a[1003];int sum[1003];int g(int i, int j)&#123; return sum[j] - sum[i - 1];&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(f, INF, sizeof f); for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; f[i][i] = 0; if (i == 0) sum[i] = a[i]; else sum[i] = sum[i - 1] + a[i]; &#125; int i, j, temp; for (int len = 1; len &lt; n; len++)&#123; //len代表区间的右端点 i = 0, j = len; while(j &lt; n)&#123; for (int k = i; k &lt; j; k ++)&#123; f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + g(i, k) + g(k + 1, j)); &#125; i++, j++; &#125; &#125; cout &lt;&lt; f[0][n - 1] &lt;&lt; \"\\n\"; &#125; return 0;&#125; SDNU-1048.石子合并2题目大意题目链接 有n堆石子排成一圈，每次选择相邻的两堆石子，将其合并为一堆，记录该次合并的得分为两堆石子个数之和。已知每堆石子的石子个数，求当所有石子合并为一堆时，最小的总得分。 分析环的话那就把数组copy一遍放在原数组后面， 取结果的话， 就从0~n - 1到 n - 1 ~ 2 * n - 1， 取个最小值， 因为都有可能。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;const int N = 1e7 + 5;const int INF = 0x3f3f3f3f;int f[1003][1003];int a[1003];int sum[1003];int g(int i, int j)&#123; return sum[j] - sum[i - 1];&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(f, INF, sizeof f); for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; f[i][i] = 0; if (i == 0) sum[i] = a[i]; else sum[i] = sum[i - 1] + a[i]; &#125; for (int i = n; i &lt; 2 * n; i++)&#123; f[i][i] = 0; sum[i] = sum[i - 1] + a[i % n];//这里处理的比较巧妙 &#125; int i, j; for (int len = 1; len &lt; 2 * n; len++)&#123; i = 0, j = len; while(j &lt; 2 * n)&#123; for (int k = i; k &lt; j; k ++)&#123; f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + g(i, k) + g(k + 1, j)); &#125; i++, j++; &#125; &#125; int ans = INF; for (int i = 0; i &lt; n; i++) ans = min(f[i][i + n - 1], ans); cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"区间dp","slug":"区间dp","permalink":"https://solodance.top/tags/%E5%8C%BA%E9%97%B4dp/"}]},{"title":"SDNU-1226.Water problem（思维）","date":"2020-01-23T13:42:34.764Z","path":"2020/01/23/SDNU-1226.Water problem（思维）/","text":"题目大意题目链接 想当年为了看懂这个题意费了好大劲。这题关键还是看懂题意给你4个数 A, B, C, K ,问你 for (sum = A; sum != B; sum += C) 这个循环能执行多少次， 其中n可以加2 ^ k。如果陷入死循环输出FOREVER。 思路判断 (bn - a) % c ?= 0其中 b = b0 + (n - 1) * 2 ^ k.如果 while((bn - a) % c != 0)陷入了死循环， 就输出FOREVER， 如果break了， 就输出(b - a) / c 关键是如何判断陷入死循环， 一开始我是取巧， 如果循环执行了1000次， 就当做陷入了死循环， 莽了一发， 过了。后来去请教大佬， 才知道正确做法。每一次记录(bn - a) % c ， 如果出现相同的， 就陷入了死循环， 其实也就是找循环节。 具体请看AC代码 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8#define debug cout &lt;&lt; \"fuck!\\n\";using namespace std;typedef long long ll;const int N = 1e7 + 5;const int INF = 0x3f3f3f3f;ll p[40];map&lt;ll, int&gt; ma;int main()&#123; ios::sync_with_stdio(0); ll a, b, c; int k; p[0] = 1; for (int i = 1; i&lt;= 32; i++) p[i] = 2 * p[i - 1]; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k)&#123; if (!a &amp;&amp; !b &amp;&amp; !c &amp;&amp; !k) break; ma.clear(); if (b &lt; a) b += p[k]; int flag = 0; while((b - a) % c != 0)&#123; if (ma[(b - a) % c])&#123; flag = 1; break; &#125; ma[(b - a) % c] = 1; b += p[k]; &#125; if (flag) cout &lt;&lt; \"FOREVER\\n\"; else cout &lt;&lt; (b - a) / c &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维题","slug":"思维题","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"}]},{"title":"SDNU-1491.整数划分（三）（动态规划综合应用）","date":"2020-01-23T13:42:34.764Z","path":"2020/01/23/SDNU-1491.整数划分（三）（动态规划综合应用）/","text":"题目大意题目链接每组输入是两个整数n和k。(1 &lt;= n &lt;= 50, 1 &lt;= k &lt;= n)对于输入的 n,k;第一行： 将n划分成若干正整数之和的划分数。第二行： 将n划分成k个正整数之和的划分数。第三行： 将n划分成最大数不超过k的划分数。第四行： 将n划分成若干个 奇正整数之和的划分数。第五行： 将n划分成若干不同整数之和的划分数。第六行： 打印一个空行 题解妥妥的动规， 说一下每一个的转移方程注意 我们编号 a[0] = 1, …a[n - 1] = n… a[i - 1] = i。 因为组成n的正整数不可能超过n 12f[i][j] 表示的是用前i个数字， 组成数字j的方案数f[i][j] += f[i - 1][j - s * i]; 0 &lt;= s &lt;= j / i; j - s * i 中的i 是a[i - 1] 12f[i][j][s] 表示的是 用前i个数字 用了j次 组成数字s 的方案数f2[i][j][s] += f2[i - 1][j - t][s - t * i]; t &lt;= j &amp;&amp; t * i &lt;= s 123f[i][j]表示的是用前i个数字， 组成数字j的方案数//这个和第一个一样， 不一样的是这个是前k个， 第一个是前n个f[i][j] += f[i - 1][j - s * i]; 0 &lt;= s &lt;= j / i; j - s * i 中的i 是a[i - 1] 1234f[i][j]表示的是用前i个数字， 组成数字j的方案数//这个也和第一个差不多， 不过转移方程有些不同f[i][j] = f[i - 1][j]; i为偶数f[i][j] += f[i - 1][j - s * i]; 0 &lt;= s &lt;= j / i; j - s * i 中的i 是a[i - 1] i为奇数 1这就是个01背包 没啥好说的 1千千万万别忘了输出空行， 我因为这个收获了一发pe AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8#define debug cout &lt;&lt; \"fuck!\\n\";using namespace std;typedef long long ll;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;int f1[100][100], f2[100][100][100], f3[100][100], f4[100][100], f5[100] ;int main() &#123; int n, k; while(cin &gt;&gt; n &gt;&gt; k)&#123; // 1. 将n划分成若干正整数之和的划分数。 输出 f[n][n]; memset(f1, 0, sizeof f1); f1[0][0] = 1; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; for (int s = 0; s &lt;= j / i; s++)&#123; f1[i][j] += f1[i - 1][j - s * i]; &#125; &#125; &#125; cout &lt;&lt; f1[n][n] &lt;&lt; \"\\n\"; // 2. 将n划分成k个正整数之和的划分数。 输出f[n][k][n] memset(f2, 0, sizeof f2); f2[0][0][0] = 1; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt;= k; j++)&#123; for (int s = 0; s &lt;= n; s++)&#123; for (int t = 0; t &lt;= j &amp;&amp; t * i &lt;= s; t++)&#123; f2[i][j][s] += f2[i - 1][j - t][s - t * i]; &#125; &#125; &#125; &#125; cout &lt;&lt; f2[n][k][n] &lt;&lt; \"\\n\"; // 3. 将n划分成最大的数不超过k的划分数。 输出f[k][n] memset(f3, 0, sizeof f3); f3[0][0] = 1; for (int i = 1; i &lt;= k; i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; for (int s = 0; s &lt;= j / i; s++)&#123; f3[i][j] += f3[i - 1][j - s * i]; &#125; &#125; &#125; cout &lt;&lt; f3[k][n] &lt;&lt; \"\\n\"; //4. 将n划分成若干个 奇正整数之和的划分数。 memset(f4, 0, sizeof f4); f4[0][0] = 1; for (int i = 1; i &lt;= n; i ++)&#123; for (int j = 0; j &lt;= n; j++)&#123; if (i % 2 == 0)&#123; f4[i][j] = f4[i - 1][j]; continue; &#125; for (int s = 0; s &lt;= j / i; s++)&#123; f4[i][j] += f4[i - 1][j - s * i]; &#125; &#125; &#125; if (n % 2 == 1) cout &lt;&lt; f4[n][n] &lt;&lt; \"\\n\"; else cout &lt;&lt; f4[n - 1][n] &lt;&lt; \"\\n\"; //5. 将n划分成若干不同整数之和的划分数。 输出f5[n] memset(f5, 0, sizeof f5); f5[0] = 1; for (int i = 1; i &lt;= n; i++)&#123; for (int j = n; j &gt;= i; j--)&#123; f5[j] += f5[j - i]; &#125; &#125; cout &lt;&lt; f5[n] &lt;&lt;\"\\n\"; cout &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"动态规划","slug":"动态规划","permalink":"https://solodance.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"SDNU 1473.求先序排列（根据中序后序求先序）","date":"2020-01-23T13:42:34.749Z","path":"2020/01/23/SDNU 1473.求先序排列（根据中序后序求先序）/","text":"题目大意题目链接 给出中序后序求先序， 递归求即可 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;void solve(string s1, string s2) &#123; if (s1.size()) &#123; int num = s1.find(s2[s2.size() - 1]); cout &lt;&lt; s1[num]; solve(s1.substr(0, num), s2.substr(0, num)); solve(s1.substr(num + 1), s2.substr(num, s1.size() - num - 1)); &#125;&#125;string s1, s2;int main() &#123; cin &gt;&gt; s1 &gt;&gt; s2; solve(s1, s2); cout &lt;&lt; '\\n';&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"二叉树的dfs序列","slug":"二叉树的dfs序列","permalink":"https://solodance.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84dfs%E5%BA%8F%E5%88%97/"}]},{"title":"SDNU 1031.字母排序(拓扑排序)","date":"2020-01-23T13:42:34.732Z","path":"2020/01/23/SDNU 1031.字母排序(拓扑排序)/","text":"题目描述题目链接有若干个字母，已知它们中某些字母之间的前后关系，求它们的排列顺序。 Input输入数据包含若干组。每组数据第一行两个整数N（2 &lt;= N &lt;= 26）、M，为字母的个数及已知条件的个数，字母为从A开始的N个字母。N、M均为0表示输入结束。之后M行，为一个条件，格式为：字母&lt;字母，或字母&gt;字母，如A&lt;B，代表A在B的前面，A&gt;B代表A在B的后面。 Output对于每组输入数据，输出包含一行，若确定了字母的顺序，则输出：Sorted sequence determined after xxx relations: yyy…y.若发现了矛盾，则输出：Inconsistency found after xxx relations.若无法确定全部字母的顺序，则输出：Sorted sequence cannot be determined.其中，xxx为已读入的条件的个数，yyy…y为排好序的字母序列。 Sample Input123456789101112134 6A&lt;BA&lt;CB&lt;CC&lt;DB&lt;DA&lt;B3 2A&lt;BB&lt;A26 1A&lt;Z0 0 Sample Output123Sorted sequence determined after 4 relations: ABCD.Inconsistency found after 2 relations.Sorted sequence cannot be determined. 题解初学拓扑， 一开始A了一道简单的题感觉自己要上天了，然后又在自己的oj里找了一题， 想爽一爽 ， 然后一落千丈， 哭叽。好了， 咱们说思路。由于这题让中途输出 第一次出现了问题的序号或者是在某个序号时， 排序就己经完成。 那就自觉的要想到在输入的时候就进行排序， 想法很好， 但是却有些无从下手。注： 首先要明白当某时刻入度为0的结点的个数大于等于2时， 那就不能确定顺序。当个数小于0时， 就是出现了矛盾。除了这些， 其他就好说了， 看代码来详细解释： AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;char, char&gt; P;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;int vis[100], ma[100][100], in[100];string s;int n, m;int topo()&#123; // 每加进一个条件就要拓扑一次 s = \"\"; //拓扑序列， 要是加进某一个条件之后正好完成了此拓扑排序。 将其输出即可， 所以其为全局变量 int now[100]; // 储存此时的所有边的入度 memset(vis, 0, sizeof vis); int to = 0, f = 1, p; // to 入度为0的点的个数, f 标记这些字母是否完成了拓扑排序 // p 指向最后一个入度为0的点， 在下面可以看到， for (int i = 1; i &lt;= n; i++)&#123; now[i] = in[i]; // in 入度 &#125; for (int i = 1; i &lt;= n; i++)&#123; to = 0; // 每一次循环都要找入度为0的点 for (int j = 1; j &lt;= n; j++)&#123; if (!now[j] &amp;&amp; !vis[j])&#123; // to++; p = j; &#125; &#125; if (to == 0) //如果没有入度为0的点， 那就出现了矛盾 return 0; if (to &gt;= 2) // 大于等于两个就有多种情况。说明现在还未排好序， 所以标记个2 f = 2; for (int i = 1; i &lt;= n; i++)&#123; if (ma[p][i]) now[i]--; // 正常套路， 让与p有关的边的入度减一 &#125; vis[p] = 1; s += p + 'A' - 1; &#125; return f; // 返回1或2 具体看下&#125;int main()&#123; char a, b, f; while(cin &gt;&gt; n &gt;&gt; m) &#123; if (!n &amp;&amp; !m) break; memset(in, 0, sizeof in); int flag = 1; memset(ma, 0, sizeof ma); for (int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; a &gt;&gt; f &gt;&gt; b; if(f == '&gt;') swap(a, b); int x = a - 'A' + 1; //这个处理技巧真的妙， 妙不可言 int y = b - 'A' + 1; if (!ma[x][y])&#123; ma[x][y] = 1; in[y]++; &#125; x = topo(); // 这是返回值就排上用场了 if (flag)&#123; // 当flag == 0时， 代表着结果已出， 其他就没必要输出了 if (x == 0)&#123; flag = 0; // 标记flag 这个也很妙呀 printf(\"Inconsistency found after %d relations.\\n\", i); &#125; else if (x == 1)&#123; flag = 0; printf(\"Sorted sequence determined after %d relations: \", i); cout &lt;&lt; s &lt;&lt; \".\\n\"; &#125; &#125; &#125; if (flag) puts(\"Sorted sequence cannot be determined.\"); &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://solodance.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"POJ - 3070Fibonacci （矩阵快速幂+斐波那契）","date":"2020-01-23T13:42:34.717Z","path":"2020/01/23/POJ - 3070Fibonacci （矩阵快速幂+斐波那契）/","text":"题目描述题目链接In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn − 1 + Fn − 2 for n ≥ 2. For example, the first ten terms of the Fibonacci sequence are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, … An alternative formula for the Fibonacci sequence is Given an integer n, your goal is to compute the last 4 digits of Fn. InputThe input test file will contain multiple test cases. Each test case consists of a single line containing n (where 0 ≤ n ≤ 1,000,000,000). The end-of-file is denoted by a single line containing the number −1. OutputFor each test case, print the last four digits of Fn. If the last four digits of Fn are all zeros, print ‘0’; otherwise, omit any leading zeros (i.e., print Fn mod 10000). Sample Input12345099999999991000000000-1 Sample Output12340346266875 Hint 题解就是矩阵快速幂的应用， 目前有两种方法 第一种： 第二种 明显第二种要快一些， 根据评测也是这样。 AC代码第一种方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define esp 1e-6using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e2 + 5;const int M = 1e9 + 5;;const int mod = 1e4;struct Matrix&#123; ll m[N][N];&#125;;Matrix mul(Matrix a, Matrix b, int n, int m)&#123; // a * b n为a的行数， m为b的列数 Matrix c; memset(c.m, 0, sizeof c.m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod ; // 取模在这里取 return c;&#125;Matrix q_pow(Matrix a, ll b, int n) &#123; // a^b n为矩阵大小 Matrix ans; memset(ans.m, 0, sizeof ans.m); for (int i = 1; i &lt;= n; i++) ans.m[i][i] = 1; while(b)&#123; if (b &amp; 1) ans = mul(ans, a, n, n); a = mul(a, a, n, n); b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; Matrix a, b, c; ll k; a.m[1][1] = a.m[1][2] = a.m[2][1] = 1; a.m[2][2] = 0; b.m[1][1] = 1; b.m[1][2] = 0; while(cin &gt;&gt; k)&#123; if (!~k) break; if (k == 0 || k == 1)&#123; cout &lt;&lt; k &lt;&lt; \"\\n\"; continue; &#125; c = q_pow(a, k - 1, 2); c = mul(c, b, 2, 1); cout &lt;&lt; c.m[1][1] &lt;&lt; \"\\n\"; &#125; return 0;&#125; 第二种方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define esp 1e-6using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e2 + 5;const int M = 1e9 + 5;;const int mod = 1e4;struct Matrix&#123; ll m[N][N];&#125;;Matrix mul(Matrix a, Matrix b, int n, int m)&#123; // a * b n为a的行数， m为b的列数 Matrix c; memset(c.m, 0, sizeof c.m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod ; // 取模在这里取 return c;&#125;Matrix q_pow(Matrix a, ll b, int n) &#123; // a^b n为矩阵大小 Matrix ans; memset(ans.m, 0, sizeof ans.m); for (int i = 1; i &lt;= n; i++) ans.m[i][i] = 1; while(b)&#123; if (b &amp; 1) ans = mul(ans, a, n, n); a = mul(a, a, n, n); b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; Matrix a, b, c; ll k; a.m[1][1] = a.m[1][2] = a.m[2][1] = 1; a.m[2][2] = 0; while(cin &gt;&gt; k)&#123; if (!~k) break; if (k == 0 || k == 1)&#123; cout &lt;&lt; k &lt;&lt; \"\\n\"; continue; &#125; c = q_pow(a, k - 1, 2); cout &lt;&lt; c.m[1][1] &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://solodance.top/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://solodance.top/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"POJ - 3061Subsequence（尺取法，模板）","date":"2020-01-23T13:42:34.717Z","path":"2020/01/23/POJ - 3061Subsequence（尺取法，模板）/","text":"题目描述题目链接A sequence of N positive integers (10 &lt; N &lt; 100 000), each of them less than or equal 10000, and a positive integer S (S &lt; 100 000 000) are given. Write a program to find the minimal length of the subsequence of consecutive elements of the sequence, the sum of which is greater than or equal to S. InputThe first line is the number of test cases. For each test case the program has to read the numbers N and S, separated by an interval, from the first line. The numbers of the sequence are given in the second line of the test case, separated by intervals. The input will finish with the end of file. OutputFor each the case the program has to print the result on separate line of the output file.if no answer, print 0. Sample Input12345210 155 1 3 5 10 7 4 9 2 85 111 2 3 4 5 Sample Output1223 题解尺取法模板题 求出前缀和 用两个指针来跑 需要注意的是， 如果sum[n] &lt; k ，那就输出0， （因为这个wa了一发好难受 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;const int mod = 998244353;int a[N];int sum[N];int main()&#123; ios::sync_with_stdio(0); int t, n, k; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; k; sum[0] = 0; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; sum[i] = sum[i - 1] + a[i]; &#125; int head, tail, len = INF; // 头尾指针 head = tail = 1; while(tail &lt;= n &amp;&amp; head &lt;= n)&#123; if (sum[tail] - sum[head - 1] &lt; k)&#123; tail++; &#125; else&#123; len = min(len, tail - head + 1); head++; &#125; &#125; if(len &gt;= INF) cout &lt;&lt; \"0\\n\"; else cout &lt;&lt; len &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"尺取法","slug":"尺取法","permalink":"https://solodance.top/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"https://solodance.top/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"POJ-1456（贪心， 并查集优化）","date":"2020-01-23T13:42:34.717Z","path":"2020/01/23/POJ-1456（贪心， 并查集优化）/","text":"题目链接 PROBLEMA supermarket has a set Prod of products on sale. It earns a profit px for each product x∈Prod sold by a deadline dx that is measured as an integral number of time units starting from the moment the sale begins. Each product takes precisely one unit of time for being sold. A selling schedule is an ordered subset of products Sell ≤ Prod such that the selling of each product x∈Sell, according to the ordering of Sell, completes before the deadline dx or just when dx expires. The profit of the selling schedule is Profit(Sell)=Σ x∈Sellpx. An optimal selling schedule is a schedule with a maximum profit.For example, consider the products Prod={a,b,c,d} with (pa,da)=(50,2), (pb,db)=(10,1), (pc,dc)=(20,2), and (pd,dd)=(30,1). The possible selling schedules are listed in table 1. For instance, the schedule Sell={d,a} shows that the selling of product d starts at time 0 and ends at time 1, while the selling of product a starts at time 1 and ends at time 2. Each of these products is sold by its deadline. Sell is the optimal schedule and its profit is 80. Write a program that reads sets of products from an input text file and computes the profit of an optimal selling schedule for each set of products. InputA set of products starts with an integer 0 &lt;= n &lt;= 10000, which is the number of products in the set, and continues with n pairs pi di of integers, 1 &lt;= pi &lt;= 10000 and 1 &lt;= di &lt;= 10000, that designate the profit and the selling deadline of the i-th product. White spaces can occur freely in input. Input data terminate with an end of file and are guaranteed correct. OutputFor each set of products, the program prints on the standard output the profit of an optimal selling schedule for the set. Each result is printed from the beginning of a separate line. Sample Input12344 50 2 10 1 20 2 30 17 20 1 2 1 10 3 100 2 8 2 5 20 50 10 Sample Output1280185 HintThe sample input contains two product sets. The first set encodes the products from table 1. The second set is for 7 products. The profit of an optimal schedule for these products is 185. 题意： 给出一组数据p，d p是价值,d是这件物品最后卖出去的时间。 问最大价值是多少？ 坑点：不一定非要等到在最后期限才能卖出去， 可以提前卖。（但是能晚卖就晚卖） 思路： 贪心， 按价值排序， 然后再找最合适的一天卖出去（就是从期限开始向前遍历， 如果那个时间没被标记过， 就可以卖） 用并查集优化（还是看的kuangbin的博客 才发现如此神奇的做法）， 这里并查集起到链表的作用。例如： （用f[i] = i 初始化） 给出两组数据 30 5, 20 5 一开始先遇到30 5 这组数据（因为30大 ， 在前面）此时 5的祖先是5 &gt; 0 所以这个可以获得， 并且令5的祖先减一， 也就是4。 然后看第二组数据， 此时5的祖先是4 &gt; 0所以也可以获得。 未用并查集优化的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;struct node&#123; int p, d;&#125;a[N];bool cmp(node x, node y)&#123; return x.p &gt; y.p;&#125;int vis[N];int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= n; i++)&#123; scanf(\"%d%d\", &amp;a[i].p, &amp;a[i].d); &#125; ll ans = 0; sort(a + 1, a + n + 1, cmp); for (int i = 1; i &lt;= n; i++)&#123; for (int j = a[i].d; j &gt;= 1; j--)&#123; // 遍历天数 if (vis[j] == 0)&#123; ans += a[i].p; vis[j] = 1; // 莫忘标记 break; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 并查集优化的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;struct node&#123; int p, d;&#125;a[N];bool cmp(node x, node y)&#123; return x.p &gt; y.p;&#125;int vis[N], f[N];int tofind(int x)&#123; if (f[x] != x)&#123; f[x] = tofind(f[x]); &#125; return f[x];&#125;void init()&#123; memset(vis, 0, sizeof vis); for (int i = 0; i &lt;= N; i++)&#123; f[i] = i; &#125;&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; for (int i = 1; i &lt;= n; i++)&#123; scanf(\"%d%d\", &amp;a[i].p, &amp;a[i].d); &#125; init(); ll ans = 0; sort(a + 1, a + n + 1, cmp); for (int i = 1; i &lt;= n; i++)&#123; int t = tofind(a[i].d); // if (t &gt; 0)&#123; ans += a[i].p; f[t] = t - 1; //注意是对祖先 减一 &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"并查集优化","slug":"并查集优化","permalink":"https://solodance.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96/"},{"name":"贪心","slug":"贪心","permalink":"https://solodance.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"python3在ACM中的一些应用","date":"2020-01-23T13:42:34.717Z","path":"2020/01/23/python3在ACM中的一些应用/","text":"虽然在区域赛中不能用python， 可我还是被简洁强大的Python折服。 输入1234a = input() #默认是字符a, b, c = input()a, b, c = map(int, input().split()) #在一行输入多个整型数a, b, c = map(int, raw_input().split()) # python 2 中的输入4 EOF输入： 123456while True: try: a = input() print(a) except EOFError: break 从句，循环 123456if i &gt;= 0:else :for i in range(3): #注意冒号，相当于 i=0,i=1,i=2for i in range(1,3): #i=1,i=2while i &gt;= 0: 运算符 123and or not #没有 &amp;&amp; || ！,注意一下区别/ #数学上的除// #整除 注释 12# 单行注释 pycharm中的快捷键 ctrl + /''' 注释中间的部分 ''' 列表（数组） 123456789101112131415161718192021222324list = [] #定义list = [0 for i in range(10)] # 初始化一个长度为10且全都为0的列表 （其中0能更换成i或其他）list.append(a) #在数组的末尾添加元素alist.insert(i,a) #i为在哪一个位置插入alist.extend([]) # 把某个列表插到list中，参数是一个列表list.index(a) #在列表中搜索元素a，返回其位置list.index(a,0,5) #在0,5搜索list.remove(a) #删除第一个次出现的alen(list) #列表长度del list #把list在内存中清除del list[1] #把list[1]删除list[1:3] #只是拷贝 list[1],list[2] （3-1=2只有两个元素）list1 = list[:] #列表拷贝list2 = list #只是相等，list变，list2也变，只是指定另一个名字罢了#列表之间的比较 默认从[0]开始list = list1 + list2 # 合并列表list * 3# 列表判断元素a in list a not in listlist.count(a) #a在list中出现的次数list.reserve() #翻转list.sort() list.sort(reserve = true) #从大到小 格式化输出 1print('%d %d %d'%(a, b, c))//这个很坑呀，（在一个括号内进行多个格式化输出） 十分有趣的技巧 输入一个表达式， 求值（eval 的奇妙之处） AC代码： 123456while True: try: s = int(eval(input())) print(s) except EOFError: break","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小技巧","slug":"小技巧","permalink":"https://solodance.top/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"python","slug":"python","permalink":"https://solodance.top/tags/python/"}]},{"title":"POJ - 2912（种类并查集 + 暴力枚举）","date":"2020-01-23T13:42:34.701Z","path":"2020/01/23/POJ - 2912（种类并查集 + 暴力枚举）/","text":"题目链接 题意：有n（n &lt;= 500）个人玩石头剪刀布， 他们被分成固定的三组（一组只能出石头，另一组只能出剪刀， 最后一组只能出布， 当然也可以为空组）， 然后在这些人中有一个judge， 他可以不受规则约束，想出啥就出啥。现在给你m组游戏结果， 问你是否能判断出谁是裁判， 输出对应信息。 分析： 我一开始想着要用并查集去做， 和食物链这题类似， 但是却想不到如何找矛盾。然后搜博客， 发现清一色的暴力 /哭 ，暴力就暴力吧。 按照最后暴力出来的人数：按照题意0人 ： Impossible大于1人 ： Can not determine等于1人： Player %d can be determined to be the judge after %d lines 等于一人的时候就比较复杂了，关键是判断是在第几句话出现的问题， 又一次头大。（按照别人的说法， 是在判断其他人的矛盾的时候， 去那时的一个最大值， 这就有点迷糊了， 等着我真正理解了再来补吧， 哭叽） 还有一点， 三种类看三倍数组 ac代码：（） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;int f[N];struct node&#123; int a, b, f;&#125;no[N];int tofind(int x)&#123; if (f[x] != x) f[x] = tofind(f[x]); return f[x];&#125;void tojoin(int x, int y)&#123; x = tofind(x); y = tofind(y); if (x != y) f[x] = y;&#125;set&lt;int&gt; se;int main()&#123; int n, m; int a, b, k; char c; while(cin &gt;&gt; n &gt;&gt; m)&#123; for (int i = 0; i &lt;= 3 * n; i++)&#123; f[i] = i; &#125; se.clear(); for (int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; a &gt;&gt; c &gt;&gt; b; no[i].a = a, no[i].b = b; if (c == '=') no[i].f = 0; else if (c == '&gt;') no[i].f = 1; else if (c == '&lt;') no[i].f = -1; &#125; int ff = 1, j, pos = 0; for (int i = 0; i &lt; n; i++)&#123; for (j = 0; j &lt;= 3 * n; j++)&#123; f[j] = j; &#125; for (j = 1; j &lt;= m; j++)&#123; a = no[j].a, b = no[j].b, k = no[j].f; if (a != i &amp;&amp; b != i)&#123; /*cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; \"\\n\" &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \"\\n\" &lt;&lt; \"b:\" &lt;&lt; b &lt;&lt; \"\\n\";*/ if (k == 0)&#123; if (tofind(a) == tofind(b + n) || tofind(b) == tofind(a + n))&#123; ff = 0; break; &#125; tojoin(a, b); tojoin(a + n, b + n); tojoin(a + 2 * n, b + 2 * n); &#125; else if (k == 1)&#123; if (tofind(a) == tofind(b) || tofind(a + n) == tofind(b))&#123; ff = 0; break; &#125; tojoin(a, b + n); tojoin(a + n, b + 2 * n); tojoin(a + 2 * n, b); &#125; else if (k == -1)&#123; if (tofind(a) == tofind(b) || tofind(a) == tofind(b + n))&#123; ff = 0; /*if (i == 1)&#123; cout &lt;&lt; \"*****\\n\"; cout &lt;&lt; tofind(a) &lt;&lt; ' ' &lt;&lt; tofind(b + n) &lt;&lt; \"\\n\"; &#125;*/ break; &#125; tojoin(b, a + n); tojoin(b + n, a + 2 * n); tojoin(b + 2 * n, a); &#125; &#125; &#125; if (ff) se.insert(i); else pos = max(pos, j); ff = 1; &#125; k = se.size(); /* set&lt;int&gt;::iterator it; for (it = se.begin(); it != se.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \"**\\n\"; &#125;*/ if (k == 0) puts(\"Impossible\"); else if (k &gt; 1) puts(\"Can not determine\"); else if (k == 1)&#123; printf(\"Player %d can be determined to be the judge after %d lines\\n\", *se.begin(), pos); &#125; &#125; return 0;&#125; 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"暴力枚举","slug":"暴力枚举","permalink":"https://solodance.top/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"},{"name":"种类并查集","slug":"种类并查集","permalink":"https://solodance.top/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"POJ - 2559（单调栈的应用）","date":"2020-01-23T13:42:34.686Z","path":"2020/01/23/POJ - 2559（单调栈的应用）/","text":"题目链接 题目描述A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles: Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram. InputThe input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1&lt;=n&lt;=100000. Then follow n integers h1,…,hn, where 0&lt;=hi&lt;=1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case. OutputFor each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line. Sample Input1237 2 1 4 5 1 3 34 1000 1000 1000 10000 Sample Output1284000 HintHuge input, scanf is recommended. 题解这题算是单调栈典型应用题了吧 题意： 在直方图中找到最大矩阵，并求出其面积。思路： 最直接的想法就是暴力（Brute Force）, 求出某个矩阵的最大左拓展个最大右拓展，但是这样会有很多重复计算的过程， 此时间复杂度是O(n ^ 2) ， 铁定超时。 然后我们的想法就是尽量减少这种重复， 然后就要用单调栈了， 何为单调栈，顾名思义 就是栈内元素是单调的。 单调栈中存两个key值， 这个矩形的高度， 和其最左宽度（向左拓展的最大距离的索引）。 当新元素的高度大于栈顶元素的高度时， 直接入栈。小于等于时， 弹出栈顶元素， 并计算弹出栈顶元素的最大拓展面积， 取最大值， 弹出， 在比较。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;struct node&#123; ll height; int width; node()&#123; height = 0; width = 0; &#125;//初始化， 其实不要也可&#125;;stack &lt;node&gt; st;int main()&#123; int n; node a; while(cin &gt;&gt; n)&#123; if (n == 0) break; ll ans = 0; for (int i = 1; i &lt;= n + 1; i++)&#123; if (i &lt;= n) scanf(\"%lld\", &amp;a.height); else a.height = 0; // 最后加入一个0元素， 使栈全部元素弹出, 巧妙啊 a.width = i; while(!st.empty() &amp;&amp; st.top().height &gt;= a.height) &#123; ans = max(ans, st.top().height * (i - st.top().width)); a.width = st.top().width; st.pop(); &#125; st.push(a); &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"单调栈","slug":"单调栈","permalink":"https://solodance.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"lis总结","date":"2020-01-23T13:42:34.670Z","path":"2020/01/23/lis总结/","text":"O(n ^ 2)鉴于O(n ^ 2)的比较简单（就用了一个简单dp）， 我就直接上代码了。 最长上升子序列：1234567891011121314int dp[N]; // 以a[i] 为结尾的最长上升子序列的长度 int a[i]; //给出的序列int lis()&#123; int len = 0; for (int i = 1; i &lt;= n; i++)&#123; dp[i] = 1; // 初始化 for (int j = 1; j &lt; i; j++)&#123; if (a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + 1); &#125; len = max(len, dp[i]); &#125; return len;&#125; 最长不下降子序列123456789101112int lis()&#123; int len = 0; for (int i = 1; i &lt;= n; i++)&#123; dp[i] = 1; for (int j = 1; j &lt; i; j++)&#123; if (a[j] &lt;= a[i]) // 这里的区别 dp[i] = max(dp[i], dp[j] + 1); &#125; len = max(len, dp[i]); &#125; return len;&#125; 最长下降子序列123456789101112int lis()&#123; int len = 0; for (int i = 1; i &lt;= n; i++)&#123; dp[i] = 1; for (int j = 1; j &lt; i; j++)&#123; if (a[j] &gt; a[i]) // 这里的区别 dp[i] = max(dp[i], dp[j] + 1); &#125; len = max(len, dp[i]); &#125; return len;&#125; 最长不上升子序列123456789101112int lis()&#123; int len = 0; for (int i = 1; i &lt;= n; i++)&#123; dp[i] = 1; for (int j = 1; j &lt; i; j++)&#123; if (a[j] &gt;= a[i]) // 这里的区别 dp[i] = max(dp[i], dp[j] + 1); &#125; len = max(len, dp[i]); &#125; return len;&#125; 打印路径(n ^ 2)123456789101112131415161718192021222324252627void lis_path()&#123; // 最长上升子序列打印路径 int len = 0,pos; //pos记录最长上升子序列的最后一个元素的下标 for (int i = 1; i &lt;= n; i++)&#123; dp[i] = 1; for (int j = 1; j &lt; i; j++)&#123; if (a[j] &lt; a[i] &amp;&amp; dp[i] &lt; dp[j] + 1)&#123; dp[i] = dp[j] + 1; path[i] = j; // path[i] 记录最长上升子序列中a[i]前的索引 if (len &lt; dp[i])&#123; len = dp[i]; pos = i;// 记录最长上升子序列的最后一个元素的下标 &#125; &#125; &#125; // len = max(len, dp[i]); &#125; cout &lt;&lt; len &lt;&lt; \"\\n\"; int ans[1000]; for (int i = len; i &gt;= 1; i --)&#123; // 打印路径 ans[i] = a[pos]; pos = path[pos]; &#125; for (int i = 1; i &lt;= len; i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; \"\\n\";&#125; O(n logn)dp[i]存的是上升子序列长度为i的最小的一位数字这样子dp数组一定是单调的（自己实践下）初始时DP[1] = a[1]， 从i = 2时遍历原数列， 将每个遍历的数与DP数列的末尾进行比较， 如果大于末尾， 则把DP数列长度提1将a[i]放在DP数列的最后， 如果小于末尾那么替换掉DP数列中比a[i]大的第一个数。结束后DP数列的长度就是LIS的长度。 举个例子： 对于序列1,5,8,3,6,7来说，当子序列为1,5,8时，遇到3时，序列已经不能继续变长了。但是，我们可以通过替换，使“整个序列”看上去更小，从而有更大的机会去变长。这样，当替换5-3和替换8-6完成后（此时序列为1,3,6），我们可以在序列末尾添加一个7了。 最长上升子序列：1234567891011int lis()&#123; int len = 1,pos; dp[1] = a[1]; for (int i = 2; i &lt;= n; i++)&#123; if (a[i] &gt; dp[len]) dp[++len] = a[i]; else *lower_bound(dp + 1, dp + len + 1, a[i]) = a[i]; &#125; return len;&#125; 最长不下降子序列1234567891011int lis()&#123; int len = 1,pos; dp[1] = a[1]; for (int i = 2; i &lt;= n; i++)&#123; if (a[i] &gt;= dp[len]) // here dp[++len] = a[i]; else *upper_bound(dp + 1, dp + len + 1, a[i]) = a[i]; // here, 为什么用upper_bound呢 ， 因为咱们要替换的是大于a[i] 的数 &#125; return len;&#125; 最长下降子序列1234567891011int lis()&#123; int len = 1,pos; dp[1] = a[1]; for (int i = 2; i &lt;= n; i++)&#123; if (a[i] &lt; dp[len]) // here dp[++len] = a[i]; else *lower_bound(dp + 1, dp + len + 1, a[i], greater&lt;int&gt;() ) = a[i]; // here &#125; return len;&#125; 最长不上升子序列1234567891011int lis()&#123; int len = 1,pos; dp[1] = a[1]; for (int i = 2; i &lt;= n; i++)&#123; if (a[i] &lt;= dp[len]) // here dp[++len] = a[i]; else *upper_bound(dp + 1, dp + len + 1, a[i], greater&lt;int&gt;() ) = a[i]; // here &#125; return len;&#125; 打印路径（n logn）12345678910111213141516171819202122232425262728void lis_path()&#123; // 最长上升子序列， 改成其他和上面一样改 int len = 1; dp[1] = a[1]; path[1] = 1; for (int i = 2; i &lt;= n; i++)&#123; if (a[i] &gt; dp[len])&#123; dp[++len] = a[i]; path[i] = len; &#125; else&#123; int cnt = lower_bound(dp + 1, dp + len + 1, a[i]) - dp; path[i] = cnt; dp[cnt] = a[i]; &#125; &#125; cout &lt;&lt; len &lt;&lt; \"\\n\"; int cnt = len; for (int i = n; i &gt;= 1; i--)&#123; if (path[i] == cnt) ans[cnt--] = a[i]; if (cnt == 0) break; &#125; for (int i = 1; i &lt;= len; i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; \" \"; &#125; putchar(10);&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"lis","slug":"lis","permalink":"https://solodance.top/tags/lis/"}]},{"title":"linux，ubuntu下对拍","date":"2020-01-23T13:42:34.654Z","path":"2020/01/23/linux，ubuntu下对拍/","text":"数据生成器 data.cpp12345678910111213// data.cpp#include&lt;bits/stdc++.h&gt;using namespace std;#define ra(a, b) ((a) + rand() % ((b) - (a) + 1))int main()&#123; freopen(\"data.in\", \"w\", stdout); srand((unsigned int)time(NULL)); int a = ra(1, 100), b =ra(1, 100); cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \"\\n\"; fclose(stdout);&#125; 自己的代码 my.cpp1234567891011// my.cpp#include &lt;bits/stdc++.h&gt;int main()&#123; // 注意有下面这两行即可， 其他正常 freopen(\"data.in\", \"r\", stdin); freopen(\"my.out\", \"w\", stdout); int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 标准代码 std.cpp1234567891011// std.cpp#include &lt;bits/stdc++.h&gt;int main()&#123; // 注意有下面这两行即可， 其他正常 freopen(\"data.in\", \"r\", stdin); freopen(\"my.out\", \"w\", stdout); int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 对拍程序 duipai.cpp1234567891011121314151617// duipai.cpp#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; for (int i=1;;i++)&#123; printf(\"The result of No. %d Case is: \",i); system(\"./data\"); system(\"./std\"); system(\"./my\"); if (system(\"diff std.out my.out\"))&#123; printf(\"Wrong Answer\\n\"); return 0; &#125; else printf(\"Accepted\\n\"); &#125; return 0;&#125; g++ 的一些操作命令12345678910// 编译g++ data.cpp -o datag++ my.cpp -o myg++ std.cpp -o stdg++ duipai.cpp -o p// 运行./p// 开c++11g++ -std=c++11 1.cpp 1234g++ -std=c++11 data.cpp -o datag++ -std=c++11 my.cpp -o myg++ -std=c++11 std.cpp -o stdg++ -std=c++11 duipai.cpp -o p 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://solodance.top/tags/ubuntu/"},{"name":"对拍","slug":"对拍","permalink":"https://solodance.top/tags/%E5%AF%B9%E6%8B%8D/"}]},{"title":"LightOJ - 1258 Making Huge Palindromes （马拉车的应用）","date":"2020-01-23T13:42:34.639Z","path":"2020/01/23/LightOJ - 1258 Making Huge Palindromes （马拉车的应用）/","text":"题目描述题目链接 A string is said to be a palindrome if it remains same when read backwards. So, ‘abba’, ‘madam’ both are palindromes, but ‘adam’ is not. Now you are given a non-empty string S, containing only lowercase English letters. The given string may or may not be palindrome. Your task is to make it a palindrome. But you are only allowed to add characters at the right side of the string. And of course you can add any character you want, but the resulting string has to be a palindrome, and the length of the palindrome should be as small as possible. For example, the string is ‘bababa’. You can make many palindromes including bababababab babababab bababab Since we want a palindrome with minimum length, the solution is ‘bababab’ cause its length is minimum. InputInput starts with an integer T (≤ 10), denoting the number of test cases. Each case starts with a line containing a string S. You can assume that 1 ≤ length(S) ≤ 106. OutputFor each case, print the case number and the length of the shortest palindrome you can make with S. Sample Input123454bababababapqrsmadamimadamanncbaaababaaa Sample Output1234Case 1: 11Case 2: 7Case 3: 11Case 4: 19 NoteDataset is huge, use faster I/O methods. 题解题目大意是给你n个字符串， 让你至少补多少个字母， 能使其成为回文串， 并输出补充之后的字符串的长度最短 要是不明白马拉车的实现原理， 那就给你推荐两篇博客：博客1博客2 就是用马拉车求包含最后一个字符的最长回文串， 那就在马拉车那里动手脚咯， 详情请看代码注释 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;char s[3 * N], str[3 * N];int len[3 * N], l;void init()&#123; int cnt = 0; str[cnt++] = '$'; for (int i = 0; i &lt; l; i++)&#123; str[cnt++] = '#'; str[cnt++] = s[i]; &#125; str[cnt++] = '#'; l = cnt;&#125;int manacher()&#123; int mx = 0, id = 0; int ans = 0; len[0] = 1; for (int i = 1; i &lt; l; i++)&#123; if (i &lt; mx) len[i] = min(len[2 *id - i], mx - i); else len[i] = 1; while(str[i - len[i]] == str[i + len[i]]) len[i] ++; if (i + len[i] &gt; mx)&#123; id = i; mx = i + len[i]; // 更新这里的时候， 不更新ans了 &#125; if (i + len[i] &gt;= l) // 这是关键点， 当mx大于这个字符串长度的时候， 就说明这就是包含最后一个字符的最长回文串了 return len[i] - 1; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; s; l = strlen(s); int l1 = l; init(); printf(\"Case %d: %d\\n\", i, 2 * l1 - manacher()); &#125;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"Manacher","slug":"Manacher","permalink":"https://solodance.top/tags/Manacher/"}]},{"title":"LightOJ - 1356Prime Independence（质因数分解+二分图匹配  最大独立集）","date":"2020-01-23T13:42:34.639Z","path":"2020/01/23/LightOJ - 1356Prime Independence（质因数分解+二分图匹配）/","text":"题目大意题目链接 A set of integers is called prime independent if none of its member is a prime multiple of another member. An integer a is said to be a prime multiple of b if, a = b x k (where k is a prime [1]) So, 6 is a prime multiple of 2, but 8 is not. And for example, {2, 8, 17} is prime independent but {2, 8, 16} or {3, 6} are not. Now, given a set of distinct positive integers, calculate the largest prime independent subset. InputInput starts with an integer T (≤ 20), denoting the number of test cases. Each case starts with an integer N (1 ≤ N ≤ 40000) denoting the size of the set. Next line contains N integers separated by a single space. Each of these N integers are distinct and between 1 and 500000 inclusive. OutputFor each case, print the case number and the size of the largest prime independent subset. Sample Input1234567352 4 8 16 3252 3 4 6 931 2 3 Sample Output123Case 1: 3Case 2: 3Case 3: 2 分析题意 ： 找出一个集合中的最大独立集，任意两数字之间不能是素数倍数的关系。这题最关键是如何建边 ： 如果这两个数是素数倍数关系， 那么这两个数的质因数的个数肯定一个是奇数个， 一个是偶数个， 这么建边。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define ms(a, b) memset((a), (b), sizeof(a))typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 4e4 + 5;const int M = 5e5 + 5;const int INF = 0x3f3f3f3f;const ll ll_max = 4557430888798830399;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = 1;ch = getchar();&#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123;res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0';ch = getchar();&#125; return f ? (~ res + 1) : res;&#125;int vis[N];int match[N];vector&lt;int&gt;fac[N];int pos[M];int cnt[N];struct edge &#123; int u, v, ne;&#125; ed[M];int head[M], cnt1;int a[N], n;int pri[M];bool is[M];int num = 0;void is_pri(int n)&#123; ms(is, true); is[1] = is[0] = false; for (int i = 2; i &lt;= n; ++i)&#123; if (is[i]) pri[++num] = i; for (int j = 1; j &lt;= num &amp;&amp; i * pri[j] &lt;= n; ++j)&#123; is[i * pri[j]] = false; if (i % pri[j] == 0) break; &#125; &#125;&#125;inline void add(int u, int v) &#123; ed[cnt1] = &#123;u, v, head[u]&#125;; head[u] = cnt1++;&#125;int tofind(int u, int sgn) &#123; // 二分图匹配 for (int i = head[u]; ~i; i = ed[i].ne) &#123; int v = ed[i].v; // if (match[u]) continue; if (vis[v] != sgn) &#123; vis[v] = sgn; if (!match[v] || tofind(match[v], sgn)) &#123; match[v] = u; // match[u] = v; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int t; is_pri(500000); // cout &lt;&lt; num &lt;&lt; \"\\n\"; t = read(); for (int tt = 1; tt &lt;= t; ++tt) &#123; n = read(); ms(head, -1); for (int i = 1; i &lt;= n; ++i) &#123; int tmp; tmp = a[i] = read(); // ↓ 分解质因数 pos[tmp] = i; for (int p = 1; p &lt;= num &amp;&amp; pri[p] * pri[p] &lt;= tmp; ++p) &#123; if (tmp % pri[p] == 0) &#123; fac[i].push_back(pri[p]); while(tmp % pri[p] == 0) tmp /= pri[p], ++cnt[i]; &#125; &#125; if (tmp &gt; 1) fac[i].push_back(tmp), ++cnt[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int L = fac[i].size(); for (int j = 0; j &lt; L; ++j) &#123; int k = pos[a[i] / fac[i][j]]; // 如果存在这个数的话 if (k) &#123; if (cnt[i] &amp; 1) add(i, k); // 如果i的质因子的个数是奇数个 else add(k, i); // 否则k的质因子个数为奇数个 &#125; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (tofind(i, i)) ans += 1; &#125; printf(\"Case %d: %d\\n\", tt, n - ans); for (int i = 1; i &lt;= n; ++i) &#123; pos[a[i]] = 0; vis[i] = cnt[i] = pos[i] = match[i] = cnt1 = 0; fac[i].clear(); &#125; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"二分图","slug":"二分图","permalink":"https://solodance.top/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"最大独立集","slug":"最大独立集","permalink":"https://solodance.top/tags/%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/"}]},{"title":"KMP总结","date":"2020-01-23T13:42:34.623Z","path":"2020/01/23/KMP总结/","text":"模板先贴一段代码：当做模板即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;int nxt[N];int m, n;string s, t;void get_next()&#123; nxt[0] = -1; //默认下标都是从0开始的 int i = 1, j = 0; // 因为nxt[0] 已经初始化成 -1 了 ， 所以i从1开始 while(i &lt; m)&#123; if (j == -1 || t[i] == t[j])&#123; i++, j++; if (t[i] != t[j]) nxt[i] = j; else nxt[i] = nxt[j]; &#125; else j = nxt[j]; &#125;&#125;int kmp()&#123; int i = 0, j = 0; n = s.length(); m = t.length(); while(i &lt; n &amp;&amp; j &lt; m)&#123; if (j == -1 || s[i] == t[j]) i++, j++; else j = nxt[j]; &#125; if (j &gt;= m) return i - m + 1; // 根据自己的输入输出灵活变通 return -1;&#125;int main()&#123; int T; scanf(\"%d\", &amp;T); while(T--)&#123; cin &gt;&gt; s &gt;&gt; t; get_next(); printf(\"%d\\n\", kmp()); &#125; return 0;&#125; 可以看一下这个例题题目链接 应用 统计模式串在母串中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define esp 1e-6using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;int nxt[N];char s[N], t[N];void get_next()&#123; int i = 1, j = 0; nxt[0] = -1; while(i &lt; strlen(s))&#123; if (j == -1 || s[i] == s[j])&#123; i ++, j++; if (s[i] != s[j]) nxt[i] = j; else nxt[i] = nxt[j]; &#125; else j = nxt[j]; &#125;&#125;int cnt = 0;void kmp()&#123; int n = strlen(t); int m = strlen(s); int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m)&#123; if (j == -1 || t[i] == s[j])&#123; i++, j++; &#125; else &#123; j = nxt[j]; &#125; if (j == m)&#123; cnt++; j = nxt[j]; // 这里很奇妙， 可以自己想一想 &#125; &#125;&#125;int main()&#123; int T; scanf(\"%d\", &amp;T); while(T--)&#123; cnt = 0; scanf(\"%s%s\", s, t); get_next(); kmp(); printf(\"%d\\n\", cnt); &#125; return 0;&#125; 同样附上一个例题：题目链接 暂且先写这些， 其他以后再补其实我复习kmp的目的是为了更好的理解AC自动机， 嘿嘿 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"KMP","slug":"KMP","permalink":"https://solodance.top/tags/KMP/"},{"name":"总结","slug":"总结","permalink":"https://solodance.top/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"int128模板","date":"2020-01-23T13:42:34.608Z","path":"2020/01/23/int128模板/","text":"int128的使用提示1： 在windows下 用mingw64可以编译int128提示2： devc++自带mingw64, codeblocks自带mingw32 。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline __int128 read() &#123; __int128 x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;inline void write(__int128 x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int main() &#123; __int128 a = read(); write(a); return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"总结","slug":"总结","permalink":"https://solodance.top/tags/%E6%80%BB%E7%BB%93/"},{"name":"int128","slug":"int128","permalink":"https://solodance.top/tags/int128/"}]},{"title":"HDU-2874Connections between cities（lca模板题,注意是森林）","date":"2020-01-23T13:42:34.592Z","path":"2020/01/23/HDU-2874Connections between cities（lca模板题,注意是森林）/","text":"题目大意题目链接After World War X, a lot of cities have been seriously damaged, and we need to rebuild those cities. However, some materials needed can only be produced in certain places. So we need to transport these materials from city to city. For most of roads had been totally destroyed during the war, there might be no path between two cities, no circle exists as well.Now, your task comes. After giving you the condition of the roads, we want to know if there exists a path between any two cities. If the answer is yes, output the shortest path between them. InputInput consists of multiple problem instances.For each instance, first line contains three integers n, m and c, 2&lt;=n&lt;=10000, 0&lt;=m&lt;10000, 1&lt;=c&lt;=1000000. n represents the number of cities numbered from 1 to n. Following m lines, each line has three integers i, j and k, represent a road between city i and city j, with length k. Last c lines, two integers i, j each line, indicates a query of city i and city j. OutputFor each problem instance, one line for each query. If no path between two cities, output “Not connected”, otherwise output the length of the shortest path between them. Sample Input1234565 3 21 3 22 4 35 2 31 44 5 Sample Output12Not connected6 分析在森林中求lca。用并查集判断两个点是不是在同一棵树中。用tarjan离线一直mle。。。无语了， 最后用的倍增才过的。第一次遇到用时间换空间的题。。。 倍增ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;#define ms(a, b) memset((a), (b), sizeof(a))const int N = (int)1e5 + 5;const int INF = 0x3f3f3f3f;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge&#123; int u, v, w, ne;&#125;ed[N];int head[N], dis[N], cnt, n, m;int deep[N], fa[N][20];inline void init()&#123; ms(head, -1); cnt = 0; ms(deep, 0); ms(dis, 0);&#125;inline void add(int u, int v, int w)&#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125;inline void dfs(int u, int pre)&#123; deep[u] = deep[pre] + 1; // deep数组表示深度 fa[u][0] = pre; // fa[i][j] 表示i的第2^j辈的祖先 for (int i = 1; i &lt; 20; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; // fa[i][j] = fa[fa[i][j - 1]][j - 1] i的第2^j辈的祖先 等于 i的第2^(j-1)辈的祖先的第2^(j-1)辈的祖先 for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v; if(v == pre) continue; dis[v] = dis[u] + ed[i].w; dfs(v, u); &#125;&#125;inline int lca(int a, int b)&#123; if (deep[a] &lt; deep[b]) swap(a, b); // 运用二进制的思想 使得deep[a] == deep[b] 比如 7 可以用4 2 1表示 for (int i = 19; i &gt;= 0; --i) if (deep[a] - (1 &lt;&lt; i) &gt;= deep[b]) a = fa[a][i]; if (a == b) return a; // 倍增 2^k 步的爬, 找最小的满足 a != b 的 for (int i = 19; i &gt;= 0; --i)&#123; if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; &#125; return fa[a][0];&#125;int t, u, v, w;int main()&#123; t = read(); while(t--)&#123; n = read(), m = read(); init(); for (int i = 1; i &lt; n; ++i)&#123; u = read(), v = read(), w = read(); add(u, v, w); add(v, u, w); &#125; dfs(1, 0); while(m--)&#123; u = read(), v = read(); int x = lca(u, v); printf(\"%d\\n\", dis[u] + dis[v] - 2 * dis[x]); &#125; &#125; return 0;&#125; tarjan MLE代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;#define ms(a, b) memset((a), (b), sizeof(a))const int N = (int)1e4 + 5;const int M = (int)1e6 + 10;const int INF = 0x3f3f3f3f;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge &#123; int u, v, w, ne;&#125;ed[N &lt;&lt; 1], eq[M &lt;&lt; 1]; // ed存边 eq离线存询问int head[N], f[N], hq[N];int dis[N], ans[N];int vis[N];int cnt, n, m, cnt1;void init()&#123; cnt = cnt1 = 0; for (int i = 0; i &lt;= n; ++i)&#123; f[i] = i; &#125; ms(head, -1); ms(hq, -1); ms(vis, 0); ms(ans, 0); ms(dis, -1);&#125;inline void add(int &amp;u, int &amp;v, int &amp;w)&#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125;inline void addq(int &amp;u, int &amp;v, int &amp;id)&#123; eq[cnt1] = &#123;u, v, id, hq[u]&#125;; // 在结构体里虽然还是w， 但是咱们用它表示id hq[u] = cnt1++;&#125;inline int tofind(int &amp;x)&#123; return (f[x] == x) ? f[x] : (f[x] = tofind(f[x]));&#125;inline void tojoin(int &amp;a, int &amp;b)&#123; a = tofind(a); b = tofind(b); if (a != b) f[b] = a;&#125;void tarjan(int &amp;u, int sgn)&#123; // 分为两部分， 第一部分 建树 第二部分 求ans // 第一部分， 建树 vis[u] = sgn; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int &amp;v = ed[i].v, &amp;w = ed[i].w; if (vis[v] == sgn) continue; dis[v] = dis[u] + w; // v到根结点的距离 tarjan(v, sgn); f[v] = u; // 这里直接连上(f[v] = u)就行, &#125; for (int i = hq[u]; ~i; i = eq[i].ne)&#123; // 与u相关的边 int &amp;v = eq[i].v, &amp;id = eq[i].w; if (vis[v] != sgn + 1) continue; // 2 是以为这离线过了的点 int lca = tofind(v); if (dis[v] != -1) ans[id] = dis[u] + dis[v] - 2 * dis[lca]; &#125; vis[u] = sgn + 1;&#125;int t, u, v, w;int main()&#123; int q; while(~scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q))&#123; init(); // init 要放在n之后， 因为这个又被卡了好长时间。。。。。。 for (int i = 1; i &lt;= m; ++i)&#123; u = read(), v = read(), w = read(); add(u, v, w); add(v, u, w); &#125; for (int i = 0; i &lt; q; ++i)&#123; u = read(), v = read(); addq(u, v, i); addq(v, u, i); &#125; for (int i = 1; i &lt;= n; ++i)&#123; if (!vis[i]) tarjan(i, 2 * i); &#125; for (int i = 0; i &lt; q; ++i)&#123; if (!ans[i]) puts(\"Not connected\"); else printf(\"%d\\n\", ans[i]); &#125; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"lca","slug":"lca","permalink":"https://solodance.top/tags/lca/"}]},{"title":"HDU-5879（打表 + 找规律）","date":"2020-01-23T13:42:34.592Z","path":"2020/01/23/HDU-5879（打表 + 找规律）/","text":"题目描述：题目链接 Given an integer n, we only want to know the sum of 1/（k * k） where k from 1 to n. InputThere are multiple cases.For each test case, there is a single line, containing a single positive integer n.The input file is at most 1M. OutputThe required sum, rounded to the fifth digits after the decimal point. Sample Input12345124815 Sample Output123451.000001.250001.423611.527421.58044 题解：需要注意的问题： 计算sum的时候不要1.0 / (i * i)这样计算， 要1.0 / i / i这样计算。 题目中没说n额具体范围， 只说了n &gt;= 0 那就认为n无限大， 用字符串存储， 也同时意味着有规律可寻。 ac代码：12345678910111213141516171819202122232425262728293031323334353637//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int N = 1e6 + 5;const int M = 1e9 + 5;double a[N];int main()&#123; a[1] = 1; for (int i = 2; i &lt; N; i++)&#123; a[i] = a[i - 1] + double(1.0 / i / i); &#125; string n; while(cin &gt;&gt; n)&#123; if (n.size() &gt;= 7) printf(\"%.5f\\n\",a[N - 1]); else&#123; int m = atoi(n.c_str());// 将字符串转化为整型 printf(\"%.5f\\n\",a[m]); &#125; &#125;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"打表","slug":"打表","permalink":"https://solodance.top/tags/%E6%89%93%E8%A1%A8/"},{"name":"找规律","slug":"找规律","permalink":"https://solodance.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}]},{"title":"hexo遇到的各种坑","date":"2020-01-23T13:42:34.592Z","path":"2020/01/23/hexo遇到的各种坑/","text":"执行hexo d 命令时出现 Untracked files 错误同时当你部署完成之后， 虽然你的博客里有了， 但是点进去就是404解决方案： 把你即将要上传的文件的文件名中的空格删掉就可以了。 修改hexo sitemap 生成插件中的链接模板在hexo-generator-sitemap 和 hexo-generator-baidu-sitemap生成的站点地图里面链接全是https://username.github.io/(post.path).但是我想分别做coding.me 和 github.io，所以只需要更改一下sitemap插件的模板就可以了。 *hexo-generator-sitemap 的模板 *默认是blog\\node_modules\\hexo-generator-sitemap\\sitemap.xml，url的默认格式是： 1&lt;loc&gt;&#123;&#123; post.permalink | uriencode &#125;&#125;&lt;/loc&gt; 修改为 1&lt;loc&gt;&#123;&#123; \"https://chalkit.ml/\" + post.path | uriencode &#125;&#125;&lt;/loc&gt; 域名要加””变成字符串，不然deploy的时候会报错 hexo-generator-baidu-sitemap的模板是\\blog\\node_modules\\hexo-generator-baidu-sitemap\\baidusitemap.ejs，其中url的默认格式是： 1&lt;loc&gt;&lt;%- encodeURI(url + post.path) %&gt;&lt;/loc&gt; 修改为 1&lt;loc&gt;&lt;%- encodeURI(\"https://chalkit.tk/\" + post.path) %&gt;&lt;/loc&gt; 域名要加””变成字符串，不然deploy的时候会报错 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"}]},{"title":"HDU-2586How far away ？(lca模板)","date":"2020-01-23T13:42:34.576Z","path":"2020/01/23/HDU-2586How far away ？(lca模板)/","text":"题目大意题目链接There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this “How far is it if I want to go from house A to house B”? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(“simple” means you can’t visit a place twice) between every two houses. Yout task is to answer all these curious people. InputFirst line is a single integer T(T&lt;=10), indicating the number of test cases. For each test case,in the first line there are two numbers n(2&lt;=n&lt;=40000) and m (1&lt;=m&lt;=200),the number of houses and the number of queries. The following n-1 lines each consisting three numbers i,j,k, separated bu a single space, meaning that there is a road connecting house i and house j,with length k(0&lt;k&lt;=40000).The houses are labeled from 1 to n. Next m lines each has distinct integers i and j, you areato answer the distance between house i and house j. OutputFor each test case,output m lines. Each line represents the answer of the query. Output a bland line after each test case. Sample Input123456789101123 21 2 103 1 151 22 32 21 2 1001 22 1 Sample Output12341025100100 分析求树上两点最短距离， lca模板， 就是试试自己的板子。 离线tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;#define ms(a, b) memset((a), (b), sizeof(a))const int N = (int)1e5 + 5;const int INF = 0x3f3f3f3f;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge &#123; int u, v, w, ne;&#125;ed[N], eq[N]; // ed存边 eq离线存询问int head[N], f[N], hq[N];int dis[N], ans[N];int vis[N];int cnt, n, m, cnt1;void init()&#123; cnt = cnt1 = 0; for (int i = 0; i &lt;= n; ++i)&#123; f[i] = i; &#125; ms(head, -1); ms(hq, -1); ms(dis, 0); ms(vis, 0);&#125;inline void add(int u, int v, int w)&#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125;inline void addq(int u, int v, int id)&#123; eq[cnt1] = &#123;u, v, id, hq[u]&#125;; // 在结构体里虽然还是w， 但是咱们用它表示id hq[u] = cnt1++;&#125;inline int tofind(int x)&#123; return (f[x] == x) ? f[x] : (f[x] = tofind(f[x]));&#125;inline void tojoin(int a, int b)&#123; a = tofind(a); b = tofind(b); if (a != b) f[b] = a;&#125;void tarjan(int u)&#123; // 分为两部分， 第一部分 建树 第二部分 求ans // 第一部分， 建树 vis[u] = 1; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int &amp;v = ed[i].v, &amp;w = ed[i].w; if (vis[v]) continue; dis[v] = dis[u] + w; // v到根结点的距离 tarjan(v); tojoin(u, v); // 这里直接连上(f[v] = u)就行, &#125; for (int i = hq[u]; ~i; i = eq[i].ne)&#123; // 与u相关的边 int &amp;v = eq[i].v, &amp;id = eq[i].w; if (vis[v] != 2) continue; // 2 是以为这离线过了的点 int lca = tofind(v); ans[id] = dis[u] + dis[v] - 2 * dis[lca]; // 两点树上最小距离：即根到两点距离-两倍到其最近公共祖先距离 &#125; vis[u] = 2;&#125;int t, u, v, w;int main()&#123; t = read(); while(t--)&#123; n = read(), m = read(); init(); // init 要放在n之后， 因为这个又被卡了好长时间。。。。。。 for (int i = 1; i &lt; n; ++i)&#123; u = read(), v = read(), w = read(); add(u, v, w); add(v, u, w); &#125; for (int i = 0; i &lt; m; ++i)&#123; u = read(), v = read(); addq(u, v, i); addq(v, u, i); &#125; tarjan(1); for (int i = 0; i &lt; m; ++i)&#123; printf(\"%d\\n\", ans[i]); &#125; &#125; return 0;&#125; 在线 倍增法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;#define ms(a, b) memset((a), (b), sizeof(a))const int N = (int)1e5 + 5;const int INF = 0x3f3f3f3f;inline int read() &#123; int res = 0;bool f = 0;char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;struct edge&#123; int u, v, w, ne;&#125;ed[N];int head[N], dis[N], cnt, n, m;int deep[N], fa[N][20];inline void init()&#123; ms(head, -1); cnt = 0; ms(deep, 0); ms(dis, 0);&#125;inline void add(int u, int v, int w)&#123; ed[cnt] = &#123;u, v, w, head[u]&#125;; head[u] = cnt++;&#125;inline void dfs(int u, int pre)&#123; deep[u] = deep[pre] + 1; // deep数组表示深度 fa[u][0] = pre; // fa[i][j] 表示i的第2^j辈的祖先 for (int i = 1; i &lt; 20; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; // fa[i][j] = fa[fa[i][j - 1]][j - 1] i的第2^j辈的祖先 等于 i的第2^(j-1)辈的祖先的第2^(j-1)辈的祖先 for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v; if(v == pre) continue; dis[v] = dis[u] + ed[i].w; dfs(v, u); &#125;&#125;inline int lca(int a, int b)&#123; if (deep[a] &lt; deep[b]) swap(a, b); // 运用二进制的思想 使得deep[a] == deep[b] 比如 7 可以用4 2 1表示 for (int i = 19; i &gt;= 0; --i) if (deep[a] - (1 &lt;&lt; i) &gt;= deep[b]) a = fa[a][i]; if (a == b) return a; // 倍增 2^k 步的爬, 找最小的满足 a != b 的 for (int i = 19; i &gt;= 0; --i)&#123; if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; &#125; return fa[a][0];&#125;int t, u, v, w;int main()&#123; t = read(); while(t--)&#123; n = read(), m = read(); init(); for (int i = 1; i &lt; n; ++i)&#123; u = read(), v = read(), w = read(); add(u, v, w); add(v, u, w); &#125; dfs(1, 0); while(m--)&#123; u = read(), v = read(); int x = lca(u, v); printf(\"%d\\n\", dis[u] + dis[v] - 2 * dis[x]); &#125; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"lca","slug":"lca","permalink":"https://solodance.top/tags/lca/"}]},{"title":"HDU-2222 Keywords Search（AC自动机+模板题）","date":"2020-01-23T13:42:34.561Z","path":"2020/01/23/HDU-2222 Keywords Search（AC自动机+模板题）/","text":"题目描述题目链接 In the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match. InputFirst line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. (N &lt;= 10000)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than 1000000. OutputPrint how many keywords are contained in the description. Sample Input1234567815shehesayshrheryasherhs Sample Output13 题解就是一个模板题， 直接上代码， 若想看详细解释请看这篇博客 AC代码（指针版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//#include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define esp 1e-6using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e9 + 5;struct node&#123; struct node *fail; // 这个节点的fail指针 node *next[30]; // 这个节点的儿子节点 int count; // 这个节点是不是单词的末尾节点（数量） node()&#123; fail = NULL; count = 0; memset(next, NULL, sizeof next); &#125;&#125;*q[N];char keyword[N]; // 输入的单词char str[N]; // 模式串int tail, head;void build_Trie(char *str, node *root)&#123; // 构建trie node *p = root; int i = 0, index; while(str[i])&#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(); // 不加括号应该也行吧 p = p-&gt;next[index]; i++; &#125; p-&gt;count++;&#125;void build_ac_automation(node *root)&#123; root-&gt;fail = NULL; q[head++] = root; while(head != tail)&#123; node *temp = q[tail++]; node *p = NULL; for (int i =0; i &lt; 26; i++)&#123; if (temp-&gt;next[i] != NULL)&#123; if (temp == root) temp-&gt;next[i]-&gt;fail = root; else&#123; // 父节点的fail 的子节点 p = temp-&gt;fail; while(p != NULL)&#123; if (p-&gt;next[i] != NULL)&#123; temp-&gt;next[i]-&gt;fail = p-&gt;next[i]; break; &#125; p = p-&gt;fail; &#125; if (p == NULL) temp-&gt;next[i]-&gt;fail = root; &#125; q[head++] = temp-&gt;next[i]; &#125; &#125; &#125;&#125;int query(node *root)&#123; int i = 0, cnt = 0, index, len = strlen(str); node *p = root; while(str[i])&#123; index = str[i] - 'a'; while(p-&gt;next[index] == NULL &amp;&amp; p != root) p=p-&gt;fail; p = p-&gt;next[index]; if (!p) p = root; node *temp = p; while(temp != root &amp;&amp; temp-&gt;count != -1)&#123; cnt += temp-&gt;count; temp-&gt;count = -1; temp = temp-&gt;fail; &#125; i++; &#125; return cnt;&#125;int main()&#123; int t, n; scanf(\"%d\", &amp;t); while(t--)&#123; head = tail = 0; scanf(\"%d\", &amp;n); node *root = new node; while(n--)&#123; scanf(\"%s\", keyword); build_Trie(keyword, root); &#125; scanf(\"%s\", str); build_ac_automation(root); printf(\"%d\\n\", query(root)); &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://solodance.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"模板题","slug":"模板题","permalink":"https://solodance.top/tags/%E6%A8%A1%E6%9D%BF%E9%A2%98/"}]},{"title":"HDU2049-不容易系列之(4)——考新郎","date":"2020-01-23T13:42:34.561Z","path":"2020/01/23/HDU2049-不容易系列之(4)——考新郎/","text":"题目大意题目链接 假设一共有N对新婚夫妇,其中有M个新郎找错了新娘,求发生这种情况一共有多少种可能. 就是求 从 n中选m 个然后对m错排 分析错排递推公式： f[i] = (i - 1) * (f[i - 1] + f[i - 2) 假设新来了一对夫妇， 其他i - 1对夫妇错排， 则新来的从i - 1中随便选一个就是(i - 1) * f[i - 1]假设i - 2对夫妇错排， 有一对没有错排， 那么新来的必须和这个交换， 即 (i - 1) * f[i - 2] AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;#define ms(a, b) memset((a), (b), sizeof(a))#define esp 1e-8typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 5e6 + 5;const int INF = 0x3f3f3f3f;const ll ll_max = 4557430888798830399;inline ll read() &#123; ll res = 0; bool f = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = 1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return f ? (~ res + 1) : res;&#125;int t;const int mod = 1e9 + 7;ll c[100][100];void get_c(int maxn)&#123; c[0][0] = 1; for (int i = 1; i &lt;= maxn; ++i)&#123; c[i][0] = 1; for (int j = 1; j &lt;= i; ++j)&#123; c[i][j] = c[i - 1][j] + c[i - 1][j - 1]; &#125; &#125;&#125;ll a, b, ans;ll f[100];int main()&#123; t = read(); get_c(20); f[0] = 0; f[1] = 0; f[2] = 1; f[3] = 2; for (int i = 4; i &lt;= 20; ++i) f[i] = (i - 1) * (f[i - 1] + f[i - 2]); while(t--)&#123; a = read(), b= read(); cout &lt;&lt; c[a][b] * f[b] &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"递推","slug":"递推","permalink":"https://solodance.top/tags/%E9%80%92%E6%8E%A8/"}]},{"title":"HDU - 6719 Strassen（玄学）","date":"2020-01-23T13:42:34.538Z","path":"2020/01/23/HDU - 6719 Strassen（玄学）/","text":"题目大意题目链接在本题中，我们只有两种方法计算两个n×n的矩阵的乘积，第一种为定义法，需要n^3次乘法和(n−1)n^2次加法。第二种为Strassen分治法，仅当n为偶数时可以使用，需要18 * (n/2) * (n/2)次加法以及再计算7次大小为(n/2)×(n/2)的矩阵的乘积。这7次更小矩阵的乘积也可以选择两种方法之一计算。现假设计算机计算一次加法需要a单位时间，计算一次乘法需要b单位时间，其他任何操作不花费时间，问计算两个n×n的矩阵的乘积至少需要多少时间。输出答案模1e9 + 7的余数。Input第一行一个正整数t表示数据组数（1≤t≤20）。每组数据包含一行三个正整数n，a，b（1≤n≤2^32，n是2的幂，1≤a≤1e9，1≤b≤1e9）。Output每组数据输出一行，包含一个整数表示答案模109+7的余数。 分析用__int128直接暴力就行了。int128模板请戳此 还有比较玄学的东西，这样写wa了 这样就a了。。。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8typedef long long ll;typedef unsigned long long ull;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const ull mod = (ull)1e9 + 7;ll a, b, n;__int128 f;inline void wrii(__int128 x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) wrii(x / 10); putchar(x % 10 + '0');&#125;int main()&#123;// std::ios::sync_with_stdio(false);// std::cin.tie(nullptr); int t; __int128 i; std::cin &gt;&gt; t; while(t--)&#123; std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; f = b; for (__int128 i = 1; i &lt;= (__int128)n; i &lt;&lt;= 1)&#123; f = std::min((__int128)(i * i * i * b + (i - 1) * i * i * a), (__int128)((i / 2) * (i / 2) * a * 18 + f * 7)); &#125; f %= mod; wrii(f); std::cout &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"玄学题","slug":"玄学题","permalink":"https://solodance.top/tags/%E7%8E%84%E5%AD%A6%E9%A2%98/"}]},{"title":"HDU - 6714最短路2（dijkstra）","date":"2020-01-23T13:42:34.526Z","path":"2020/01/23/HDU - 6714最短路2（dijkstra）/","text":"题目大意题目链接小 A 是社团里的工具人，有一天他的朋友给了他一个 n 个点，m 条边的正权连通无向图，要他计算所有点两两之间的最短路。 作为一个工具人，小 A 熟练掌握着 floyd 算法，设 w[i][j] 为原图中 (i,j) 之间的权值最小的边的权值，若没有边则 w[i][j]=无穷大。特别地，若 i=j，则 w[i][j]=0。 Floyd 的 C++ 实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143for(int k=1;k&lt;=p;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) w[i][j]=min(w[i][j],w[i][k]+w[k][j]); ``` 当 p=n 时，该代码就是我们所熟知的 floyd，然而小 A 为了让代码跑的更快点，所以想减少 p 的值。 令 Di,j 为最小的非负整数 x，满足当 p=x 时，点 i 与点 j 之间的最短路被正确计算了。 现在你需要求 ∑ni=1∑nj=1Di,j，虽然答案不会很大，但为了显得本题像个计数题，你还是需要将答案对 998244353 取模后输出。**Input**第一行一个正整数 T(T≤30) 表示数据组数 对于每组数据： 第一行两个正整数 n,m(1≤n≤1000,m≤2000)，表示点数和边数。 保证最多只有 5 组数据满足 max(n,m)&gt;200 接下来 m 行，每行三个正整数 u,v,w 描述一条边权为 w 的边 (u,v)，其中 1≤w≤109**Output**输出 T 行，第 i 行一个非负整数表示第 i 组数据的答案### 思路就是求最大松弛点中的最小值， 当时比赛的时候不管怎么样都不能顿悟， 还是太菜了呀。### AC代码```cpp#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8typedef long long ll;const int N = 1e5 + 5;typedef std::pair&lt;ll, int&gt; P;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;const ll mod = 998244353;struct edge&#123; int v; ll w; int ne;&#125;ed[N];int head[1003];bool vis[1003];ll dis[1003];int d[1003][1003];int cnt, m, n;void init()&#123; cnt = 0; memset(head, -1, sizeof head); memset(d, 0, sizeof d);&#125;void addedge(int u, int v, ll w)&#123; ed[cnt].v = v, ed[cnt].w = w; ed[cnt].ne = head[u]; head[u] = cnt++;&#125;std::priority_queue&lt;P, std::vector&lt;P&gt; , std::greater&lt;P&gt; &gt;q;void dijk(int s)&#123; memset(vis, false, sizeof vis); for (int i = 1; i &lt;= n; i++) dis[i] = 1e18; dis[s] = 0; q.push(P(0, s)); while(!q.empty())&#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = ed[i].ne)&#123; int v = ed[i].v; if (dis[v] &gt; dis[u] + ed[i].w)&#123; dis[v] = dis[u] + ed[i].w; q.push(P(dis[v], v)); if (dis[v] == ed[i].w) &#123; d[s][v] = 0; &#125; else &#123; d[s][v] = std::max(d[s][u], u); &#125; &#125; else if (dis[v] == dis[u] + ed[i].w)&#123; d[s][v] = std::min(d[s][v], std::max(u, d[s][u])); &#125; &#125; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false);// std::cin.tie(nullptr); ll ans; int t, u, v; ll w; std::cin &gt;&gt; t; while(t--)&#123; std::cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 0; i &lt; m; i++)&#123; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); addedge(v, u, w); &#125; for (int i = 1; i &lt;= n; i++) dijk(i); ans = 0; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 1; j &lt;= n; j++)&#123; ans = (ans + d[i][j]) % mod; &#125; &#125; std::cout &lt;&lt; ans % mod &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"最短路","slug":"最短路","permalink":"https://solodance.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"dijkstra","slug":"dijkstra","permalink":"https://solodance.top/tags/dijkstra/"}]},{"title":"HDU - 6672 Seq（打表找规律）","date":"2020-01-23T13:42:34.494Z","path":"2020/01/23/HDU - 6672 Seq（打表找规律）/","text":"题目描述题目链接 分析当时做题的时候没理解清题意就开始做了， 一开始想打表找规律但是当时根本就没认真看或者没看懂， 因为觉得是数论题， 赛后看题解才发现是打表找规律。 很容易看出来， 没到几个就会出现 a[i] = i - 1 或者 a[i] = i / 2 这种情况， 那就取两个a[i] = i - 1之间找规律， 然后发现了ac代码里的那个规律。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8typedef long long ll;typedef std::pair&lt;int, int&gt; P;const int N = 2e5 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); ll n; int t; std::cin &gt;&gt; t; while(t--)&#123; std::cin &gt;&gt; n; int x = n % 6; switch (x) &#123; case 0: &#123; n /= 2; break; &#125; case 1: &#123; n = 5 + (n / 6 - 1) * 4; break; &#125; case 2:&#123; n /= 2; break; &#125; case 3: &#123; n /= 6; break; &#125; case 4: &#123; n--; break; &#125; case 5: &#123; n /= 6; break; &#125; &#125; std::cout &lt;&lt; n &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"打表","slug":"打表","permalink":"https://solodance.top/tags/%E6%89%93%E8%A1%A8/"},{"name":"找规律","slug":"找规律","permalink":"https://solodance.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}]},{"title":"HDU - 6713 最短路1（思维）","date":"2020-01-23T13:42:34.494Z","path":"2020/01/23/HDU - 6713 最短路1（思维）/","text":"题目大意题目链接 有一张 n 个点的完全无向图，点的标号是 1…n，其中边 (i,j) 的长度是 i xor j，现在你需要求出点 1 到点 n 的最短路的长度。 分析异或的特殊性， 从1 到 n 不论怎么走， 路径的最后一步， 即 某个点 x 到 n 点的距离是 1 ^ n， 让1 ~ n 的路径最小那就让 x为1 就好了。 AC代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8typedef long long ll;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); int t, n; std::cin &gt;&gt; t; while(t--)&#123; std::cin &gt;&gt; n; int x = (1 ^ n); std::cout &lt;&lt; x &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维题","slug":"思维题","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"}]},{"title":"HDU - 3294Girls' research（马拉车的应用）","date":"2020-01-23T13:42:34.478Z","path":"2020/01/23/HDU - 3294Girls' research（马拉车的应用）/","text":"题目描述题目链接 One day, sailormoon girls are so delighted that they intend to research about palindromic strings. Operation contains two steps:First step: girls will write a long string (only contains lower case) on the paper. For example, “abcde”, but ‘a’ inside is not the real ‘a’, that means if we define the ‘b’ is the real ‘a’, then we can infer that ‘c’ is the real ‘b’, ‘d’ is the real ‘c’ ……, ‘a’ is the real ‘z’. According to this, string “abcde” changes to “bcdef”.Second step: girls will find out the longest palindromic string in the given string, the length of palindromic string must be equal or more than 2. InputInput contains multiple cases.Each case contains two parts, a character and a string, they are separated by one space, the character representing the real ‘a’ is and the length of the string will not exceed 200000.All input must be lowercase.If the length of string is len, it is marked from 0 to len-1. OutputPlease execute the operation following the two steps.If you find one, output the start position and end position of palindromic string in a line, next line output the real palindromic string, or output “No solution!”.If there are several answers available, please choose the string which first appears. Sample Input12b babda abcd Sample Output1230 2azaNo solution! 题解题意: 一开始输入的字母起得是变换作用， 比如， 若输入b， 就把原来子串所有字母减一， 若输入z 就把所有字母加一。 当着这个条件最后输出的时候变换一下就行， 不用把整个串变换。 找出最长回文串， 若长度相同只取最先出现的。要是不明白马拉车的实现原理， 那就给你推荐两篇博客：博客1博客2 关键就是在这两步的处理上， 详情看代码注释 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;char s[3 * N], str[3 * N];int len[3 * N], l, indx;void init()&#123; int cnt = 0; str[cnt++] = '$'; for (int i = 0; i &lt; l; i++)&#123; str[cnt++] = '#'; str[cnt++] = s[i]; &#125; str[cnt++] = '#'; l = cnt;&#125;int manacher()&#123; int mx = 0, id = 0; int ans = 0; len[0] = 1; for (int i = 1; i &lt; l; i++)&#123; if (i &lt; mx) len[i] = min(len[2 *id - i], mx - i); else len[i] = 1; while(str[i - len[i]] == str[i + len[i]]) len[i] ++; if (i + len[i] &gt; mx)&#123; id = i; mx = i + len[i]; if (ans &lt; len[i])&#123;// 注意这里是 小于，取得是第一次出现的 若是小于等于， 就是取最后一次出现的 ans = len[i]; indx = i; // 记录最长回文串的中心位置， 这是str的！！！， 用来输出该回文串所在的位置 &#125; &#125; &#125; return ans - 1;&#125;int main() &#123; char c; int L, R; while(~scanf(\"%c %s\", &amp;c, s))&#123; getchar(); // 加个getchar() 吃回车还是啥的巴拉巴拉 这个做的时候具体看看吧// cout &lt;&lt; c &lt;&lt; \" \" &lt;&lt; s &lt;&lt; \"!!!!!\\n\"; l = strlen(s); init(); l = manacher(); if (l &lt;= 1) puts(\"No solution!\"); else&#123; L = indx - l + 1;//这是最长回文串 str的左边界 R = indx + l - 1;//这是最长回文串 str的右边界， 自己画画图就可以得到 printf(\"%d %d\\n\", L / 2 - 1, R / 2 - 1); // 这是str的坐标y 和 s的坐标 x 满足的关系 y = 2 * (x + 1), 具体的关系式还是要看你的init() for (int i = L; i &lt;= R; i += 2)&#123; printf(\"%c\", 'a' + (str[i] - c + 26) % 26); // 这是一个取余处理 ， 为什么这样可以呢， 请读者深思~ &#125; putchar(10); &#125; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"Manacher","slug":"Manacher","permalink":"https://solodance.top/tags/Manacher/"}]},{"title":"HDU - 4513 吉哥系列故事——完美队形II（马拉车的应用）","date":"2020-01-23T13:42:34.478Z","path":"2020/01/23/HDU - 4513 吉哥系列故事——完美队形II（马拉车的应用）/","text":"题目描述题目链接 吉哥又想出了一个新的完美队形游戏！ 假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] … h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形： 1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的； 2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意； 3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &lt;= H[2] &lt;= H[3] …. &lt;= H[mid]。 现在吉哥想知道：最多能选出多少人组成新的完美队形呢？ Input 输入数据第一行包含一个整数T，表示总共有T组测试数据(T &lt;= 20)； 每组数据首先是一个整数n(1 &lt;= n &lt;= 100000)，表示原先队形的人数，接下来一行输入n个整数，表示原队形从左到右站的人的身高（50 &lt;= h &lt;= 250，不排除特别矮小和高大的）。 Output 请输出能组成完美队形的最多人数，每组输出占一行。 Sample Input123452351 52 51451 52 52 51 Sample Output1234 题解马拉车的一点点变形， 具体请看ac代码要是不明白马拉车的实现原理， 那就给你推荐两篇博客：博客1博客2 认真看完， 自己动手， 绝对有所收获。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int s[3 * N], str[3 * N];int len[3 * N], l;void init()&#123; int cnt = 0; str[cnt++] = -2; for (int i = 0; i &lt; l; i++)&#123; str[cnt++] = -1; str[cnt++] = s[i]; &#125; str[cnt++] = -1; l = cnt;&#125;int manacher()&#123; int mx = 0, id = 0; int ans = 0; len[0] = 1; for (int i = 1; i &lt; l; i++)&#123; if (i &lt; mx) len[i] = min(len[2 *id - i], mx - i); else len[i] = 1; while(str[i - len[i]] == str[i + len[i]] &amp;&amp; str[i - len[i]] &lt;= str[i - len[i] + 2]) //这一这里多了一个判断是为了满足条件：H[1] &lt;= H[2] &lt;= H[3] .... &lt;= H[mid]。 ， 就这点变形 len[i] ++; if (i + len[i] &gt; mx)&#123; id = i; mx = i + len[i]; ans = max(ans, len[i]); &#125; &#125; return ans - 1;&#125;int main() &#123; int t, n; scanf(\"%d\", &amp;t); while(t--)&#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf(\"%d\", &amp;s[i]); &#125; l = n; init(); printf(\"%d\\n\", manacher()); &#125;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"Manacher","slug":"Manacher","permalink":"https://solodance.top/tags/Manacher/"}]},{"title":"HDU - 5882（思维+水题）","date":"2020-01-23T13:42:34.478Z","path":"2020/01/23/HDU - 5882（思维+水题）/","text":"题目描述：题目链接Rock-paper-scissors is a zero-sum hand game usually played between two people, in which each player simultaneously forms one of three shapes with an outstretched hand. These shapes are “rock”, “paper”, and “scissors”. The game has only three possible outcomes other than a tie: a player who decides to play rock will beat another player who has chosen scissors (“rock crushes scissors”) but will lose to one who has played paper (“paper covers rock”); a play of paper will lose to a play of scissors (“scissors cut paper”). If both players choose the same shape, the game is tied and is usually immediately replayed to break the tie. Recently, there is a upgraded edition of this game: rock-paper-scissors-Spock-lizard, in which there are totally five shapes. The rule is simple: scissors cuts paper; paper covers rock; rock crushes lizard; lizard poisons Spock; Spock smashes scissors; scissors decapitates lizard; lizard eats paper; paper disproves Spock; Spock vaporizes rock; and as it always has, rock crushes scissors. Both rock-paper-scissors and rock-paper-scissors-Spock-lizard are balanced games. Because there does not exist a strategy which is better than another. In other words, if one chooses shapes randomly, the possibility he or she wins is exactly 50% no matter how the other one plays (if there is a tie, repeat this game until someone wins). Given an integer N, representing the count of shapes in a game. You need to find out if there exist a rule to make this game balanced. InputThe first line of input contains an integer t, the number of test cases. t test cases follow.For each test case, there is only one line with an integer N (2≤N≤1000), as described above. Here is the sample explanation. In the first case, donate two shapes as A and B. There are only two kind of rules: A defeats B, or B defeats A. Obviously, in both situation, one shapes is better than another. Consequently, this game is not balanced. In the second case, donate two shapes as A, B and C. If A defeats B, B defeats C, and C defeats A, this game is balanced. This is also the same as rock-paper-scissors. In the third case, it is easy to set a rule according to that of rock-paper-scissors-Spock-lizard. OutputFor each test cases, output “Balanced” if there exist a rule to make the game balanced, otherwise output “Bad”. Sample Input12343235 Sample Output123BadBalancedBalanced 题解首先说这是很水的一道题， 我是到最后才看清题意，Given an integer N, representing the count of shapes in a game.本来我是以为只有石头剪刀布还有5种shape这两种玩法， 然后就各种对5对3取余。。。。后来发现大错特错。题意： 给你n种shape， 让你判断是不是平衡的。何谓平衡？ 这是重点。举几个例子你就明白了。当n = 2 时， 两个shape， 对于每个shape， 只有一个出边， 或者入边， 这就是不平衡。当n = 3 时， 三个shape， 对于每个shape， 他会有两个边， 一个入边一个出边（想想三角形就明白了， 至于入边和出边， 画了图， 就明白了了）， 这就是平衡（入边数和出边数相同）。当n = 4 时， 四个shape， 对于每个shape， 他会有三个边， 那就只有两种情况 2个入边1个出边 和 2个出边1个入边 ， 这明显是不平衡的。当n = 5 时， 五个shape， 对于每个shape， 他会有四个边， 两个入边两个出边， 所以是平衡的。 好了， 规律就有了：当n为奇数时， 平衡。当n为偶数时， 不平衡。 AC代码： 123456789101112131415161718192021222324252627282930313233//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include \"algorithm\"#include \"cstdio\"#include \"queue\"#include \"set\"#include \"cstring\"#include \"string\"#include \"map\"#include \"vector\"#include \"math.h\"#include \"utility\" // pair头文件#define esp 1e-6using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;int main()&#123; ios::sync_with_stdio(0); int t, n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; if (n % 2 == 1) puts(\"Balanced\"); else puts(\"Bad\"); &#125;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维","slug":"思维","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"水题","slug":"水题","permalink":"https://solodance.top/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"HDU - 6669 Game （模拟）","date":"2020-01-23T13:42:34.478Z","path":"2020/01/23/HDU - 6669 Game （模拟）/","text":"题目大意题目链接 一个数轴， 里面有n个区间， 每次行走只能走1个或者2个格子， 让你按照所给区间顺序依次到达这n个区间的最小步数。 分析说是模拟但是我觉得更像思维题。设l， r为状态区间[l, r]， 这个状态区间只有两个状态：l == r || l + 1 == r。为什么呢？如果状态区间与新加入的区间的距离为偶数， 那就令状态区间为 l = r = 端点， 如果为奇数， 那么有两种情况 l = r = 端点 或者r = 端点 l = r - 1。请读者好好理解下~ 还有对l，r的初始化问题， 我自己想的初始化时 l = a1, r = b1， 但是看大佬们的初始化是l = 1, r = 1000000 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8typedef long long ll;typedef std::pair&lt;int, int&gt; P;const int N = 1e6 + 5;const int INF = 0x3f3f3f3f;const ll llINF = 0x3f3f3f3f3f3f3f3f;int l, r;int solve(int x, int y)&#123; int ll = std::max(l, x); int rr = std::min(r, y); if (ll &lt;= rr)&#123; l = ll; r = rr; return 0; &#125; int res; if (y &lt; l) &#123; // 如果新区间在状态区间的左边 res = l - y + 1 &gt;&gt; 1; r = y; if ((l - y) % 2 == 1 &amp;&amp; x != y) l = y - 1; else l = y; &#125; else&#123; res = x - r + 1 &gt;&gt; 1; l = x; if ((x - r) % 2 == 1 &amp;&amp; x != y) r = x + 1; else r = x; &#125; return res;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); int t, n, a, b; std::cin &gt;&gt; t; ll ans; while(t--)&#123; l = r = -1; ans = 0; std::cin &gt;&gt; n; while(n--)&#123; std::cin &gt;&gt; a &gt;&gt; b; if (l == r &amp;&amp; l == -1) // 若是初始化l = 1, r = 1000000， 那就直接放在循环外面即可， l = a, r = b; else ans += solve(a, b); &#125; std::cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维","slug":"思维","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4/"},{"name":"模拟","slug":"模拟","permalink":"https://solodance.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"CodeForces - 848A From Y to Y（思维）","date":"2020-01-23T13:42:34.462Z","path":"2020/01/23/CodeForces - 848A From Y to Y（思维）/","text":"题目描述题目链接 A. From Y to Ytime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard output From beginning till end, this message has been waiting to be conveyed. For a given unordered multiset of n lowercase English letters (“multi” means that a letter may appear more than once), we treat all letters as strings of length 1, and repeat the following operation n - 1 times: Remove any two elements s and t from the set, and add their concatenation s + t to the set.The cost of such operation is defined to be , where f(s, c) denotes the number of times character c appears in string s. Given a non-negative integer k, construct any valid non-empty set of no more than 100 000 letters, such that the minimum accumulative cost of the whole process is exactly k. It can be shown that a solution always exists. InputThe first and only line of input contains a non-negative integer k (0 ≤ k ≤ 100 000) — the required minimum cost. OutputOutput a non-empty string of no more than 100 000 lowercase English letters — any multiset satisfying the requirements, concatenated to be a string. Note that the printed string doesn’t need to be the final concatenated string. It only needs to represent an unordered multiset of letters. Examplesinput12outputababababinput3outputcodeforces NoteFor the multiset {‘a’, ‘b’, ‘a’, ‘b’, ‘a’, ‘b’, ‘a’, ‘b’}, one of the ways to complete the process is as follows: {“ab”, “a”, “b”, “a”, “b”, “a”, “b”}, with a cost of 0;{“aba”, “b”, “a”, “b”, “a”, “b”}, with a cost of 1;{“abab”, “a”, “b”, “a”, “b”}, with a cost of 1;{“abab”, “ab”, “a”, “b”}, with a cost of 0;{“abab”, “aba”, “b”}, with a cost of 1;{“abab”, “abab”}, with a cost of 1;{“abababab”}, with a cost of 8.The total cost is 12, and it can be proved to be the minimum cost of the process. 题解题意：对于字符串s和字符c， f(s, c)表示c在s中出现的次数， 若将c合并到s中， 则花费f(s, c)，要求求一个字符串， 是的合并后的最小话费恰好等于k。思路：可以发现， 只有一种字符的字符串s， 若他的长度为n， 则花费 n * (n - 1) / 2。这点是非常重要的， 啧啧啧， 奇妙的题， 发现这个规律就好办了， 这里我用到了二分。 若对我使用的二分有疑问， 请看这篇博客 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define esp 1e-6using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e4 + 5;const int M = 1e9 + 5;const int mod = 998244353;int binary_search(int a[], int low, int high, int key)&#123; // 二分查找第一个小于等于key的值得下标 int m; while(low &lt; high)&#123; m = low + (high - low + 1) / 2; //从后往前， 向上取整 if (a[m] &lt;= key) low = m; else high = m - 1; // 后往前， 改变的是high &#125; if(a[low] &lt;= key) return low; return -1;&#125;int sum[N];int main()&#123; for (int i = 0; i &lt;= 150; i++)&#123; sum[i] = i * (i - 1) / 2; &#125;// 打表 int k, cnt; cin &gt;&gt; k; for (int i = 'a'; i &lt;= 'z'; i++)&#123; cnt = binary_search(sum, 0, 150, k); for (int j = 1; j &lt;= cnt; j++) printf(\"%c\", i); k -= sum[cnt]; if (k == 0) break; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维题","slug":"思维题","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"}]},{"title":"Codeforce928A - Login Verification（模拟）","date":"2020-01-23T13:42:34.447Z","path":"2020/01/23/Codeforce928A - Login Verification（模拟）/","text":"题目大意题目链接 检查是否有相似的用户名， 有就输出no， 没有就输出yes， 它有如下规则： 大小写字母互相转换 将大写拉丁字母O和数字0互换 数字1和字母L,I互换 思路一开始多想了， 这么多情况， 后来想着想着发现全都换成一种格式比较就好了~也发现了一个很有意思的函数 AC代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; string s, t; int n; cin &gt;&gt; s &gt;&gt; n; for (int i = 0; i &lt; s.size(); i++) &#123; s[i] = tolower(s[i]); // 将大写转换为小写 if (s[i] == 'o') s[i] = '0'; if (s[i] == 'l') s[i] = '1'; if (s[i] == 'i')s[i] = '1'; &#125; while (n--) &#123; cin &gt;&gt; t; for (int i = 0; i &lt; t.size(); i++) &#123; t[i] = tolower(t[i]); if (t[i] == 'o') t[i] = '0'; if (t[i] == 'l')t[i] = '1'; if (t[i] == 'i')t[i] = '1'; &#125; if (s == t) &#123; puts(\"No\"); return 0; &#125; &#125; puts(\"Yes\"); return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"模拟","slug":"模拟","permalink":"https://solodance.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"codeforce569A- Music","date":"2020-01-23T13:42:34.432Z","path":"2020/01/23/codeforce569A- Music/","text":"A. Musictime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLittle Lesha loves listening to music via his smartphone. But the smartphone doesn’t have much memory, so Lesha listens to his favorite songs in a well-known social network InTalk. Unfortunately, internet is not that fast in the city of Ekaterinozavodsk and the song takes a lot of time to download. But Lesha is quite impatient. The song’s duration is T seconds. Lesha downloads the first S seconds of the song and plays it. When the playback reaches the point that has not yet been downloaded, Lesha immediately plays the song from the start (the loaded part of the song stays in his phone, and the download is continued from the same place), and it happens until the song is downloaded completely and Lesha listens to it to the end. For q seconds of real time the Internet allows you to download q - 1 seconds of the track. Tell Lesha, for how many times he will start the song, including the very first start. InputThe single line contains three integers T, S, q (2 ≤ q ≤ 104, 1 ≤ S &lt; T ≤ 105). OutputPrint a single integer — the number of times the song will be restarted. 题意：Lesha在线听歌， 但是网速不够快 每过q秒只能下载q - 1 秒， 这首歌总共t秒， 一开始已经下载了s秒， 每次从头播放， 每当播放到未下载的地方， 就会重新播放， 问一共播放几次？解：设第一次 经过x秒 听得时间和下载的时间相同 即s + (q - 1) / q * x = x（要把这个弯转过来） 解得 x = q * s设第二次 经过t秒 听得时间和下载的时间相同 即x + (q - 1) / q * x = x （注意是x 而不是 s + x 看来是我老了傻了） 解得 t = q * x这就看出来咯 每一次 听得时间和下载时间相同时 就是原起始时间乘q 然后边界情况自己想呗。 ac代码： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e6 + 5;int main()&#123; ll t, s, q, sum = 0; while(cin &gt;&gt; t &gt;&gt; s &gt;&gt; q)&#123; // 为啥用多组输入呢， 因为输入测试数据的时候方便 ll x; sum = 1; x = q * s; while(x &lt; t)&#123; sum ++; x = q * x; &#125; cout &lt;&lt; sum &lt;&lt; \"\\n\"; &#125; return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维","slug":"思维","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"CLion 输出遇到乱码解决办法","date":"2020-01-23T13:42:34.400Z","path":"2020/01/23/CLion 输出遇到乱码解决办法/","text":"更改设置：File -&gt; Settings -&gt; Default Settings -&gt; Editor -&gt; File Encodings:Global Encoding: UTF-8Project Encoding : UTF-8Default encoding for properties files: UTF-8 看图： 别着急，还有一步：这里选GBK 然后convert 完事！ 这里有个弊端就是每新建一个文件就要更改成GBK 这里有个大佬的博客有一个一劳永逸的办法，但是有失就有得， 自己取舍吧， 反正我觉得倒是无所谓。大佬博客： 链接 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"clion","slug":"clion","permalink":"https://solodance.top/tags/clion/"},{"name":"输出乱码","slug":"输出乱码","permalink":"https://solodance.top/tags/%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81/"}]},{"title":"Codeforce260B - Ancient Prophesy（模拟）","date":"2020-01-23T13:42:34.400Z","path":"2020/01/23/Codeforce260B - Ancient Prophesy（模拟）/","text":"题目大意题目链接 大意： 给你一串字符串， 让你找出现次数最多的合法日期， 日期格式dd-mm-yyyy，其中yyyy 范围是2013 to 2015（因为这个降低了不少难度） 思路： 每次取10个字母判断是不是合法的， 同时用map计数。 具体实现看代码 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;set&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define eps 1e-8using namespace std;typedef long long ll;const int MAX = 2e5 + 5;char s[MAX];char tmp[15];string ans;int month[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; // 2013 to 2015 没有闰年map&lt;string, int&gt; mp;map&lt;string, int&gt;::iterator it;int main() &#123; cin &gt;&gt; s; int len = strlen(s); for (int i = 0; i &lt;= len - 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; tmp[j] = s[j + i]; &#125;// 每次取10个 tmp[10] = '\\0'; if (tmp[6] != '2' || tmp[7] != '0' || tmp[8] != '1') continue; if (tmp[9] != '3' &amp;&amp; tmp[9] != '4' &amp;&amp; tmp[9] != '5') continue; if (tmp[2] != '-' || tmp[5] != '-') continue; if (!isdigit(tmp[0]) || !isdigit(tmp[1]) || !isdigit(tmp[3]) || !isdigit(tmp[4]) || !isdigit(tmp[6]) || !isdigit(tmp[7]) || !isdigit(tmp[8]) || !isdigit(tmp[9])) //不知道这个函数自己手写一个也可 continue; int yue = (tmp[3] - '0') * 10 + tmp[4] - '0'; if (yue &lt;= 0 || yue &gt; 12) continue; int day = (tmp[0] - '0') * 10 + tmp[1] - '0'; if (day &gt; month[yue] || day &lt;= 0) continue; mp[tmp]++;//map记数 &#125; it = mp.begin(); int maxx = 0; for (; it != mp.end(); ++it) &#123; // 遍历map if (maxx &lt; (it-&gt;second)) &#123; maxx = it-&gt;second; ans = it-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"模拟","slug":"模拟","permalink":"https://solodance.top/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"c++数据范围","date":"2020-01-23T13:42:34.370Z","path":"2020/01/23/c++数据范围/","text":"详情见下： 123456789101112char -128 ~ +127 (1 Byte) (-2^(8*1-1) ~ 2^(8*1-1)-1) short -32767 ~ + 32768 (2 Bytes) (-2^(8*2-1) ~ 2^(8*2-1)-1)unsigned short 0 ~ 65535 (2 Bytes) (0 ~ 2^(8*2)-1)int -2147483648 ~ +2147483647 (10位数) (4 Bytes) (-2^(8*4-1) ~ 2^(8*4-1)-1 )unsigned int 0 ~ 4294967295 (4 Bytes) (0 ~ 2^(8*4-1)-1 )long == intlong long -9223372036854775808 ~ +9223372036854775807 (19位数) (8 Bytes) (-2^(8*8-1) ~ 2^(8*8-1)-1 )long long == __int64 == int64_tunsign long long 0 ~ 18446744073709551615 (20位数) (8 Bytes) (0 ~ 2^(8*8-1) )double 1.7 * 10^308 (8 Bytes) //这个不怎么确定__int128 -170141183460469231731687303715884105728 ~ 170141183460469231731687303715884105727 (39位数) (16 Bytes) (-2^(8*16-1) ~ 2^(8*16-1)-1) 注： __int64 和 long long 的区别 ： 点此 关于__int128的使用注意事项 能在Linux下使用， 还能再mingw64下使用。 Cion配置MinGW64， 详情点击 需要自己写读入输出挂 详情见博客： 点此 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"数据类型范围","slug":"数据类型范围","permalink":"https://solodance.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%8C%83%E5%9B%B4/"}]},{"title":"c++map的遍历和按照key，value排序","date":"2020-01-23T13:42:34.354Z","path":"2020/01/23/c++map的遍历和按照key，value排序/","text":"c++map的遍历和按照key，value排序map的遍历12345map&lt;int, int&gt;ma;map&lt;int, int&gt;::iterator it;for(it = ma.begn(); it != ma.end(); it++)&#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; \"\\n\"; //first 是key , second 是 value&#125; c++ map 默认按照key值排序 按照值排序方法： 将key的value储存在pair类型的vector 中， 按照vector排序 1234567891011121314151617181920bool cmp(const pair&lt;int,int&gt; &amp;p1,const pair&lt;int,int&gt; &amp;p2) &#123;//要用常数，不然编译错误 return p1.second &lt; p2.second;&#125;int main()&#123; map&lt;int,int&gt; mp; mp[1]=4; mp[2]=3; mp[3]=2; mp[4]=1; vector&lt;pair&lt;int,int&gt; &gt; arr;// pair 在头文件 utility for (map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; cout&lt;&lt; it-&gt;first &lt;&lt; '\\t' &lt;&lt; it-&gt;second &lt;&lt; \"\\n\"; arr.push_back(make_pair(it-&gt;first,it-&gt;second)); &#125; sort(arr.begin(), arr.end(), cmp); for (vector&lt;pair&lt;int,int&gt; &gt;::iterator it=arr.begin();it!=arr.end();it++)&#123; cout &lt;&lt; it-&gt;first &lt;&lt; '\\t' &lt;&lt; it-&gt;second &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，较弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"stl","slug":"stl","permalink":"https://solodance.top/tags/stl/"},{"name":"map","slug":"map","permalink":"https://solodance.top/tags/map/"}]},{"title":"c++map遍历排序","date":"2020-01-23T13:42:34.338Z","path":"2020/01/23/c++map遍历，排序/","text":"遍历map也有迭代器 1234map&lt;char, int&gt; ::iterator it;for (map&lt;char, int&gt; ::iterator it = ma.begin(); it != ma.end(); it ++)&#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it -&gt; second &lt;&lt; \"\\n\"; &#125; 排序默认的map是按照key值从小到大排序。可以加个参数让其从大到小排序： 1map &lt;string, int, greater&lt;string&gt; &gt; ma; 按照value排序， 利用了map和pair对应的关系，在加上vector的sort排序。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;typedef pair&lt;string, int&gt; P;bool cmp(const P &amp;p1, const P &amp;p2)&#123; return p1.second &gt; p2.second;&#125; // 设置优先级map&lt;string, int&gt; ma;map&lt;string, int&gt; ::iterator it;vector&lt;P&gt; ve;int main() &#123; for (it = ma.begin(); it != ma.end(); it++)&#123; ve.push_back(P(it-&gt;first, it-&gt;second)); &#125; sort(ve.begin(), ve.end(), cmp); return 0;&#125;","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小技巧","slug":"小技巧","permalink":"https://solodance.top/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"stl-map","slug":"stl-map","permalink":"https://solodance.top/tags/stl-map/"}]},{"title":"c++11 emplace 与 push 的区别","date":"2020-01-23T13:42:34.323Z","path":"2020/01/23/c++11 emplace 与 push 的区别/","text":"c++11 emplace 与 push 的区别 直接传入对象（type） 123456789class data&#123; int a, b; public: data(int x, int y) : a(x), b(y)&#123;&#125; &#125;; data x(5, 2); queue&lt;data&gt; q1; q1.push(x); q1.emplace(x); 传入时构造函数 12q1.push(data(5, 2));q1.emplace(data(5, 2)); emplace 可以直接传入构造对象需要的元素， 然后自己调用其构造函数1q1.emplace(5, 2); 第三种方法更节省内存 注意 123emplace_back(type) 对应 push_back(type)emplace_(i, type) 对应 insert(typy, i)emplace_front(type) 对应 push_front(type) 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"stl","slug":"stl","permalink":"https://solodance.top/tags/stl/"},{"name":"c++11","slug":"c-11","permalink":"https://solodance.top/tags/c-11/"}]},{"title":"C++ 流控制函数setw()、setfill()、setbase()、setprecision()的使用","date":"2020-01-23T13:42:34.307Z","path":"2020/01/23/C++ 流控制函数/","text":"C++ 流控制函数setw()、setfill()、setbase()、setprecision()的使用 ps : 为什么要提这个呢， 因为在c++ 中 %.2f 输出double 型可能会报错 头文件12#include &lt;iostream&gt;#include &lt;iomanip&gt; 功能std::setw ：需要填充多少个字符,默认填充的字符为’ ‘空格 std::setfill：设置std::setw将填充什么样的字符，如:std::setfill(‘*’) std::setbase(n)：将输出数据转换为n进制 std::setprecision()：控制输出流显示浮点数的数字个数，C++默认的流输出数值有效位是6。 样例123456789cout &lt;&lt; setfill('0') &lt;&lt; setw(5) &lt;&lt; 111 &lt;&lt; \"\\n\"; // 若填充的位数小于数字的位数， 则输出原数字// 等价于 printf(\"%05d\\n\", a = 111);cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(5) &lt;&lt; 3.1415926 &lt;&lt; \"\\n\";//等价于printf(\"%.5f\\n\", a = 3.1415926);cout &lt;&lt; setprecision(5) &lt;&lt; 3.1415926 &lt;&lt; \"\\n\"; // 保留的数字的总位数是5位 最后附上一个C++ cout格式化输出（输出格式）完全攻略链接","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"小技巧","slug":"小技巧","permalink":"https://solodance.top/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"C++ 流控制函数","slug":"C-流控制函数","permalink":"https://solodance.top/tags/C-%E6%B5%81%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/"}]},{"title":"c、c++头文件中预编译的作用","date":"2020-01-23T13:42:34.291Z","path":"2020/01/23/c、c++头文件中预编译的作用/","text":"c、c++头文件中预编译的作用在头文件中加入#ifndef或#ifdef等宏定义，是为了防止重复声明。 我们知道，头文件一般是用来声明的，会被其他的源文件和头文件include，当被多个文件include的时候就会造成重复声明。 为了使得只声明一次，引入前面所说的宏定义，一般以文件名大写和_来当宏的名字。 这个宏是给预处理器用的，通常预处理变量用大写，所以这些宏定义都用大写。为了方便，一般将大写的文件名作为预处理器变量，其实在#ifndef后面加什么都都可以，用文件名只是为了好区分。它只是用来定义一个预处理器变量。 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量重定义的错误。在头文件中实用#ifndef #define #endif能避免头文件的重定义。 方法：例如要编写头文件test.h在头文件开头写上两行： 12#ifndef _TEST_H#define _TEST_H//一般是文件名的大写 头文件结尾写上一行：#endif这样一个工程文件里同时包含两个test.h时，就不会出现重定义的错误了。分析：当第一次包含test.h时，由于没有定义_TEST_H，条件为真，这样就会包含（执行）#ifndef _TEST_H和#endif之间的代码，当第二次包含test.h时前面一次已经定义了_TEST_H，条件为假，#ifndef _TEST_H和#endif之间的代码也就不会再次被包含，这样就避免了重定义了。主要用于防止重复定义宏和重复包含头文件 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"c，c++头文件","slug":"c，c-头文件","permalink":"https://solodance.top/tags/c%EF%BC%8Cc-%E5%A4%B4%E6%96%87%E4%BB%B6/"}]},{"title":"ACM中关于文件的读入输出","date":"2020-01-23T13:42:34.275Z","path":"2020/01/23/ACM中关于文件的读入输出/","text":"直接看下面代码 123456789101112131415161718192021int main()&#123; FILE *fp; FILE *fpw = fopen(\"output.txt\", \"w\"); if ((fp = fopen(\"input.txt\", \"r\")) == NULL) exit(1); int n, k; int i = -1; while(!feof(fp))&#123; // 这个视情况而定 if (i == -1) fscanf(fp, \"%d %d\", &amp;n, &amp;k); else&#123; fscanf(fp, \"%d\", &amp;a[i]); b[i] = a[i]; &#125; i++; &#125; fprintf(fpw, \"%d\\n\", minn); return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"文件读入输出","slug":"文件读入输出","permalink":"https://solodance.top/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA/"},{"name":"acm小知识","slug":"acm小知识","permalink":"https://solodance.top/tags/acm%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"2019牛客国庆集训派对day6  H-Super Fast Fourier Transform(思维)","date":"2020-01-23T13:42:34.259Z","path":"2020/01/23/2019牛客国庆集训派对day6  H-Super Fast Fourier Transform(思维)/","text":"题目大意题目链接 分析因为a1 + s2 + ... + an &lt;= 1e6 并且 n &lt;= 1e5， 可以看出应该有很多重读的数， 统计一下， 暴力解决。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;map&gt;#include &lt;set&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define eps 1e-8using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const ll ll_max = 4557430888798830399;unordered_map&lt;int, int&gt; ma;unordered_map&lt;int, int&gt; mb;int a[N], b[N];int main()&#123; ios::sync_with_stdio(false);// cin.tie(nullptr); int n, m, x; while(cin &gt;&gt; n &gt;&gt; m)&#123; int c1 = 0, c2 = 0; ma.clear(); mb.clear(); while(n--)&#123; cin &gt;&gt; x; if (ma[x] == 0) &#123; a[c1++] = x; ma[x] = 1; &#125; else ma[x]++; &#125; while(m--)&#123; cin &gt;&gt; x; if (mb[x] == 0)&#123; b[c2++] = x; mb[x]++; &#125; else mb[x]++; &#125; ll ans = 0; for (int i = 0; i &lt; c1; ++i)&#123; for (int j = 0; j &lt; c2; ++j)&#123; ans += ll(ma[a[i]]) * ll(mb[b[j]]) * ll(sqrt(fabs(a[i] - b[j]))); &#125; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125; 1恰似你一低头的温柔，娇弱水莲花不胜寒风的娇羞， 我的心为你悸动不休。 --mingfuyan","tags":[{"name":"acm","slug":"acm","permalink":"https://solodance.top/tags/acm/"},{"name":"思维题","slug":"思维题","permalink":"https://solodance.top/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"}]},{"title":"Hello World","date":"2020-01-23T09:42:22.821Z","path":"2020/01/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]